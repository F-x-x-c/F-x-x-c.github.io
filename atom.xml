<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aegis</title>
  
  <subtitle>Aegis Curiser</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-10T14:59:50.306Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Deng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>判断2</title>
    <link href="http://example.com/2023/04/10/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q002-xing-ce-pan-duan-2/"/>
    <id>http://example.com/2023/04/10/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q002-xing-ce-pan-duan-2/</id>
    <published>2023-04-10T12:24:18.000Z</published>
    <updated>2023-04-10T14:59:50.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断2"><a href="#判断2" class="headerlink" title="判断2"></a>判断2</h1><h2 id="空间类"><a href="#空间类" class="headerlink" title="空间类"></a>空间类</h2><p>常见立体截面图:   </p><p>能切:   </p><ol><li><p>正方体,   长方体</p><p>(1) 矩形:   拦腰切(横着切),   上下切(从上往下垂直切),   斜切(平行于某一条棱往内切)</p><p>(2) 梯形:   斜切(从上往下斜着切)</p><p>(3) 三角形:   从棱上的某一点开始斜着往内切</p><p>(4) 六面体只能切出锐角三角形</p></li><li><p>圆柱</p><p>(1) 圆(横切)    (2) 椭圆(斜切)    (3) 矩形(竖切)    [圆柱切不出梯形!]</p></li><li><p>圆锥</p><p>(1) 圆(横切)    (2) 椭圆(斜切)    (3) 三角形(竖切)</p></li><li><p>圆台</p><p>(1) 圆(横切)    (2) 椭圆(斜切)    (3) 梯形(竖切)</p></li></ol><p>不能切:   </p><p>(1) 正方体长方体不能切出直角三角形和钝角三角形;   </p><p>(2) 刀不能拐弯;   不同方向的截面不能出现在同一个选项中;   </p><p>(3) 空心图形:   切的时候如果没有碰到果肉,   则不能划线;   </p><h2 id="立体拼合"><a href="#立体拼合" class="headerlink" title="立体拼合"></a>立体拼合</h2><p>先确定是几乘几的立体图;   如果贴合完成之后是一个3*3的立体图,   那么可以数每一层的小方块数量,   如果是不规则立体,   则不要去数,   而是尝试去拼凑,   优先不考虑旋转;   </p><h2 id="定义判断"><a href="#定义判断" class="headerlink" title="定义判断"></a>定义判断</h2><p>要小心隐藏主体,   如果出现”帮助…”    “让…”,   则估计会从隐藏主体上挖坑,   在选择的时候一定要明确被隐藏的主体;   </p><p>如果题干中反复出现某一个奇奇怪怪的词,   那么它大概率是一个重要词语;   </p><p>限定词:   </p><ol><li>数量与种类的限定(互益素是<strong>一种</strong>生物释放的,   能引起<strong>它种接受生物</strong>…的…)</li><li>主动被动的限定(众人自发形成…法律规定)</li><li>直接间接(能够确保遭遇<strong>直接气候风险损失</strong>)</li><li>条件/大前提(在<strong>对每一个人都不信任</strong>的基础之上)</li><li>时间的限定(网络考古指对<strong>多年前</strong>网络上发表的各种文字图片…)</li></ol><blockquote><p>定义较长或难以读懂的题:   </p><p>单定义:   哪里读懂读哪里,   重复出现(的词语)很重要<br>多定义:   问谁就优先看谁</p><p>在做定义判断的时候,   如果出现了明确的项和不明确的项,   则优先选择明确的项;   </p><p>如果定义读不懂,   定义词又可以拆的话,   则考虑使用拆词去做题;   </p></blockquote><h2 id="组合排列"><a href="#组合排列" class="headerlink" title="组合排列"></a>组合排列</h2><p>注意:   如果说A和B在某些程度上相同,   则说明他们不是同一个人!</p><blockquote><p>列表技巧:   人作为列,   职位作为行;   如果确定了某个人的职位,   那么以这个人和这个职位相交的位置为中心,   十字画叉;   </p></blockquote><blockquote><p>4321秒杀技巧:   如果有4个人,   有一个条件是3个人满足,   有一个条件是2个人满足,   有一个条件是1个人满足或者4个人都满足;   则需要先找到满足3个人的那个条件,   找到不同的这个人(菜鸟);   然后找到满足2个人的那个条件,   找到不满足条件的两个人(菜鸟和他的队友),   这个队友就是答案;   </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断2&quot;&gt;&lt;a href=&quot;#判断2&quot; class=&quot;headerlink&quot; title=&quot;判断2&quot;&gt;&lt;/a&gt;判断2&lt;/h1&gt;&lt;h2 id=&quot;空间类&quot;&gt;&lt;a href=&quot;#空间类&quot; class=&quot;headerlink&quot; title=&quot;空间类&quot;&gt;&lt;/a&gt;空间类&lt;/h</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q001_行测_判断1</title>
    <link href="http://example.com/2023/04/10/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q001-xing-ce-pan-duan-1/"/>
    <id>http://example.com/2023/04/10/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q001-xing-ce-pan-duan-1/</id>
    <published>2023-04-10T06:31:12.000Z</published>
    <updated>2023-04-10T08:53:49.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><h2 id="面"><a href="#面" class="headerlink" title="面"></a>面</h2><p>图形被分割,   窟窿比较多,   生活化粗线条的留白图形;   </p><p>考法1:   整体去数面;   </p><p>考法2:   细化考点,   面与点线不同的是,   面时需要考虑形状的,   而点只有数量(当然可以跟)</p><p>(1) 所有面的形状;   在三角形和四边形居多的时候;   </p><p>(2) 相同形状的面;   有长得一样的奇怪图形;   </p><p>(3) 最面的形状或属性;   与外框的关系;  如果最面的形状比较常见,   则只看最面就行,   如果不常见,   则要看最面的关系或者是与外框的关系;   </p><blockquote><p>一定要注意特征图,   即有一两幅图片会明显提示这题要考啥,   一定要学会抓住;   比如出现那种大圆套小圆的,   还有明显最面的;   </p></blockquote><h2 id="线"><a href="#线" class="headerlink" title="线"></a>线</h2><p>特征图:   单一直线,   多边形出现,   优先数直线;   单一曲线,   圆,   弧出现,   优先数曲线;   </p><p>曲线和直线可以分开数,   曲线和直线也可以做运算;   </p><blockquote><p>曲直小总结:   曲直性,   曲直线(出现单一直线单一曲线),   曲直交点(每一幅图曲线与直线都有交点)</p></blockquote><p>平行线:   一般数组数,   也就是说,   同一方向的平行线为一组;   图形特征为同方向的线条成对出现;   如果有出头的线条,   先考虑笔画数,   如果总有与出头的线条方向平行的线要考虑平行线组数;   </p><p>笔画数:   </p><p>其特征图:   </p><p>(1) 外面一个框,   里面一条线,   为日字变形图;   </p><p>(2) 外面一个框,   里面两条线,   为田字变形图;   </p><p>(3) 多边形的相交,   相接;   </p><p>(4) 出头端点图;   </p><p>(5) 五角星,   因为能够一笔画出;   </p><p>(6) 多部分图形,   回字图形;   </p><img src="D:/Program%20Files/Typora/img/image-20230410144939824.png" alt="image-20230410144939824" style="zoom:80%;" /><p>线条交叉地非常凌乱,   交地非常硬(就是大树叉子),   而且交点过多的时候(数不了交点),   就考虑数笔画数;   </p><h2 id="点"><a href="#点" class="headerlink" title="点"></a>点</h2><p>特征图:   </p><p>(1) 线条交叉明显,   大树叉子(其实在我看来就是,   线条交叉非常地硬)</p><p>(2) 相切较多,   也就是圆和线的相切点;   </p><p>(3) 有笔画数特征但是笔画数无规律;   </p><blockquote><p>要注意:   笔画数和点数量是锁死的,   出现其中一个的特征图,   如果没有规律,   则考虑另外一个;   </p></blockquote><p>细化考法:   </p><p>(1) 切点;   大部分图都有切点;   </p><p>(2) 曲直交点;   <strong>每一幅图</strong>都有曲有直,   并且曲直相交;   </p><p>(3) 框上/框内有交点;   <strong>每一幅图</strong>都有外框;   </p><blockquote><p>当每一幅图都有曲线的时候:   </p><p>(1) 先想曲直性;   </p><p>(2) 对于单一曲线;   先考虑曲线数量,   如果无规律,   则考虑曲直线运算;   </p><p>(3) 每幅图都有曲直相交;   考虑曲直交点;   </p><p>(4) 特殊曲线—圆;   可以当曲线,   可以当外框,   可以构造切点;   </p></blockquote><h2 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h2><p>轴对称;   类等腰元素;   </p><p>中心对称;   S    N    Z    平行四边形,   及其变形图;   </p><p>轴对称+中心对称;   图形存在互相垂直的对称轴;   </p><p>细化考法:   对称轴的方向和数量,   对称轴与图形中的点线面角的关系;   </p><p>如果每一幅图行都是两到三幅对称图组成的时候,   考虑对称轴之间的关系;   </p><blockquote><p>对称轴总结:   </p><p>(1) 对称轴的简单判别,   判别图形是哪种对称;   </p><p>(2) 单一对称轴;   考虑与图形中的点线面相交的关系;   考虑对称轴的方向;   </p><p>(3) 多条对称轴;   考虑对称轴的数量;   考虑对称轴之间的位置关系,   要考虑图形拆分和内外拆分来看;   </p></blockquote><blockquote><p>区分图形间关系和对称轴关系:   都是轴对称图形就考虑对称轴,   有不是轴对称的就考虑图形间关系;   </p></blockquote><h2 id="样式规律"><a href="#样式规律" class="headerlink" title="样式规律"></a>样式规律</h2><p>即加减同异;   这种题型非常好辨识;   </p><h2 id="位置规律"><a href="#位置规律" class="headerlink" title="位置规律"></a>位置规律</h2><p>对于16宫格;   先看中间四个格子,   如果黑块数量相同,   则内外分开看;   如果黑块数量不同,   则横竖看;   </p><blockquote><p>注意平移可能隐藏了主体,   可能是顶点和端点在平移,   也可能是顶点和端点所指代的东西在平移;   </p></blockquote><h2 id="空间重构"><a href="#空间重构" class="headerlink" title="空间重构"></a>空间重构</h2><p>相对面不能出现于一个三视图:   (1) 同行或同列隔一个;       (2) 紧邻中线的”Z”两端;   </p><p>相邻面折叠前后相邻位置不变:   </p><p>(1) 公共边;   两个面挨着所形成的边;   两个构成直角的面所形成的两条边;   一列/一竖四个面,   另外两个面相对的边;   </p><p>(2) 公共点;   相邻的三个面有唯一的一个公共点;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断&quot;&gt;&lt;a href=&quot;#判断&quot; class=&quot;headerlink&quot; title=&quot;判断&quot;&gt;&lt;/a&gt;判断&lt;/h1&gt;&lt;h2 id=&quot;面&quot;&gt;&lt;a href=&quot;#面&quot; class=&quot;headerlink&quot; title=&quot;面&quot;&gt;&lt;/a&gt;面&lt;/h2&gt;&lt;p&gt;图形被分割, </summary>
      
    
    
    
    <category term="公务员考试" scheme="http://example.com/categories/%E5%85%AC%E5%8A%A1%E5%91%98%E8%80%83%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/04/08/gong-wu-yuan-kao-shi/wu-shi-ji-chu/n-mian-shi/"/>
    <id>http://example.com/2023/04/08/gong-wu-yuan-kao-shi/wu-shi-ji-chu/n-mian-shi/</id>
    <published>2023-04-08T02:29:39.572Z</published>
    <updated>2023-04-08T02:44:35.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我叫邓雨桐,   即将毕业于重庆邮电大学通信工程系,   成绩良好,   在校期间积极参加通信工程相关实训,   锻炼了吃苦耐劳的精神,   并且拥有过硬的编程能力,   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;自我介绍&lt;/h2&gt;&lt;p&gt;我叫邓雨桐,   即将毕业于重庆邮电大学通信工程系,   成绩良好,   在校期间积极参加通信工程相关实训,   锻炼了吃苦</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/04/04/bi-ye-lun-wen/f015-fan-yi/"/>
    <id>http://example.com/2023/04/04/bi-ye-lun-wen/f015-fan-yi/</id>
    <published>2023-04-04T00:26:38.926Z</published>
    <updated>2023-04-06T05:48:02.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视频序列中可变因素对人脸识别算法处理时间之影响"><a href="#视频序列中可变因素对人脸识别算法处理时间之影响" class="headerlink" title="视频序列中可变因素对人脸识别算法处理时间之影响"></a>视频序列中可变因素对人脸识别算法处理时间之影响</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>人脸识别是生物特征识别领域最热门的研究课题之一;   有时,   人脸识别需要在不稳定的环境下工作;   因此,   影响人脸识别性能因素的研究就是一个十分有意义的主题;   识别准确度会受到许多因素的影响,   但是人脸数据库中图片的质量和系统环境因素是需要关注的主要因素;   本研究通过严格空指环境因素来建立用户图像数据库,   以确保图像具有最小的混淆度和最好的质量;   我们也使用了多种不同的因素来测试算法的性能;   他们用于测试算法的准确度和执行速度;   我们使用处理静止图像的时间作为标准;   在对视频的测试中,   该实验通过使用影响因素变化的测试集来进行;   所有因素都与静态图片基准相同,   唯一不同的就是视频的分辨率;   实验结果表明,   人脸识别处理时间,   视频分辨率,   输入图片数量都会影响处理速度;   并且输入图像数量越小,   图片尺寸越小,   处理时间就越短;   在人脸识别算法中,   FisherFace的处理速度最快;   该实验的结果可以指明最有效的人脸识别算法;   它也可以应用于现有的系统;   </p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现如今,   生物信息已被应用于认证系统;   人的生理和行为特征主要用于这一目的;   人类生理信息广泛应用于人类身份认证,   但这需要特定的设备;   人脸识别的研究和发展受到了计算机视觉和图像处理领域研究人员的广泛关注;   因为人脸是便于用于身份验证的生理特征,   在实际使用中能够进行有效的身份识别;   而且,   人脸信息比指纹和虹膜更易被采集;   它可以应用于个人图像检索、监视、护照照片验证等各种用途;   </p><p>有时人脸识别系统需要被安装在某些不能够控制环境因素的地方;   尽管人脸数据库中的图片能够被小心收集,   像CPU速度,   光照和噪音等未知因素仍然会发生变化;   这些因素影响着人脸识别算法的准确度和性能;   另外,   不同的人脸算法各有利弊,   各自适合于不同的使用环境;   特别地,   如果对视频使用人脸算法,   每个人的人脸文件夹中会有许多张图片;   每一秒会捕获25到30张图片帧;   </p><p>因此,   人脸算法在不稳定环境因素和处理速度下的研究显得十分有意义;   因为了解这些因素,   用户在使用时就会尝试避免和控制这些因素,   以求得更稳定的人脸识别效率;   进一步说,   这可以帮助开发者选择基于应用场景之最正确的识别算法;   </p><p>该实验的重要性在于为乐于将人脸识别应用于真是系统中的人提供指导,   比如上课考勤记录系统,   每日时间记录系统和实施人脸识别系统;   此外,   处理时间于CPU速度和电池消耗有关,   因此我们可以评估系统规格和人脸识别系统的性能;   在某些情况下,   人脸识别系统可能会在互联网上运行,   导致数据传输成本,   适当的视频分辨率是衡量数据量和估计成本必不可少的;   </p><p>该论文的剩余部分如下;   第二部分描述人脸识别算法的基础方法论;   第三部分描述可能会影响处理时间的试验性因素;   第四部分对这些因素的实验结果进行展示和讨论;   最后在第五部分进行总结;   </p><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><h3 id="2-1-问题现状"><a href="#2-1-问题现状" class="headerlink" title="2.1 问题现状"></a>2.1 问题现状</h3><p>人脸识别广泛应用于身份认证;   这种方法可以用于多种目的,   但都只需要一个相机;  因此,   它可以应用于许多系统中,   如个人身份识别系统,   个人身份验证系统,   门禁系统和监控等;   所以一些人脸识别系统可能会安装在不稳定的环境当中;   前人将人脸识别系统应用于班级考勤系统;   在实际课堂上进行了测试,   但是识别率低于预期;   对于148位被试者, 识别率仅有48.18%,   这暴露了该系统不能有效应用于实际环境;   从以往的研究结果来看,   可能影响识别率的因素已经被找出并研究过了;   首先一个因素就是图片数据库;   使用人脸识别技术实现班级考勤系统是一个难题,   因为他需要将部分图像存储到参照数据库中;   要解决这个问题,   需要手动创建学生参照数据库;   文献<a href="">8</a>的研究只用少量的相关图片(大约每人8~15张),   并且所采集的图片质量并没有很好受到的控制;   这也是人脸识别应用于班级考勤系统时准确率低于预期的原因之一;   随后,   进一步研究表明,   美人的参照图片数量、图片质量(分辨率和光照)和面部遮挡物如眼镜和流海都需要被认知和控制,   以求得更高的准确率;   而环境因素也是影响因素之一;   理想的班级考勤系统能够在实时人脸识别中运行良好;   这个过程是通过从视频序列中捕捉学生的脸来完成的，人们没有站着不动来捕捉他们的图像。此外，还有的问题就是,   有时光照等系统环境会不稳定，摄像机质量可能不如图像数据库创建过程中使用的摄像机;   这些因素会干扰人脸识别过程，导致识别准确率较低。因此，本研究将对人脸识别的准确率进行比较研究，以寻找最适合的人脸识别算法。</p><h3 id="2-2-Eigenface算法"><a href="#2-2-Eigenface算法" class="headerlink" title="2.2 Eigenface算法"></a>2.2 Eigenface算法</h3><p>Turk和Pentland提出了一种基于主成分分析(PCA)的人脸识别方法，每个PCA训练集中人脸的s维向量可以基于与原始图像中最大方差方向对应的T维向量空间。通过人脸子空间的基向量定义的子空间基础向量,   对新维度进行较正常维度的缩减;   为了找到一组权重,   所有已分类的人脸图像都要被投影到图像区域的人脸上,   因为这些权重向量代表了每个向量的贡献度;   为了识别未知图像,   需要将图像投影到人脸子空间中,   并找到一组权重向量;   然后,   将未知图像投影到人脸子空间中,   也得到一组权重;   如果图像是随机变量的向量,   则将其定义为扩散矩阵的S<sub>T</sub>的PCA特征向量:<br>$$<br>S_T=\sum_{i=1}^M(x_i-\mu)(x_i-\mu)^T<br>$$<br>µ<sub>i</sub>是训练集中所有图像的平均值，x<sub>i</sub>是第i个图像，其列连接在一个向量中。投影矩阵W<sub>PCA</sub>由t个最大特征值的t个特征向量组成，形成了t维人脸空间。由于这些特征向量(PCA基向量)看起来像一些鬼脸，因此它们被命名为特征脸;   </p><h3 id="2-3-FisherFace算法"><a href="#2-3-FisherFace算法" class="headerlink" title="2.3 FisherFace算法"></a>2.3 FisherFace算法</h3><p>Fisherfaces 是一种强大的算法，它的基础理论是支持在人脸识别问题中使用线性方法进行降维，至少在寻求对光照条件的敏感性时是这样的。由于学习集已被标记，因此可以使用此信息构建更可靠的方法来降低特征空间的维数。使用特定类别的线性方法进行降维,   并在减少维度的特征空间中使用简单的分类器，可以得到比特征脸算法更好的识别率。 Fisher 线性判别法 (FLD) 是一种特定类别方法的例子，因为它试图“塑造”散点使分类更可靠。该方法在 [12] 中选择 W，使得类间散布和类内散布的比率最大化。将类间散布矩阵定义为：</p><img src="D:/Program%20Files/Typora/img/image-20230405102255652.png" alt="image-20230405102255652" style="zoom:80%;" /><p>其中x<sub>ij</sub>是第j类的第i个样本,   j是j类的平均值,   nj是j类的样本数;   同样,   类间差异是使用类间散布矩阵来计算的;   </p><img src="D:/Program%20Files/Typora/img/image-20230405102621840.png" alt="image-20230405102621840" style="zoom:80%;" /><p>其中µ是所有类别的平均值;   为了阐述特定类别线性投影的好处，我们构建了一个低维模拟分类问题，其中每个类的样本位于线性子空间附近。</p><h3 id="2-4-LBP算法"><a href="#2-4-LBP算法" class="headerlink" title="2.4 LBP算法"></a>2.4 LBP算法</h3><p>在局部二值模式(LBP)纹理分类方法中，图像中LBP编码的出现次数被收集到直方图中(也称为局部二值模式直方图，LBPH)。然后通过计算简单的直方图相似性来进行分类。然而，考虑到类似的方法用于面部图像表示会导致空间信息的丢失，因此应该在保留其位置的同时对纹理信息进行编码。实现这一目标的一种方法是使用LBP算子来构建面部的几个局部描述，并将它们组合成全局描述。因为整体表征法存在一定限制,   所以这种局部描述引起了人们的兴趣,   这可以理解。与整体方法相比，这些基于局部特征的方法对姿态或照明的变化具有更好的鲁棒性。</p><p>Ahonen等人提出的基于LBP的人脸描述的基本方法论是：将人脸图像划分为许多局部区域，并从每个区域独立地提取LBP算子。然后将描述符串接以形成脸部的全局描述。此操作符通过阈值为图像中的每个像素分配一个带有中心像素值的3x3邻域(后来对其进行了改进)的标签，并将结果视为二进制数。它们使用LBP<sup>u2</sup><sub>(P,   R)</sub>表示LBP运算符。下标表示在(P，R)邻域中使用运算符。上标u2表示仅使用统一图案，并用单个标签标记所有剩余图案。标记图像f<sub>l</sub>(x，y)的直方图可以定义为</p><img src="D:/Program%20Files/Typora/img/image-20230405104743380.png" alt="image-20230405104743380" style="zoom:80%;" /><p>其中n是LBP算子产生的标签的数量，并且</p><img src="D:/Program%20Files/Typora/img/image-20230405104854543.png" alt="image-20230405104854543" style="zoom:80%;" /><p>该直方图包含有关局部微观图案在整个图像上的分布信息，例如边缘、斑点和平坦区域。为了有效的人脸表示，还应该保留空间信息。</p><h2 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h2><p>在数字图像处理中，环境因素是指任何可能发现或影响图像处理系统的因素，包括每个过程中出现的因素。有时一些因素导致图像的人脸识别不理想，进而降低识别率。这些因素包括用户的年龄，因为人脸在不同时间可能会有很大差异。影响识别率的其他因素还有光照、脸型和纹理、眼镜等。因此，所有可控的因素都应该控制好，以便最小程度地影响识别系统。 Jafri 和 Arabnia 将导致面部外观变化的因素分为两类，内部因素和外部因素，人脸的物理性质导致了内部因素。这种因素可以分为两类，内在和人际。内部因素导致同一个人的面部外观发生变化，此类因素可能发生在每个人身上。比如年龄、面部表情和面部用品，如面部毛发、眼镜、化妆品等。人际因素也是造成不同人面部外观差异的原因，比如种族和性别，这会导致存在相似面部外观的人无法被识别的情况。外部因素通过光与面部和观察者的相互作用导致面部外观发生变化。外部因素包括光照、姿势、手势、比例和成像参数。由于人脸识别系统常用于不稳定的环境，对应的可变因素是多种多样的，有时很难控制。因此，这种因素对人脸识别准确率的影响最大。</p><h3 id="3-1-对比与评估的方法"><a href="#3-1-对比与评估的方法" class="headerlink" title="3.1 对比与评估的方法"></a>3.1 对比与评估的方法</h3><p>该实验所用的比较方法的目的为从不同的角度对不同的算法进行比较;   它可以帮助研究人员从探索性案例研究的初始水平提升到高级的一般理论模型、不变性（如因果关系或进化）水平。该实验旨在使用冗杂的可变因素比较不同人脸识别算法的准确率;   比较研究设计是很简单的;   其目的是找出不同测试用例导致不同结果的原因,   来揭示产生或导致这种变化的一般基础结构;   比较方法分为两类;   其一为描述性比较,   旨在描述并有可能解释对象的不变性,   但并不是对其进行直接改变,   而是会尽量避开他们;   另一个是规范比较;   它目标不仅是检测和解释，而且还要改变对象的当前状态，帮助改进或开发将来的类似对象时，所需要的一种特殊的研究方式;   人脸识别准确率可以由多个方面来评估;   因此,   有许多具有不同数据集的知名数据库如FERET,   Yale,   AT&amp;T,   SCFace可以选用;   但是在该实验中,   使用的是真实教室环境下的学生图片组成的数据库;   因为该实验需要在类真实的环境中找到面向使用了人脸识别技术的班级考勤系统的最合适的算法;   </p><h3 id="3-2-测试因素"><a href="#3-2-测试因素" class="headerlink" title="3.2 测试因素"></a>3.2 测试因素</h3><p>在该实验中,   许多能够影响人脸识别率的因素都可能出现在真实系统中;   在创建参考数据库的时候,   图片质量,   图片大小,   噪音等级,   光照等级,   人脸方向,   眼睛和流海都需要考虑在内;   考虑这么多是因为这些因素会直接影响训练模型质量;   尽管可以对图片进行预处理来提高训练模型质量,   输入图片仍然会包含各种冗杂因素,   进而影响人脸识别准度;   因此,   该实验研究了可能出现在真实系统中的冗杂因素,   并对人脸识别算法的准确性进行了对比测试，以期找到最适合人脸识别系统的算法;   使用到的冗杂因素如下;   </p><p>在人脸识别准度测试中,   会对视频进行三方面的调整,   分别是曝光度,   噪音以及视频分辨率;   该测试是十分有意义的,   因为人脸识别系统很可能会安装在像教室那种不稳定的环境中,   并对硬件进行限制;   测试的目的是研究各种因素对人脸识别准确率的影响，并对它们进行比较，以找到最适合应用于班级考勤记录系统的算法。因此，每个因素的变化如下所述;   </p><p>根据Tan和Triggs对于困难光照条件下的人脸识别的局部纹理特征研究表明,   光照条件是影响人脸识别准确率的主要问题。因此,   本实验第一个选取的因素就是光照;   由于学生考勤系统一般被安装在室内,   通常使用灯泡作为光源,   并且光线方向是不变的;   虽然光线强度易变,   但实际环境中不太会发生变化;   因此，该实验让光照强度在正值和负值的较小范围内变化，以调整视频亮度来研究光照对人脸识别精度的影响。</p><p>噪声是使用任何相机时图像和视频都可能出现的因素。它是由多种原因引起的，但主要是因为光线不足和相机质量较低。因此，室内人脸识别系统在光线不足的情况下,   会频繁受到噪声的影响。噪声变化是实验中使用的第二个因素。将人工高斯噪声添加到视频序列中,   因为其很有可能随机出现在视频帧中。没有噪声时被定义为正常情况,   其值为零，然后将值增加到20、25、30和50进行测试。为了研究噪声对人脸识别准确率的影响，在视频中加入了噪声;   </p><p>基于视频的人脸识别包括人脸跟踪和人脸识别两部分;   最重要的因素是图片分辨率,   根据Huang和Wang的研究,   图片中的面部细节取决于图片分辨率;   面部细节影响面部识别的性能，因为更多的面部细节可以获得更高的面部识别精度，但它对面部检测速度有一个折中。此外，不同的视频分辨率会影响面部大小和清晰度，准确度测试的最后一个因素是视频分辨率的变化。本实验旨在研究视频分辨率对人脸识别准确率的影响。本次测试中使用的视频分辨率有 720p、480p 和 360p。</p><h3 id="执行速度测试"><a href="#执行速度测试" class="headerlink" title="执行速度测试"></a>执行速度测试</h3><p>影响人脸识别系统处理速度的因素有很多，如人脸识别算法、视频分辨率、硬件等。但是，由于研究目标旨在找到实现硬件限制的班级考勤记录系统的合适的算法。复杂方法的处理速度提高是不合适的。因此，选择比较的因素是提高视频中人脸识别处理速度的简单方法，即跳帧率和视频分辨率的变化。跳帧是提高视频中人脸识别速度的正确思路，因为有些视频帧率高，处理时间长。此外，在它包含的一秒钟视频中，许多相似的帧取决于帧速率。因此，可以通过跳过一些相似的帧来减少它们，以提高人脸识别的处理速度。在实验中，跳帧率的变化分别取值 5、6、7、8、9、10、15、20 和 30，以找到最适合接受精度的跳帧。另一个需要比较的因素是视频分辨率。这个因素显然会影响处理速度，尤其是在人脸检测方面。在实验中，将使用 Haar 级联分类器搜索人脸，但该方法使用搜索窗口在图像的每个区域中查找人脸。由于这个原因，处理时间的性能将取决于视频帧的大小。<br>此外，更高的视频分辨率需要更多的存储空间。因此，本次测试的目的是寻找在性能和实际使用方面都能被接受的适合考勤系统的视频分辨率。本次测试的视频分辨率变化为 720p、480p 和 360p。</p><h3 id="基于视频的人脸识别准确率测试"><a href="#基于视频的人脸识别准确率测试" class="headerlink" title="基于视频的人脸识别准确率测试"></a>基于视频的人脸识别准确率测试</h3><p>基于视频的人脸识别是基于静止图像的人脸识别的延伸，在准确率方面有一定的挑战。该研究旨在找到最适合的人脸识别算法。基于视频的人脸识别取代了实时人脸识别。究其原因，在实际测试中，让受试者亲临现场多次对系统进行测试的方法存在复测的局限性。如果测试对象较少，会影响结果的精确度。因此，视频是本实验的最佳选择，它解决了复测的问题，而且基于视频的人脸识别过程也可以被认为是实时的人脸识别;   该实验旨在比较视频的人脸识别率,   并找寻最合适的人脸算法;   </p><p>这项工作是通过收集面向对象编程(OOP)班级的视频文件进行的，为期10周。有148名学生走过摄像机。然后，视频将被分割成更小的部分。每个视频有7.18分钟长的视频，每秒30fps，其中包含30个路人的镜头。每个受试者随机进入画面三次。测试对象与基于静止图像的测试中使用的相同。本实验测试了三种与基于静止图像的人脸识别测试类似的人脸识别算法。本实验的假设是每种算法都能达到可接受的人脸识别准确率，并且处理时间是合适的。测试因素为准确度和处理时间;   </p><img src="D:/Program%20Files/Typora/img/image-20230406101552947.png" alt="image-20230406101552947" style="zoom:80%;" /><h2 id="4-结果与讨论"><a href="#4-结果与讨论" class="headerlink" title="4. 结果与讨论"></a>4. 结果与讨论</h2><h3 id="4-1-可变因素的准确率测试"><a href="#4-1-可变因素的准确率测试" class="headerlink" title="4.1 可变因素的准确率测试"></a>4.1 可变因素的准确率测试</h3><p>该实验给出了具有可变因素的静止图像的人脸识别测试的结果。本次测试实验分为三个部分。第一个实验是在没有混淆因素的情况下进行静止图像的人脸识别测试。这是测试集中的非调整对比图像测试。该测试基于30名受试者的封闭测试集。参考数据库是以前使用的受控数据库，但将图像扩展到每个受试者40个。测试集包含参考数据库中存在的每个受试者的10个图像，但与图像不同。它通过三种算法进行了测试：EigenFace、FisherFace和LBPH。实验结果如表1所示。从图1来看，LBPH的准确率最高，为81.67%，FisherFaces的准确率为69.93%，EigenFace的准确率最低，为46.67%。</p><img src="D:/Program%20Files/Typora/img/image-20230406103800061.png" alt="image-20230406103800061" style="zoom:80%;" /><p>这与前人的班级考勤记录系统相比,   比较令人满意，因为之前的LBPH准确率为48.18%。因此,   该实验表明,   图片数据库是影响准确率的主要因素;   而包含不同人脸表情和方位的参考库可以提高LBPH的准确率。这一部分的第二个实验是在不同噪声值的情况下基于静止图像的人脸识别测试。添加了高斯噪波，通过使用不同的值20、25、30和50来调整图像。实验结果如表2所示。在每种情况下，特征脸和FisherFace的人脸识别准确率略有不同。</p><img src="D:/Program%20Files/Typora/img/image-20230406103733455.png" alt="image-20230406103733455" style="zoom:80%;" /><p>在噪声值为0和50的情况下，特征脸的准确率最高，达到46.67%。FisherFace在25岁时正确率最高，为70.0%。当噪声值为0时，LBPH的准确率最高，为81.67%。结果表明，在图2中，特征脸和FisherFace对不同的噪声具有稳定的精度。LBPH噪声对准确度的影响最大。从LBPH的准确度来看，随着噪声值的增大，LBPH的准确度不断下降。其原因是图像中噪声的干扰导致了直方图相似性的缺失。更改图像的细节可以更改直方图值。而特征脸和FisherFace不受噪声的影响，因为这些方法使用了一种统计方法，可以灵活地处理图像中的一些细节变化。在基于静止图像的人脸识别中测试的最后一个因素是图像亮度变化。此测试包含具有正值和负值的曝光调整的图像。本实验的结果如表3所示。在曝光度-10的情况下，LBPH的准确率最高，为84.0%，但其准确性与其他情况没有显著差异。在许多情况下，FisherFace算法的准确率最高，达到69.33%。特征脸算法的正确率最高，为46.67%。</p><p>在这个实验中，将测试三个可能影响人脸识别系统处理时间的因素：人脸识别算法、视频分辨率和跳帧率。人脸识别算法是首先需要关注的因素。显然，每种算法都有不同的特点，基于不同的方法。它可以假设每个算法需要不同的处理时间。在此基础上，采用特征脸、FisherFace和LBPH三种人脸识别算法进行了人脸识别处理时间的实验。在这种情况下，使用长度为7.18分钟的720p视频分辨率，没有混杂因素或任何调整，但跳帧被定义为6帧。本例的结果如表4所示。如图4所示，FisherFace算法占用的处理时间最短。对于长度为7.18分钟的视频，该算法花费的时间大约是原始长度13.31分钟的1.85倍。其次是特征脸，占原始长度的1.96倍，为14.13分钟。最后一种LBPH，处理时间最长，为14.66分钟，即视频长度的2.04倍。视频分辨率是用于测试处理时间的因素之一。根据假设人脸识别处理时间取决于视频分辨率的假设。如上所述，人脸检测模块是基于视频的人脸识别组件之一，并且使用了类Haar特征。该算法设置了一个移动窗口，并移动到图像的每个区域。因此，该测试的假设是较大的图像比较小的图像需要更多的处理时间。处理时间测试的结果如图5,   随着视频分辨率的降低，每种人脸识别算法的处理时间都呈现下降趋势。这与如上所述的假设有关，即较小的视频分辨率需要较短的处理时间。FisherFaces算法是所有案例中处理时间最短的算法，三个案例的平均处理时间约为9.79分钟。其次是特征脸，它的平均处理时间为10.18分钟。LBPH是处理时间最长的算法，平均为11.19分钟。然而，这三种算法的处理时间并没有显著差异。基于视频的人脸识别系统需要对视频的每一帧进行提取和处理。在实际应用中，视频通常为25fps或30fps，整个视频帧的处理耗时较长，不适合用于班级考勤记录系统。因此，跳帧率是在处理时间的情况下要测试的因素，因为如果跳过帧，则只选择部分视频帧进行处理，并且它可以减少处理时间。顺便说一句，跳过率是比较重要的。因为如果视频帧被跳过太多，一些人脸可能不会出现和检测到;   在该实验中,   视频使用30帧,   并捕捉了以不同姿势和表情经过摄像机的人;   人们每次在视频中至少出现一秒，所以在这个实验中，跳帧率将从每秒一帧调整。这可以确保它可以覆盖视频中的所有人。通过跳帧调整进行处理时间测试的结果如表6所示。如图6所示，处理时间的趋势取决于输入图像的数量。</p><img src="D:/Program%20Files/Typora/img/image-20230406104826870.png" alt="image-20230406104826870" style="zoom:80%;" /><p>处理时间的减少与跳帧率的增加有关，这意味着较少的输入图像需要较少的处理时间。然而，这些处理时间的结果具有类似的准确性。因此，本实验中的跳帧率范围可以适用于班级考勤记录系统。与7.18分钟的视频长度相比，在20、25和30帧跳跃的情况下，处理时间比原始视频长度更短。</p><p>据此得出结论,   对于处理时间,   其影响因素为人脸算法,   视频分辨率,   与输入图片数量;   作为实验的结果，这与假设有关，即输入图像的数量越少，图像尺寸越小越可以减少处理时间。在人脸识别算法的情况下，LBPH是处理时间最长的算法，平均为10.58分钟。第二个是特征脸，平均耗时约10.03分钟。Fisherfaces是处理时间最短的算法，平均为9.76分钟。<br>结果评估是评估人脸检测和识别准确性的过程。这个过程的目的是验证每个实验结果的准确性和有效性。有几种方法可以评估结果，但在本研究中，评估是通过手动检查完成的。原因是视频中有很多人路过镜头，有时不止一个人。虽然它可以估计受试者通过相机的时刻，但它会被叠加而导致错误，以影响初步阶段验证结果。我们可以通过手动检查考虑图像的物理特性，并对导致错误检测和识别的问题进行分类。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>在这项研究中，研究了三种有效的人脸识别算法及其变化因素。 Eigenfaces、Fisherfaces 和 LBPH 是人脸识别算法，由于这些算法在人脸识别领域广为人知和流行，所以本研究选择这些人脸识别算法进行研究。虽然人脸识别系统具有如前所述的诸多好处，但在实际的人脸识别系统中，它大多部署在不稳定的环境中。这些因素都会影响并导致系统对每个人脸识别算法的处理时间有很多冗杂因素。根据这些原因，在初步测试中检验了每个因素的假设，以研究人脸识别准确率和处理时间的影响;   基于静止图像的测试结果表明，LBPH 在正常情况下获得了最高的识别率。虽然，它可以高精度地处理测试中的曝光度变化，但是当添加噪声时它无法做到很好。 LBPH 受高斯噪声的干扰太大，该算法的精度在这种情况下远低于其他算法。 Eigenfaces 具有了相当的准确性，在所有情况下都没有显着差异。<br>Fisherfaces 的结果非常有意思，也是最快的算法，它花费的处理时间最少。即使准确率不如LBPH，但该算法可以稳定准确地处理所有因素。该测试概述了影响人脸识别准确性的因素。 LBPH 的准确性也从之前研究中的 48.18% 显着提高到新数据库的 15 个图像数据库大小的 73.3% 和 40 个图像数据库大小的 81.67%。<br>在视频测试中，实验是使用带有冗杂因素变化的测试集进行的。所有因素都与静止图像相似，但它有一个附加因素，即视频分辨率。视频外观根据曝光度的变化、噪声的变化和视频分辨率进行调整。基于视频的人脸识别测试结果的趋势与基于静止图像的测试结果相关，但三种算法的准确率大幅下降。然而，LBPH 拥有最高的精度。虽然分辨率增加了，但它比 Fish erfaces 和Eigenfaces 算法花费了更多的处理时间。 Fisherfaces 仍然是最快的算法，它在所有视频分辨率上花费的处理时间最短，对噪声和曝光度有很强的鲁棒性。同时，Eigenfaces 的精度最低。它对分辨率的影响低于LBPH。由此可见，人脸识别处理时间、人脸识别算法、视频分辨率、输入图像数量等因素对处理速度的影响。作为实验的结果，它与输入图像数量较少的假设有关，较小的图像尺寸可以减少处理时间。在人脸识别算法的情况下，Fisherfaces 是最快的算法，其处理时间分别比 Eigenfaces 和 LBPH 短。<br>可以通过将低 CPU 速度（例如 Rasberry PI 和实时视频）应用于所研究的问题并比较不同方法在解决方案质量和运行时间方面的结果来进行进一步的研究。研究研究问题的处理时间是未来研究的另一个有趣的扩展和机会。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;视频序列中可变因素对人脸识别算法处理时间之影响&quot;&gt;&lt;a href=&quot;#视频序列中可变因素对人脸识别算法处理时间之影响&quot; class=&quot;headerlink&quot; title=&quot;视频序列中可变因素对人脸识别算法处理时间之影响&quot;&gt;&lt;/a&gt;视频序列中可变因素对人脸识别算法处</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>S001_servlet</title>
    <link href="http://example.com/2023/03/27/hou-duan-gong-cheng-shi/java-web/s001-servlet/"/>
    <id>http://example.com/2023/03/27/hou-duan-gong-cheng-shi/java-web/s001-servlet/</id>
    <published>2023-03-27T12:39:18.000Z</published>
    <updated>2023-04-02T02:59:26.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="servlet介绍"><a href="#servlet介绍" class="headerlink" title="servlet介绍"></a>servlet介绍</h1><p>基本的架构就是客户端和服务器;   客户端通过网络向服务器发送请求,   服务器向客户端返回相应;   在服务器中,   服务器会启动一个服务,   来接收客户端的请求,   并且搭载对应的静态页面,   当收到客户端的url地址后,   会通过地址的参数得知客户端请求的是哪一个界面,   将该页面返回即可;   </p><p>由于不同的浏览器所实现的请求包装方式可能会不同,   所以需要统一标准,   也就是http协议;   </p><p>如果静态页面过多,   会过多的占用存储空间,   所以引入动态生成页面的方式,   只需要保存一套数据即可;   也可以说是按照不同的需求来生成不同的页面,   使得提供的服务能够更灵活,   而这个小程序就是applet;   </p><p>而随着时间的发展,   衍生出了servlet    jsp(java server page)    SSM;   </p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>用于规范客户端与服务器之间的交互;   </p><p>特点:   简单快速    灵活    无连接    无状态    支持B/S和C/S架构;   </p><p>(1) 通过键值对的形式来表示数据”key”=”value”;   </p><p>(2) 可以指定数据的多种形式,   比如json    纯文本等等;   </p><p>(3) 相对于短链接而言的,   节省了创建链接等等步骤的时间;   </p><p>(4) 不记录上一次的请求的保存;   </p><p>(5) B/S架构相当于统一了各个应用,   使其应用基于浏览器…</p><h2 id="http请求格式"><a href="#http请求格式" class="headerlink" title="http请求格式"></a>http请求格式</h2><p>包含三部分,   请求行    请求头和请求体,   </p><img src="D:/Program%20Files/Typora/img/image-20230327212028008.png" alt="image-20230327212028008" style="zoom:80%;" /><p>请求行就是告知要从哪里干什么;   </p><p>请求头放置的信息为头信息的补充信息,   比如各种格式和语言;   </p><p>请求体放置的信息为请求的数据,   最终会以K-V键值对的形式返回;   </p><h2 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h2><p>get    post    head    put</p><p>get和post都是获取数据的方法;   </p><blockquote><p>get和post的区别:   </p><p>post所请求的数据不会显示在地址栏中,   而get会;   所以post是安全的,   get不安全;   </p><p>而由于这个原因,   get会限制请求长度限制,   但是post不会;   </p></blockquote><h2 id="http响应格式"><a href="#http响应格式" class="headerlink" title="http响应格式"></a>http响应格式</h2><img src="D:/Program%20Files/Typora/img/image-20230327214600622.png" alt="image-20230327214600622" style="zoom:80%;" /><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>在物理服务器的webserver中,   要准备一个长服务,   用于接收客户端的请求,   而在实际开发环境当中,   webserver有多个;   </p><h2 id="自定义TomCat"><a href="#自定义TomCat" class="headerlink" title="自定义TomCat"></a>自定义TomCat</h2><ol><li><p>MyRequest</p><p>该类定义好请求的方法和地址,   在构造方法中通过输入流将请求读取进来,   进行字符分割之后,   填写好请求方法和请求地址;   </p></li><li><p>MyResponse</p><p>该类负责发送请求,   填写好详细的请求信息之后,   在请求中加上简单的字符串,   使用输出流将请求送出;   </p></li><li><p>MyServlet</p><p>通过响应类进行具体的消息的发出;   </p></li><li><p>MyServer</p><p>无限循环接收请求,   通过请求获取该请求对应的servlet服务类,   通过反射创建该类,   让该类将对应的响应发出;   </p></li><li><p>其他</p><p>为了维护扩展性,   需要创建一个Servlet的接口,   因为服务页面不止一个;   还需要创建一个url地址标识符映射Servlet类的类;   </p></li></ol><p>全部写好过后,   就可以在浏览器中输入对应的地址 端口号以及资源定位符,   即可获取到对应的资源;   而如果使用Tomcat,   则只需要撰写servlet即可;   </p><p>撰写servlet,   也只需要重写doGet    doPost和service方法即可;   对于service方法,   需要拿到参数中的响应的撰写体,   调用write方法即可;   而映射关系需要在web/WEB-INF/web/xml中填写;   </p><blockquote><p>使用Tomcat作为服务器的流程就是:   请求打过来,   Tomcat先找web.xml,   通过url找到对应的servlet名称,   通过名称找到对应的类,   该类一定实现了HttpServlet父类,   自动调用该类的service方法即可;   </p></blockquote><p>所以这个时候可以对servlet下定义:   servlet是web服务端的编程技术,   它实现了特定的Java类(比如在Tomcat中为HttpServlet),   并由支持Servlet的web服务器执行和调用,   一个Servlet对应一个或一组URL访问请求,   并返回对应的响应;   </p><h2 id="servlet生命周期"><a href="#servlet生命周期" class="headerlink" title="servlet生命周期"></a>servlet生命周期</h2><p>当服务端接收到客户端发送的第一个请求后,   才开始生成对应的servlet类对应的对象;   而Tomcat服务器结束的时候,   servlet才被销毁;   </p><p>所以他的生命周期:   接收到第一个对应的请求后—&gt;Tomcat服务器关闭;   </p><blockquote><p>当然也可以设置对应的属性&lt; load on startup &gt;,   让它在Tomcat启动的时候就创建</p></blockquote><h2 id="servlet的使用"><a href="#servlet的使用" class="headerlink" title="servlet的使用"></a>servlet的使用</h2><p>使用jsp实现BS交互:   撰写MethodServlet类,   这里可以直接选择创建servlet文件,   IDEA会自动在该类中写好doGet和doPost,   然后在web.xml中写好别名与类名的对应,   我们只需要写上别名与url的对应,   并在MethodServlet类中撰写service方法即可;   然后创建jsp文件,   在其中写上表单:   </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;method&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意如果要将jsp连接到MethodServlet类的话,   action属性对应的值为web.xml文件中对应于MethodServlet类的url;   而通过调整method属性,   也可以看到get和post的区别;   </p><p>service方法可以用来接收get和post请求,   而doX方法只能接受对应的X请求;   </p><h2 id="servlet常见错误"><a href="#servlet常见错误" class="headerlink" title="servlet常见错误"></a>servlet常见错误</h2><p>404:   访问资源不存在;   表示地址栏中填写的路径与web.xml中的请求不一致,   或者项目虚拟名称填写错误;   </p><p>405:   请求的方式与servlet中支持的方式不一致;   也就是说jsp中method属性与servlet中重写了的方法不匹配;   </p><p>500:   服务器内部错误;   比如web.xml中的servlet类名或包名填写错误,   就是报这个错,   并在网页中直接打印java异常;   或者servlet重写的请求处理方法中存在逻辑错误;   </p><h2 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h2><p>可以通过该对象获得请求的所有信息,   包括方法,   地址,   资源地址和协议;   </p><p>上面说的是请求行中的数据,   由于请求头中的数据是键值对,   所以拿请求头中的数据的时候,   需要使用get方法获取;   还可以获取用户数据;   </p><blockquote><p>代码分层:   一开始所有的页面都是静态页面,   所以所有的东西都放在一起进行处理,   包括展示页面效果的标签,   以及代码的逻辑处理;   然后进行拆分,   把html或者jsp放在一块,   进行页面展示,   java代码放在另一块,   进行逻辑处理,   比如获取参数和与数据库进行进行交互;   这时如果想要修改页面效果,   只需要修改前端;   </p><p>但是由于这样分层之后,   java代码需要拿到对应的参数以及进行逻辑处理,   所以需要分层,   分为控制层control,   服务层service,   数据库层dao</p></blockquote><h2 id="登录小项目"><a href="#登录小项目" class="headerlink" title="登录小项目"></a>登录小项目</h2><p>撰写method.jsp,   以及控制层 数据层和服务层,   在控制层中撰写对应的servlet,   在jsp文件中填写对应的映射名,   映射servlet处理类,   也就是说请求的就是method.jsp页面,   然后把收到的请求交给servlet处理类进行处理,   所以在servlet类中就需要进行对应的登录判断;   </p><p>servlet调用服务层提供的服务, 对应的方法为checkUser(),   判断该用户是否已注册,   而服务层的具体实现子类会调用数据层的checkUser()方法进行判断,   在数据层,   就是通过jdbc去数据库中查询对应的用户是否存在,   如果存在则返回一个用户,   当然也可以直接在数据层对应的方法中就进行判断,   然后直接返回布尔值;   </p><blockquote><p>注意:   如果此处不使用jsp文件的话,    就需要撰写两个servlet类,   一个负责页面的显示,   并且把请求传递给另一个servlet类,   比较麻烦;   </p></blockquote><h2 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h2><p>在登录项目中,    如果数据库中的人名有中文,   则在登陆的时候会显示没有对应的信息,   这时需要进行格式的转化:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name1 = <span class="keyword">new</span> String(name.getBytes(<span class="string">&quot;iso-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>将浏览器的格式转化为utf-8格式,   然后传入对应的方法中;   即可得到正确的结果;   </p><p>这是一种方式,   也可以设置request的编码格式为utf-8,   然后在Tomcat的conf文件夹中对server.xml中修改属性,   为</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;servlet介绍&quot;&gt;&lt;a href=&quot;#servlet介绍&quot; class=&quot;headerlink&quot; title=&quot;servlet介绍&quot;&gt;&lt;/a&gt;servlet介绍&lt;/h1&gt;&lt;p&gt;基本的架构就是客户端和服务器;   客户端通过网络向服务器发送请求,   服务器向客</summary>
      
    
    
    
    <category term="Java Web" scheme="http://example.com/categories/Java-Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring_IoC源码</title>
    <link href="http://example.com/2023/03/18/hou-duan-gong-cheng-shi/spring/spring04-ioc-yuan-ma/"/>
    <id>http://example.com/2023/03/18/hou-duan-gong-cheng-shi/spring/spring04-ioc-yuan-ma/</id>
    <published>2023-03-18T12:57:25.000Z</published>
    <updated>2023-03-20T07:53:45.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IoC启动源码"><a href="#IoC启动源码" class="headerlink" title="IoC启动源码"></a>IoC启动源码</h1><h2 id="Resource定位"><a href="#Resource定位" class="headerlink" title="Resource定位"></a>Resource定位</h2><p>也就是Bean文件的定位,   由于Spring提供多种配置文件的定位方式,   所以这块值得拿出来说;   </p><p>Resource类为Spring定义的IO封装类,   该类中包含着配置文件(的路径?)</p><img src="D:/Program%20Files/Typora/img/image-20230318210220480.png" alt="image-20230318210220480" style="zoom:80%;" /><p>Spring提供了ResourceLoader接口来获取对应的资源,   ResourceLoader作为接口,   自然有许多的实现子类,   不同的实现子类通过实现getResource方法来进行资源的获取;   </p><h2 id="BeanDefinition的生成"><a href="#BeanDefinition的生成" class="headerlink" title="BeanDefinition的生成"></a>BeanDefinition的生成</h2><p>通过配置文件注入的bean对象在IoC容器中就是一个一个的BeanDefinition对象;   IoC容器对bean的管理和依赖注入都是通过BeanDefinition来实现的;   </p><p>下面讲述如何将BeanDefinition放入IoC容器中;   </p><p>在AbstractXmlApplicationContext类中定义了一个方法loadBeanDefinitions(DefaultListableBeanFactory beanFactory),   用于获取BeanDefinition;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">   <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">   <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中看到,   首先创建一个XmlBeanDefinitionReader对象,   设置好相应的参数之后,   调用下面的重载方法;   在重载方法中,   通过这个对象加载路径,   其中有用户指定的配置文件路径,   也有IoC容器所需要的配置文件;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">Resource[] configResources = getConfigResources();<span class="comment">//获取所有定位到的resource资源位置（用户定义）</span></span><br><span class="line"><span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configResources);</span><br><span class="line">&#125;</span><br><span class="line">String[] configLocations = getConfigLocations();<span class="comment">//获取所有本地配置文件的位置（容器自身）</span></span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configLocations);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而loadBeanDefinitions的实现:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法属于AbstractBeanDefinitionReader类, 父接口BeanDefinitionReader</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">        <span class="comment">// 将所有资源全部加载，交给AbstractBeanDefinitionReader的实现子类处理这些resource</span></span><br><span class="line">        counter += loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadBeanDefinitions重载方法的逻辑是,   一个负责与外部进行对接,   把全部的配置文件都拿到,   另一个负责具体的对单一配置文件进行处理;   而这两个方法都由接口BeanDefinitionReader实现,   但是AbstractBeanDefinitionReader类并没有实现单一参数值的loadBeanDefinitions方法,   或者说它只实现了对本地资源的单个具体处理方法,   而对用户指定的配置文件,   具体是由XmlBeanDefinitionReader来实现的;   </p><img src="D:/Program%20Files/Typora/img/image-20230318214320942.png" alt="image-20230318214320942" style="zoom:80%;" /><p>所以下面来分析XmlBeanDefinitionReader类中的对loadBeanDefinitions方法的实现,   XmlBeanDefinitionReader类中对于配置文件的loadBeanDefinitions方法又有两个重载,   第一个是将配置文件打包为EncodedResource,   第二个则是进行具体的操作:   将资源转为输入流,   然后经典流套流打包为InputSource,   最后放入doLoadBeanDefinitions方法中执行,   在该方法中,   通过DocumentLoader将资源再打包为Document类,   调用registerBeanDefinitions方法;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// 包装resource为EncodeResource类型</span></span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载包装后的EncodeResource资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过resource对象得到XML文件内容输入流，并为IO的InputSource做准备</span></span><br><span class="line">        InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Create a new input source with a byte stream.</span></span><br><span class="line">            InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">            <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开始准备 load bean definitions from the specified XML file</span></span><br><span class="line">            <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取指定资源的验证模式</span></span><br><span class="line">        <span class="keyword">int</span> validationMode = getValidationModeForResource(resource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从资源对象中加载DocumentL对象，大致过程为：将resource资源文件的内容读入到document中</span></span><br><span class="line">        <span class="comment">// DocumentLoader在容器读取XML文件过程中有着举足轻重的作用！</span></span><br><span class="line">        <span class="comment">// XmlBeanDefinitionReader实例化时会创建一个DefaultDocumentLoader型的私有属性,继而调用loadDocument方法</span></span><br><span class="line">        <span class="comment">// inputSource--要加载的文档的输入源</span></span><br><span class="line">        Document doc = <span class="keyword">this</span>.documentLoader.loadDocument(</span><br><span class="line">                inputSource, <span class="keyword">this</span>.entityResolver, <span class="keyword">this</span>.errorHandler, validationMode, <span class="keyword">this</span>.namespaceAware);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将document文件的bean封装成BeanDefinition，并注册到容器</span></span><br><span class="line">        <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ...(略)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在registerBeanDefinitions(Document doc, Resource resource)方法中,   通过生成的BeanDefinitionDocumentReader对象调用registerBeanDefinitions方法进行执行;   </p><blockquote><p>BeanDefinitionDocumentReader为一个接口,   它的实现子类是DefaultBeanDefinitionDocumentReader;   createBeanDefinitionDocumentReader方法生成的就是该子类,   而且又是通过反射生成的;   </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在DefaultBeanDefinitionDocumentReader类中的registerBeanDefinitions方法又调用了doRegisterBeanDefinitions方法,   在这个方法中,   则是通过BeanDefinitionParserDelegate代理类去实现的BeanDefinition的注入;   </p><p>具体请参考图<a href="https://viewer.diagrams.net/?tags=%7B%7D&highlight=0000ff&edit=_blank&layers=1&nav=1&title=Spring#R7V1bc9s2Fv41nEkf7OH98khZUtvdpJONs1snLxlKgiW2lKil6NjOry8AAhIpHFK0RBEUo07HISFeQJzbh4NzDhTjbvnyaxKsFx%2FiGYoUXZ29KMZQ0XXdsHT8D2l5zVo0xzKylnkSzrI2dddwH%2F5A7ELe%2BhTO0Ia1ZU1pHEdpuC42TuPVCk3TQluQJPFz8bLHOJoVGtbBHAkN99MgElv%2FDGfpImt1LXXX%2FhsK5wv%2BZk1lvywDfjFr2CyCWfycazJGinGXxHGaHS1f7lBERq84LuOSX7cdS9AqrXPDTajG%2F%2Fv%2BrP618X58Vu9%2FvQtHH24s9pjvQfTEvpj1Nn3lQ4Afg0cbnwzwJ6xJ4zSKn%2FBTB8%2BLMEX362BKGp8xB%2BC2RbqM8JmGDx%2FDKLqLozihzzEevUcHkds2aRL%2FjXK%2FGLbhGeQX1hmUpOil9DO17eBhtkPxEqXJK76E3WBYdnYL47gb0%2FSyhucd%2FQyTf%2BciRzxd9dilAeOa%2Bfbxu4HFB2xs3zDOhi2M8wAFqyF6DFdhGsarj0GyQckQRWgepEigQRI%2FrWZk8OjAHhh3Mn4hZmE%2FCucr3JbG6%2B2ocyY2APo8Ins6BeljqPi%2FZuij206RQB4X9Rx9bNcByGOcizoicTBhgqcoLdJoGE%2BflvgzP6FghpIe00hzHbNAI1c3BRptNXmeRrZjnU6jz8lI%2Ffr%2B93vty7%2FS1afJahP9mN9ool6aYU3NTuMkXcTzeBVEo13rYEcRMjC7a97HZLQpHf5CafrKzE7wlMZFKqGXMH0gt99a7OwLexg5Hr7kT175yQp%2F7kP%2BhN5zq1v8fHcfPeM3Tp%2BS71v2KSEZHoD4KZmyEfg6eTCS1dD79sfX4ed48MWf%2FPWDD1QaJHOUVlzH7RIZxkqmSFAUpOH3okE8hb5V3c7JoD%2FBTB5M04dl5K%2FXEZYWIoR38QozdnoO6Xu7rInyWko3QSBLpc9x1YLwaR6gIHlbXvgMWz2T8AGg4Cp8oFBZlyl9vN%2BA%2BBVt4CXYvpOkT9PMovhZkPg5kPh5DYgfSB1DFagTxcGsSJnNu08o48%2Fb21vKONnZ5pfTqFWkiy7SZRYg97EFujhFujiqSBfdAuhino0sos2CyHKfJuFqnhElijMr1luiAMLSMlFMgSjKyFL8sTLwlJGtuJ6C7Ss%2B8O7I8chRPF9xTS47yshVBqriGvQXU%2FFdcrc7VDxLGZnKwFV8n7ZYysChLfgng77BxI%2Bhd%2BHbbfoGm71zYJDbdTvCHz%2BYYO1pz8lRlQznBFhkld2M%2FACbFHmqyAqzbIpDWAdDqnGwDCNCxN9Q9B0R9cx%2BYOZZ09k5cHuO83atIoc2wW%2BmXeQ32xX5zTABfnPPxm%2BWTGzEj78UcNLbsNEhaHQie7yBEQ7CK24ID8IrrgU6Aq9MtzsAWqvJJDu%2B%2BFJgi5aYpCFAzh1vBznGtDrFMYDDsI4Zy7CGbCPGerGDO42ZsNps1o75cRzp5se5mp%2F2zE9d3xqX3o4oE1Oc3R8ptr2YpEArDu1OUsyrdr8A7e4Ck9l2tbt51e7taXezru%2FWlKbdF38%2BjL%2Fp%2F%2F7P6%2B%2Bj4WPw6cPdt%2FEcWDlJts4MLPMjojsyLeAOKxS6elhaGxCyG83RC0KmAcpYg1Y3rAaEDI6BkLq6cZyQ3aq2VxQ0wzUOiBo9%2B4iSEA8bSlgjyMkH5QfkQ10Un4qYE1nSooOWd5AZRGxYLWoisUH0iZUkZtRXfJX%2BNCT%2FkxZif4tWsQNyZTsFuTKMFuUKHGmjfKT3Bi%2FDHwzHYPRztx1lpsEIRrEUz6PXZBCng6rMA2aD7Q455PumUJKYADyeY8V12AC6lJUJELwrOsGn6H1M1%2FiY8RiRn90RJ8aQioWjDDRlMBABI3kNudihJBwTgFn%2BPto5Cl3JA4fkdRkmZb0cKANIKE%2BalDQBFFW3aMLqrkQ1sT4PzzflmDA5mK%2FgGWwSAGpuTQDIVWtHpveGIRPAHOdd%2Ftk4RpPFMWA8j2SG0S8noIfHnF5aQA%2Fvdw4KPCyjny2WZz%2BOVfdswVKDsTym556JMNx%2FVDOWR6mKA7hIb6zrFWli2CJN2vXG8oyBS7Kf%2FVidNesuqPBY845oV1P0uW3ntnnnG57r4PkNnsH4Bp3D0pnQwB%2BtpjHmnZ2M98F9jiV7T7BNUbBbdp9foGevVWDcqPu8bmyOKQ0Lw6rlyiSStD8P0jrMMd3C1pbo2QQgnOgbeyfofRUVW3oK8Sy9RYgHrjl0KHvsPAgPFJDjxNKqK5a2JVUKIWc3dRq71I1MsJeTWwFlPucXTB7AyYx%2FHVD%2Fs0XDJazdMoOwBDTBcp6L1nCJK9zXYFd4MU5jFr%2BvpSd%2BX62f0nuuI8L8GR4rFZwbAsEcvUSVliobVVrXiO%2F2UCW3tYdniN2K%2BNaPhAgs8fx9uEmDSYTIDeNgmsa065PdWT%2BQwjZdqGLRul1fkAsYFboWjc0DsQ3YWvhljlTAJuBO2MGSDP5qslnTQduRPEc9%2B%2F9PMW2OE%2Fykm2k23D7tSfLu5ibf%2Fkv2GHbHztqIC70u6Y9vAR3LrvGojcKnZE1WjH3YrtIKS7oNmZYeJCRpepGDt5wpzTxp4gJ5f9eCmzQ1ek1L43bK0IjrPCLurGd6SteH8JeQgzNizB4qAsiUtawI5Ex6fx5F4HVKEWhvhpyN4o8a6qOPiNV0ZK9ealKmo01G5BzjJ2tS3uuGeHAJa07g2a0f4xD3OZeIwsuxcCbjC1n8GVlX2W17%2FLPtxwksBc%2BCDqUn1Q7nLCYvvakugljbRHS7WYqnkynNG7KZhOocV6hTH%2BqYlmyXnOZJgTo%2Fp0uOq8HD%2BrJbMyVdjLzqTDzcdIYm7gQEL8XaqKdJrsMLnPLiqLo4SbEMqPYmd682TxWoAm2muGfhd665M%2FtYP1BOTRe09q%2B%2Bl6dzn8YJGr1M0Zomnuz8cbjvudc1AVUvWsW7RlHFA0l6ptsmytXF2Q3AJrxpsw5W8PwmmP49p8TMz3EocwQROK85zHkiJDmG%2B7IuFz8jB2qubFqHTW3pbAokvUlmUyhdvykGvbJjtdaUrzaBIIlO8KNYDvGqNGVxqXStaTkil15XXdtZdc37R%2Bsz8Z7r1ULuzGzN3yB%2FjdWCHGQXvup2gYwgf43NgpZfr57SRthTcjWo7nk5bdGBdS1t3Ale6V5ZYhvOULtCqrNAqo6pKvkAyQbcdZcHkDpGVvlwxxYLiYI5DUdlMDQwL5ceHiKkPtma7NQnqdkKF5b6ZAPVwsFB1WEuaGch04aqx1Kd6o0pDsRGXuWb1R2XqZSgebhJUVIjYYG%2FR1dn8fRNCUqA7RYKwfVCk4tJTEAdkpY1%2BbWyrFLpkW0yYsKuW1nWllZZFiwTBWVY2gRCZ1AcQ2hfrCRFd%2BcrUD1gsRBTPHCk8KgQJLEMZ7OMwdAm%2FEHynhgN1yTCjX6VNVCsIXkW5qkNI55gzFfxCu1ZftbUhGm398o9WoDbXBdFmOc%2BN27YRYhdQ2s3G%2FNbW%2Fl3BNuduCvqHrZzeCSUvLR2ve%2FgrlbpvrdiP3iL5prQzztRI9Nb%2FSQJXnMXMEW3e%2FJeSLBuWHs78jLSj8tuUHlMJHwDPsj6cGzgcNUYVgLTyj2VJYDVh2WUvXy7syxzLLBz0L8AdupSsOxp%2B3fvY1nbE7Xg2bAsyHXmFcoeBWUFtXlQR%2Bo1daRRm6saB7LlOrsOVDpSQ%2FQS3niqJRveSJ2k9gve8FC0g7KrmTIlVYPWOMU6Op9KxHcUISa9SRzDpruXRth1RVlt1whLyjb%2BGa0wkK9YKUudMcOa6FCqL8q9tLGaqjuSjax%2B9SE0Z2QBRy98oStVDsVl3EPz9I9BskHJEEVoHqSIBan5Ri4oqHJLmKL9XpOHVct7hrwr%2B4AROjvspp3f0zDjMVYlxrk1jIAMNFUVNUzL0EBqffWfChpwC3tYAVldwwZiSHXzaqKfGEJrs2oejCGuE%2FXmMERdeJ%2FlGkqTVyjy3VNcje305o7Yjoqur7gUXuC%2F2T5%2B7pg0skhjO7ernHAxle7cokDuFoxRXH7gl2EMVk2T6Yyc7sAaoQcI4yx4AUpabBcv8LDHK144P14ANjCrFPfO4AUg07ppke8nWtBN41a2Yx9KS94F%2BYuBgtsA%2Fiwp5S6XwYIvpjcWTMJY8TTBeJgkHYDUhq%2FYjzQzMAaxZOT5I26cHGiBt%2BI5FZ9wOKuLP5mmQnhDxddzX2eTHVmznYlZfk5mdJ3CnrmlX8F2IMpq2NukiVW%2FL%2Bm30Ll1Ek%2FRZlMUokbFrCd2VNdMQM5MFaiu08Rmc7CcXUvVt2VJ9brxQ1z3dceSAjPvswv5hdrS4h7rmsH3l5RmSU2pWLmNvX%2Fbm3nrdWfeWYU0afIKzbwpmBhoVY75Om54EDZnk98hj%2FoupJAWb%2F8tjmgU3%2FaVOWAFZJSqtLt3dHMdill8a6tZKr%2BE3uX5Yncmhe7AKe%2B4FwTz7GeZQkmG%2F03DaFMxgnAU0bsz1NMBx5ko2P0mOnbCd%2B9%2FHOk2Y9nscFseYL%2BqDt%2FWsjIJNx%2FqaPFrRsxl43nsJ4ZX%2BcZKPcF9ewWhNUP3bh0A%2BPEZdN4saLrLMWLjasK4elFaw351vSh617wohtTYWfXW1IwjAMTbXPfkIR9REuIRI9lHbYOKuity%2BqkhAaWZA%2Fq%2BgtoDo9k3CNXEoZyCMvzbfGFyGO3qfddpDXIer%2BN7kPNMuSpILP5WF5gytGOqfzxFEU0b3J%2BR4oYpVv4BPl3NyU%2F9mInqjroXq%2B3KDiMz4JJopS7dLYQXixJl3k81V5TII%2F5N4mllW3BCjsps0lDjSrYC6UKvzpy8Xu7VJS8qzQDyeB%2BKDmIMlDMvsE%2Fd0OQanU5ucoWXmBM5OwB7nrmwu1O25jQm9ryiZfJMIFLJAmDz2VYejes%2BAm1h5trWiSuWzmBmvn99ZYpChQk7pgAvUCaL5JVjfi09gmbzgPXclocmrpM%2FguVxRhXWsjVcMwdq83YgarNBq%2B15xX19NJUrHGkazwSciYw0a5ATl1hew1XmsDLXL%2Fivuv1bwqeZpcwbSuI%2FMtnarTvK8cJk%2Fzbctt5vWxDPFysCsXuhVv5uymHAt%2FAR9vWSzpcWyHOob9JhVRex3eery%2F4Es1QwTeGSZecqmXfuB79BL1UOQPm4VY1XRaHv3g8j5kB%2FvY7CrNwqT0A9zH%2Bf0GOCNguiv%2FFNj%2BEceMpJtf3hjW6EUi8xvu4xip9xG9GsJUAD1NU57Q4p%2FwYUsmbyVdutQjaBwkyGLirkbdH0N2hkfEpjlnMuEfwpiw%2FxDJEr%2FgE%3D">springIoC初始化过程</a>;   (不要看网址,   太长了)</p><blockquote><p>总体来看,   BeanDefinition的生成,   首先把配置文件中的属性层层包装,   然后生成一个代理类,   对属性进行封装,   生成对应的BeanDefinition对象;   </p></blockquote><h2 id="BeanDefinition注入容器"><a href="#BeanDefinition注入容器" class="headerlink" title="BeanDefinition注入容器"></a>BeanDefinition注入容器</h2><p>bean配置最终会被解析为BeanDefinition,   并与beanName和alias一同封装到那个什么holder当中,   并传入BeanDefinitionReaderUtils的registerBeanDefinition方法中,   最后通过给定的bean工厂把给定的BeanDefinition注入到beanDefinitionMap中,   这个beanDefinitionMap是一个ConcurrentHashMap;   </p><p>上述步骤完成之后,   实际上还没有进行具体的对象的实例化,   只是相当于把bean信息放入了容器当中,   而在实例化的时候,   会实例化用户指定的对象,   也会实例化容器自身的对象;   对于用户指定的对象,   其在实例化的时候,   会创建BeanPostProcessor对其jn’xy</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IoC启动源码&quot;&gt;&lt;a href=&quot;#IoC启动源码&quot; class=&quot;headerlink&quot; title=&quot;IoC启动源码&quot;&gt;&lt;/a&gt;IoC启动源码&lt;/h1&gt;&lt;h2 id=&quot;Resource定位&quot;&gt;&lt;a href=&quot;#Resource定位&quot; class=&quot;head</summary>
      
    
    
    
    <category term="SSM" scheme="http://example.com/categories/SSM/"/>
    
    
  </entry>
  
  <entry>
    <title>24_ 备忘录模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/24-bei-wang-lu-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/24-bei-wang-lu-mo-shi/</id>
    <published>2023-03-14T07:33:39.000Z</published>
    <updated>2023-03-14T07:34:54.558Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>23_ 亨元模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/23-heng-yuan-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/23-heng-yuan-mo-shi/</id>
    <published>2023-03-14T07:33:18.000Z</published>
    <updated>2023-03-14T07:34:52.411Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>22_ 解释器模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/22-jie-shi-qi-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/22-jie-shi-qi-mo-shi/</id>
    <published>2023-03-14T07:33:14.000Z</published>
    <updated>2023-03-14T07:34:50.263Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>21_ 中介者模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/21-zhong-jie-zhe-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/21-zhong-jie-zhe-mo-shi/</id>
    <published>2023-03-14T07:33:10.000Z</published>
    <updated>2023-03-14T07:34:48.401Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>20_ 原型模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/20-yuan-xing-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/20-yuan-xing-mo-shi/</id>
    <published>2023-03-14T07:33:05.000Z</published>
    <updated>2023-03-14T07:34:46.665Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>19_ 状态模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/19-zhuang-tai-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/19-zhuang-tai-mo-shi/</id>
    <published>2023-03-14T07:33:01.000Z</published>
    <updated>2023-03-14T07:34:44.889Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>18_ 访问者模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/18-fang-wen-zhe-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/18-fang-wen-zhe-mo-shi/</id>
    <published>2023-03-14T07:32:18.000Z</published>
    <updated>2023-03-14T07:34:42.963Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>17_ 责任链模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/17-ze-ren-lian-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/17-ze-ren-lian-mo-shi/</id>
    <published>2023-03-14T07:32:14.000Z</published>
    <updated>2023-03-14T07:34:41.130Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>16_ 观察者模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/16-guan-cha-zhe-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/16-guan-cha-zhe-mo-shi/</id>
    <published>2023-03-14T07:32:10.000Z</published>
    <updated>2023-03-14T07:34:39.507Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>13_ 装饰模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/13-zhuang-shi-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/13-zhuang-shi-mo-shi/</id>
    <published>2023-03-14T07:32:00.000Z</published>
    <updated>2023-03-14T07:34:37.613Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>12_ 命令模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/12-ming-ling-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/12-ming-ling-mo-shi/</id>
    <published>2023-03-14T07:31:56.000Z</published>
    <updated>2023-03-14T07:34:35.519Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>11_ 桥梁模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/11-qiao-liang-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/11-qiao-liang-mo-shi/</id>
    <published>2023-03-14T07:31:51.000Z</published>
    <updated>2023-03-14T07:34:33.802Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>10_建造者模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/10-jian-zao-zhe-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/10-jian-zao-zhe-mo-shi/</id>
    <published>2023-03-14T07:31:47.000Z</published>
    <updated>2023-03-14T07:34:31.138Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>09_ 模板方法模式</title>
    <link href="http://example.com/2023/03/14/she-ji-mo-shi/09-mo-ban-fang-fa-mo-shi/"/>
    <id>http://example.com/2023/03/14/she-ji-mo-shi/09-mo-ban-fang-fa-mo-shi/</id>
    <published>2023-03-14T07:31:43.000Z</published>
    <updated>2023-03-14T07:34:29.313Z</updated>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
