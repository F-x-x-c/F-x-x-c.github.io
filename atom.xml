<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aegis</title>
  
  <subtitle>Aegis Curiser</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-07T08:41:12.817Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Deng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/06/suan-fa-da-han-shua-ti/suan-fa-da-han-shua-ti-01/"/>
    <id>http://example.com/2023/03/06/suan-fa-da-han-shua-ti/suan-fa-da-han-shua-ti-01/</id>
    <published>2023-03-06T06:58:04.468Z</published>
    <updated>2023-03-07T08:41:12.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大厂刷题01"><a href="#大厂刷题01" class="headerlink" title="大厂刷题01"></a>大厂刷题01</h1><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>给定一个有序数组arr,   代表坐落在x轴的点,   给定一个正数K,   代表绳子长度,   返回绳子中最多压中的几个点? (绳子边缘覆盖的点也算)</p><p>解法1:   贪心</p><p>绳子的末尾只需要压在每一个arr[i]处,   判断此时能够压住多少点即可,   绳子的末尾不需要压在非arr[i]处;   设绳长为L,   当遍历到arr[i]的时候,   绳子锁盖住的范围为[ arr[i]-L,   arr[i] ],   <strong>这个时候只需要获得坐标轴上,   下标大于等于arr[i]-L并且还存在于arr中的点即可</strong>,   具体做法:   对arr进行二分,   先取得arr[(0+i)/2]的值,   判断该值是否大于等于arr[i]-L,   如果大于,   则让左指针跳到mid+1的地方;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> R, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index = R;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">index = mid;</span><br><span class="line">R = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">L = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此便可采用二分的方法找到大于arr[i]-L的最小下标;   根据每一个最近的下标,  算出这条线上有多少个值即可;   </p><p>解法2:   滑动窗口</p><p>讨论必须以左指针L为头的窗口,   并且右指针R到达窗口最大值的时候,   能够包含多少个点,   这是一个动态的过程,   L一个一个地往右,   R也是,   所以这种方法地时间复杂度为O(N),   因为只遍历数组两次;   而上面的方法的时间复杂度为O(N * logN);   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoint2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> N = arr.length;</span><br><span class="line">   <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (left &lt; N) &#123;</span><br><span class="line">      <span class="keyword">while</span> (right &lt; N &amp;&amp; arr[right] - arr[left] &lt;= L) &#123;</span><br><span class="line">         right++;</span><br><span class="line">      &#125;</span><br><span class="line">      max = Math.max(max, right - left);</span><br><span class="line">      left++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p>给定一个文件目录路径,   写一个函数统计这个目录下面的所有文件的数量并返回,   隐藏文件也算,    但文件夹不算;   </p><p>解法:   准备一个队列,   遍历到的是文件,   则count++,   是文件夹,   则放入队列中去;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFileNumber</span><span class="params">(String folderPath)</span> </span>&#123;</span><br><span class="line">    File root = <span class="keyword">new</span> File(folderPath);</span><br><span class="line">    <span class="keyword">if</span> (!root.isDirectory() &amp;&amp; !root.isFile()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.isFile()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;File&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        File curFile = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (File file : curFile.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory())&#123;</span><br><span class="line">                queue.add(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String path = <span class="string">&quot;D:\\Program Files\\Neat Download\\ArcSoft_ArcFace_Java_Windows_x64_V3.0&quot;</span>;</span><br><span class="line">    System.out.println(getFileNumber(path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><p>题目:   给定一个非负整数num,   如何不用循环语句,   返回&gt;=num,   并且离num最近的2次幂数;   </p><p>思路:   一段神奇的代码~在这个代码中,   完成那一堆无符号右移与操作之后,   可以把二进制形式下的n最高位的1右边全部填为1,   这玩意儿+1,   就变成了比n大的最小2次幂数;   为了避免本身就是2的次幂数进行上述操作之后导致的问题,   所以需要减1;   也就是说,   如果n刚好是2的次幂,   则给它打到后一位去,   防止它通过算法找到它的下一个2次幂数;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">n--;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到这里n为0...0111111...11, 加一就变成了只有一个1</span></span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h2><p>题目:   一个数组中只有’G’和’B’,   想让所有的G都放在左侧,   所有的B都放在右侧,   但是只能在相邻字符之间进行交换操作,   至少需要交换几次,   返回交换次数;   </p><p>思路:   贪心策略—每一个’B’都不会跑到前一个’B’的前面,   每一个’G’都不会跑到前一个’G’的前面;   所以这道题可以这么干:   拿一个指针b指向B,   拿一个指针g指向G,   指针g指向的是当前遍历到的需要调整位置的字符’G’的位置,   而指针b指向的是最左边的’B’,   这两个指针之间的字符一定全是’B’,   所以就这么调整咯,   两个指针都不回退,   所以时间复杂度O(N);   该贪心策略其实就是排序算法的稳定性的问题,   即相同的被排序元素的相对位置是否不变;   在这道题中,   不管是’B’还是’G’,   其相对位置都没有必要发生变化,   因为如果发生了变化,   则说明一个元素跑到了与它相同的前一个元素的前面,   也就是多交换了几位;    </p><p>因为只需要返回次数,   所以根本不需要调动字符数组;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minSteps1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> step1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> gi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123; </span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">step1 += i - (gi++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> step2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">step2 += i - (bi++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.min(step1, step2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而原题既可以是G在左边,   又可以是B在左边,   两相比较,   判断哪种所需的次数少,   代码与上面的一致;   </p><h2 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h2><p>题目一个二维数组,   可以从任何位置出发,   向上下左右任意方向行走,   返回能走出的最长的递增链长度;   要注意是<strong>最长</strong>以及<strong>递增</strong>;   </p><p>直接把暴力递归改成记忆化搜索即可;   但是需要注意,   由于dp[i] [j]依赖的是上下左右四个位置,   所以这道题目不好改成严格位置依赖,   所以就记忆化搜索得了~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath2</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rols = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rols][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            ans = Math.max(ans, process2(matrix, <span class="number">0</span>, <span class="number">0</span>, dp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> rol, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[rol][col] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[rol][col];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> up;</span><br><span class="line">    <span class="keyword">int</span> down;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">int</span> rolN = mat.length;</span><br><span class="line">    <span class="keyword">int</span> colN = mat[<span class="number">0</span>].length;</span><br><span class="line">    up = rol - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; mat[rol][col] &lt; mat[rol - <span class="number">1</span>][col] ?</span><br><span class="line">            process2(mat, rol - <span class="number">1</span>, col, dp) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    down = rol + <span class="number">1</span> &lt; rolN &amp;&amp; mat[rol][col] &lt; mat[rol + <span class="number">1</span>][col] ?</span><br><span class="line">            process2(mat, rol + <span class="number">1</span>, col, dp) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    left = col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; mat[rol][col] &lt; mat[rol][col - <span class="number">1</span>] ?</span><br><span class="line">            process2(mat, rol, col - <span class="number">1</span>, dp) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    right = col + <span class="number">1</span> &lt; colN &amp;&amp; mat[rol][col] &lt; mat[rol][col + <span class="number">1</span>] ?</span><br><span class="line">            process2(mat, rol, col + <span class="number">1</span>, dp) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dp[rol][col] = Math.max(Math.max(up, down), Math.max(left, right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[rol][col];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>什么情况之下要改成严格位置依赖? </p><p>dp[i] [j]所依赖的位置是一连串的时候,   比如这道题为什么不改,   是因为它就依赖4个位置,   或者说它就依赖O(1)个位置,   所以不用改,   但是如果它依赖的是一行或者一列,   则需要改成严格位置依赖;   </p></blockquote><h2 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h2><p>题目:   给定两个非负数组x和hp,   长度为N,   再给定一个正数range,   以及一个有序数组x,   x[i]表示i号怪兽在x轴上的位置,   hp[i]表示i号怪兽的血量,   range表示法师如果站在x位置,   用AOE技能打到的范围为[x - range,   x + range],   被打到的每只怪兽损失1点血量,   返回要把所有怪兽血量清空所释放的最少AOE技能的次数;   </p><p>思路:   先来一个贪心,   对最左边的血量不为0的元素,   把施法范围的左边界卡在它的位置上,   然后开始摁技能,   摁到它死,   再看下一最左边的血量不为0的元素,   采用同样的方法;   </p><p>使用线段树就可以解决,   也就是贪心策略+线段树,   所以线段树和IndexTree的代码要熟记呀</p><h2 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h2><p>题目:   给定一个数组arr,   可以在每个数字之前决定+或者-,   但是必须所有数字都参与,   再给定一个数target,   所有数字跟它前面的符号相结合进行计算,   求最后算出的结果刚好为target的方法数;   </p><p>思路1:   暴力递归</p><p>当越界的时候,   如果刚好此时rest减完,   则方法数+1,   否则方法数+0;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTargetSumWays1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process1(arr, <span class="number">0</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process1(arr, index + <span class="number">1</span>, rest + arr[index]) +</span><br><span class="line">            process1(arr, index + <span class="number">1</span>, rest - arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成动态规划,   动态规划数组dp[index,   rest]的含义是:   对于arr[0,   index],   凑出rest的方法数;   但是改成动态规划的话,   太过于复杂,   因为rest的范围是[target-Max(arr),   target+Max(arr)];   </p><p>优化1:   可能arr的元素有正有负,   改变正负其实并不影响计算,   所以将所有的元素取绝对值,   变成正值;   </p><p>优化2:   处理完成之后,   将所有的元素值相加,   和为sum,   如果target&gt;sum,   则方法数为0;   </p><p>优化3:   如果sum和target的奇偶性不同,   则,   方法数为0;   </p><p>优化4:   数组arr的元素取正取负后相加组成target,   所以arr中的元素可以被划分为正集合和负集合,   设正集合为P,   负集合为N,   则P-N=target,   两边同时加P+N,   得到2P=(target+sum),   也就是说,   有多少种方法,   P就对应了多少种(target+sum)/2,   也就是说问题转变为了(target+sum)/2的取法;   </p><p>优化5:   空间压缩技巧;   </p><p>由此得到的暴力递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTargetSumWays2_iter</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(arr[<span class="number">0</span>]) == Math.abs(target) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tarAndSum = (target + sum) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> sum &lt; target || ((target &amp; <span class="number">1</span>) ^ (sum &amp; <span class="number">1</span>)) != <span class="number">0</span> ? <span class="number">0</span> : process2(arr, <span class="number">0</span>, tarAndSum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process2(arr, index + <span class="number">1</span>, rest) + process2(arr, index + <span class="number">1</span>, rest - arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实左程云对这道题的思路根本就不是先提出那5个优化之后,   再进行的代码编写,   而是先提出了优化1和优化4,   写出代码之后发现不对,   然后提出的优化3! 因为使用优化1和优化4进行代码编写的时候,   一定会发现的问题是如果target + sum是一个奇数,   则除2之后结果不正确;   通过观察发现target + sum一定为偶数,   这种思路才得以实现,   然后才推出了优化3;   </p><p>而且这种方法改成动态规划还有一个坑,   就是如果target + sum&lt;0,   则返回0;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大厂刷题01&quot;&gt;&lt;a href=&quot;#大厂刷题01&quot; class=&quot;headerlink&quot; title=&quot;大厂刷题01&quot;&gt;&lt;/a&gt;大厂刷题01&lt;/h1&gt;&lt;h2 id=&quot;题目1&quot;&gt;&lt;a href=&quot;#题目1&quot; class=&quot;headerlink&quot; title=&quot;题目1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/05/bi-ye-lun-wen/pca-yuan-ma/"/>
    <id>http://example.com/2023/03/05/bi-ye-lun-wen/pca-yuan-ma/</id>
    <published>2023-03-05T10:44:23.881Z</published>
    <updated>2023-03-05T11:18:48.503Z</updated>
    
    <content type="html"><![CDATA[<p>下面是OpenCV对于PCA算法的c++实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*M///////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  By downloading, copying, installing or using the software you agree to this license.</span></span><br><span class="line"><span class="comment">//  If you do not agree to this license, do not download, install,</span></span><br><span class="line"><span class="comment">//  copy or use the software.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                          License Agreement</span></span><br><span class="line"><span class="comment">//                For Open Source Computer Vision Library</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.</span></span><br><span class="line"><span class="comment">// Copyright (C) 2009, Willow Garage Inc., all rights reserved.</span></span><br><span class="line"><span class="comment">// Copyright (C) 2013, OpenCV Foundation, all rights reserved.</span></span><br><span class="line"><span class="comment">// Third party copyrights are property of their respective owners.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Redistribution and use in source and binary forms, with or without modification,</span></span><br><span class="line"><span class="comment">// are permitted provided that the following conditions are met:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   * Redistribution&#x27;s of source code must retain the above copyright notice,</span></span><br><span class="line"><span class="comment">//     this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   * Redistribution&#x27;s in binary form must reproduce the above copyright notice,</span></span><br><span class="line"><span class="comment">//     this list of conditions and the following disclaimer in the documentation</span></span><br><span class="line"><span class="comment">//     and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   * The name of the copyright holders may not be used to endorse or promote products</span></span><br><span class="line"><span class="comment">//     derived from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot; and</span></span><br><span class="line"><span class="comment">// any express or implied warranties, including, but not limited to, the implied</span></span><br><span class="line"><span class="comment">// warranties of merchantability and fitness for a particular purpose are disclaimed.</span></span><br><span class="line"><span class="comment">// In no event shall the Intel Corporation or contributors be liable for any direct,</span></span><br><span class="line"><span class="comment">// indirect, incidental, special, exemplary, or consequential damages</span></span><br><span class="line"><span class="comment">// (including, but not limited to, procurement of substitute goods or services;</span></span><br><span class="line"><span class="comment">// loss of use, data, or profits; or business interruption) however caused</span></span><br><span class="line"><span class="comment">// and on any theory of liability, whether in contract, strict liability,</span></span><br><span class="line"><span class="comment">// or tort (including negligence or otherwise) arising in any way out of</span></span><br><span class="line"><span class="comment">// the use of this software, even if advised of the possibility of such damage.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//M*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;precomp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************************\</span></span><br><span class="line"><span class="comment">*                                          PCA                                           *</span></span><br><span class="line"><span class="comment">\****************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cv</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">PCA::<span class="built_in">PCA</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">PCA::<span class="built_in">PCA</span>(InputArray data, InputArray _mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> maxComponents)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">operator</span></span>()(data, _mean, flags, maxComponents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCA::<span class="built_in">PCA</span>(InputArray data, InputArray _mean, <span class="keyword">int</span> flags, <span class="keyword">double</span> retainedVariance)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">operator</span></span>()(data, _mean, flags, retainedVariance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PCA&amp; <span class="title">PCA::operator</span><span class="params">()</span><span class="params">(InputArray _data, InputArray __mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> maxComponents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat data = _data.<span class="built_in">getMat</span>(), _mean = __mean.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="keyword">int</span> covar_flags = CV_COVAR_SCALE;</span><br><span class="line">    <span class="keyword">int</span> len, in_count;</span><br><span class="line">    Size mean_sz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert</span>( data.<span class="built_in">channels</span>() == <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span>( flags &amp; CV_PCA_DATA_AS_COL )</span><br><span class="line">    &#123;</span><br><span class="line">        len = data.rows;</span><br><span class="line">        in_count = data.cols;</span><br><span class="line">        covar_flags |= CV_COVAR_COLS;</span><br><span class="line">        mean_sz = <span class="built_in">Size</span>(<span class="number">1</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = data.cols;</span><br><span class="line">        in_count = data.rows;</span><br><span class="line">        covar_flags |= CV_COVAR_ROWS;</span><br><span class="line">        mean_sz = <span class="built_in">Size</span>(len, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = std::<span class="built_in">min</span>(len, in_count), out_count = count;</span><br><span class="line">    <span class="keyword">if</span>( maxComponents &gt; <span class="number">0</span> )</span><br><span class="line">        out_count = std::<span class="built_in">min</span>(count, maxComponents);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;scrambled&quot; way to compute PCA (when cols(A)&gt;rows(A)):</span></span><br><span class="line">    <span class="comment">// B = A&#x27;A; B*x=b*x; C = AA&#x27;; C*y=c*y -&gt; AA&#x27;*y=c*y -&gt; A&#x27;A*(A&#x27;*y)=c*(A&#x27;*y) -&gt; c = b, x=A&#x27;*y</span></span><br><span class="line">    <span class="keyword">if</span>( len &lt;= in_count )</span><br><span class="line">        covar_flags |= CV_COVAR_NORMAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ctype = std::<span class="built_in">max</span>(CV_32F, data.<span class="built_in">depth</span>());</span><br><span class="line">    mean.<span class="built_in">create</span>( mean_sz, ctype );</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">covar</span><span class="params">( count, count, ctype )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !_mean.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_Assert</span>( _mean.<span class="built_in">size</span>() == mean_sz );</span><br><span class="line">        _mean.<span class="built_in">convertTo</span>(mean, ctype);</span><br><span class="line">        covar_flags |= CV_COVAR_USE_AVG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calcCovarMatrix</span>( data, covar, mean, covar_flags, ctype );</span><br><span class="line">    <span class="built_in">eigen</span>( covar, eigenvalues, eigenvectors );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(covar_flags &amp; CV_COVAR_NORMAL) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// CV_PCA_DATA_AS_ROW: cols(A)&gt;rows(A). x=A&#x27;*y -&gt; x&#x27;=y&#x27;*A</span></span><br><span class="line">        <span class="comment">// CV_PCA_DATA_AS_COL: rows(A)&gt;cols(A). x=A&#x27;&#x27;*y -&gt; x&#x27;=y&#x27;*A&#x27;</span></span><br><span class="line">        Mat tmp_data, tmp_mean = <span class="built_in">repeat</span>(mean, data.rows/mean.rows, data.cols/mean.cols);</span><br><span class="line">        <span class="keyword">if</span>( data.<span class="built_in">type</span>() != ctype || tmp_mean.data == mean.data )</span><br><span class="line">        &#123;</span><br><span class="line">            data.<span class="built_in">convertTo</span>( tmp_data, ctype );</span><br><span class="line">            <span class="built_in">subtract</span>( tmp_data, tmp_mean, tmp_data );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">subtract</span>( data, tmp_mean, tmp_mean );</span><br><span class="line">            tmp_data = tmp_mean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Mat <span class="title">evects1</span><span class="params">(count, len, ctype)</span></span>;</span><br><span class="line">        <span class="built_in">gemm</span>( eigenvectors, tmp_data, <span class="number">1</span>, <span class="built_in">Mat</span>(), <span class="number">0</span>, evects1,</span><br><span class="line">            (flags &amp; CV_PCA_DATA_AS_COL) ? CV_GEMM_B_T : <span class="number">0</span>);</span><br><span class="line">        eigenvectors = evects1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// normalize eigenvectors</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; out_count; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            Mat vec = eigenvectors.<span class="built_in">row</span>(i);</span><br><span class="line">            <span class="built_in">normalize</span>(vec, vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( count &gt; out_count )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// use clone() to physically copy the data and thus deallocate the original matrices</span></span><br><span class="line">        eigenvalues = eigenvalues.<span class="built_in">rowRange</span>(<span class="number">0</span>,out_count).<span class="built_in">clone</span>();</span><br><span class="line">        eigenvectors = eigenvectors.<span class="built_in">rowRange</span>(<span class="number">0</span>,out_count).<span class="built_in">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PCA::write</span><span class="params">(FileStorage&amp; fs )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_Assert</span>( fs.<span class="built_in">isOpened</span>() );</span><br><span class="line"></span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;name&quot;</span> &lt;&lt; <span class="string">&quot;PCA&quot;</span>;</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;vectors&quot;</span> &lt;&lt; eigenvectors;</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;values&quot;</span> &lt;&lt; eigenvalues;</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;mean&quot;</span> &lt;&lt; mean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PCA::read</span><span class="params">(<span class="keyword">const</span> FileNode&amp; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_Assert</span>( !fn.<span class="built_in">empty</span>() );</span><br><span class="line">    <span class="built_in">CV_Assert</span>( (String)fn[<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;PCA&quot;</span> );</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">read</span>(fn[<span class="string">&quot;vectors&quot;</span>], eigenvectors);</span><br><span class="line">    cv::<span class="built_in">read</span>(fn[<span class="string">&quot;values&quot;</span>], eigenvalues);</span><br><span class="line">    cv::<span class="built_in">read</span>(fn[<span class="string">&quot;mean&quot;</span>], mean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computeCumulativeEnergy</span><span class="params">(<span class="keyword">const</span> Mat&amp; eigenvalues, <span class="keyword">double</span> retainedVariance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_DbgAssert</span>( eigenvalues.<span class="built_in">type</span>() == DataType&lt;T&gt;::type );</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">g</span><span class="params">(eigenvalues.size(), DataType&lt;T&gt;::type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ig = <span class="number">0</span>; ig &lt; g.rows; ig++)</span><br><span class="line">    &#123;</span><br><span class="line">        g.at&lt;T&gt;(ig, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> im = <span class="number">0</span>; im &lt;= ig; im++)</span><br><span class="line">        &#123;</span><br><span class="line">            g.at&lt;T&gt;(ig,<span class="number">0</span>) += eigenvalues.at&lt;T&gt;(im,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(L = <span class="number">0</span>; L &lt; eigenvalues.rows; L++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> energy = g.at&lt;T&gt;(L, <span class="number">0</span>) / g.at&lt;T&gt;(g.rows - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(energy &gt; retainedVariance)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L = std::<span class="built_in">max</span>(<span class="number">2</span>, L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PCA&amp; <span class="title">PCA::operator</span><span class="params">()</span><span class="params">(InputArray _data, InputArray __mean, <span class="keyword">int</span> flags, <span class="keyword">double</span> retainedVariance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat data = _data.<span class="built_in">getMat</span>(), _mean = __mean.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="keyword">int</span> covar_flags = CV_COVAR_SCALE;</span><br><span class="line">    <span class="keyword">int</span> len, in_count;</span><br><span class="line">    Size mean_sz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert</span>( data.<span class="built_in">channels</span>() == <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span>( flags &amp; CV_PCA_DATA_AS_COL )</span><br><span class="line">    &#123;</span><br><span class="line">        len = data.rows;</span><br><span class="line">        in_count = data.cols;</span><br><span class="line">        covar_flags |= CV_COVAR_COLS;</span><br><span class="line">        mean_sz = <span class="built_in">Size</span>(<span class="number">1</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = data.cols;</span><br><span class="line">        in_count = data.rows;</span><br><span class="line">        covar_flags |= CV_COVAR_ROWS;</span><br><span class="line">        mean_sz = <span class="built_in">Size</span>(len, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert</span>( retainedVariance &gt; <span class="number">0</span> &amp;&amp; retainedVariance &lt;= <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = std::<span class="built_in">min</span>(len, in_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;scrambled&quot; way to compute PCA (when cols(A)&gt;rows(A)):</span></span><br><span class="line">    <span class="comment">// B = A&#x27;A; B*x=b*x; C = AA&#x27;; C*y=c*y -&gt; AA&#x27;*y=c*y -&gt; A&#x27;A*(A&#x27;*y)=c*(A&#x27;*y) -&gt; c = b, x=A&#x27;*y</span></span><br><span class="line">    <span class="keyword">if</span>( len &lt;= in_count )</span><br><span class="line">        covar_flags |= CV_COVAR_NORMAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ctype = std::<span class="built_in">max</span>(CV_32F, data.<span class="built_in">depth</span>());</span><br><span class="line">    mean.<span class="built_in">create</span>( mean_sz, ctype );</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">covar</span><span class="params">( count, count, ctype )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !_mean.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_Assert</span>( _mean.<span class="built_in">size</span>() == mean_sz );</span><br><span class="line">        _mean.<span class="built_in">convertTo</span>(mean, ctype);</span><br><span class="line">        covar_flags |= CV_COVAR_USE_AVG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calcCovarMatrix</span>( data, covar, mean, covar_flags, ctype );</span><br><span class="line">    <span class="built_in">eigen</span>( covar, eigenvalues, eigenvectors );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(covar_flags &amp; CV_COVAR_NORMAL) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// CV_PCA_DATA_AS_ROW: cols(A)&gt;rows(A). x=A&#x27;*y -&gt; x&#x27;=y&#x27;*A</span></span><br><span class="line">        <span class="comment">// CV_PCA_DATA_AS_COL: rows(A)&gt;cols(A). x=A&#x27;&#x27;*y -&gt; x&#x27;=y&#x27;*A&#x27;</span></span><br><span class="line">        Mat tmp_data, tmp_mean = <span class="built_in">repeat</span>(mean, data.rows/mean.rows, data.cols/mean.cols);</span><br><span class="line">        <span class="keyword">if</span>( data.<span class="built_in">type</span>() != ctype || tmp_mean.data == mean.data )</span><br><span class="line">        &#123;</span><br><span class="line">            data.<span class="built_in">convertTo</span>( tmp_data, ctype );</span><br><span class="line">            <span class="built_in">subtract</span>( tmp_data, tmp_mean, tmp_data );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">subtract</span>( data, tmp_mean, tmp_mean );</span><br><span class="line">            tmp_data = tmp_mean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Mat <span class="title">evects1</span><span class="params">(count, len, ctype)</span></span>;</span><br><span class="line">        <span class="built_in">gemm</span>( eigenvectors, tmp_data, <span class="number">1</span>, <span class="built_in">Mat</span>(), <span class="number">0</span>, evects1,</span><br><span class="line">            (flags &amp; CV_PCA_DATA_AS_COL) ? CV_GEMM_B_T : <span class="number">0</span>);</span><br><span class="line">        eigenvectors = evects1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// normalize all eigenvectors</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; eigenvectors.rows; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            Mat vec = eigenvectors.<span class="built_in">row</span>(i);</span><br><span class="line">            <span class="built_in">normalize</span>(vec, vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the cumulative energy content for each eigenvector</span></span><br><span class="line">    <span class="keyword">int</span> L;</span><br><span class="line">    <span class="keyword">if</span> (ctype == CV_32F)</span><br><span class="line">        L = computeCumulativeEnergy&lt;<span class="keyword">float</span>&gt;(eigenvalues, retainedVariance);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        L = computeCumulativeEnergy&lt;<span class="keyword">double</span>&gt;(eigenvalues, retainedVariance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use clone() to physically copy the data and thus deallocate the original matrices</span></span><br><span class="line">    eigenvalues = eigenvalues.<span class="built_in">rowRange</span>(<span class="number">0</span>,L).<span class="built_in">clone</span>();</span><br><span class="line">    eigenvectors = eigenvectors.<span class="built_in">rowRange</span>(<span class="number">0</span>,L).<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PCA::project</span><span class="params">(InputArray _data, OutputArray result)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat data = _data.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="built_in">CV_Assert</span>( !mean.<span class="built_in">empty</span>() &amp;&amp; !eigenvectors.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">        ((mean.rows == <span class="number">1</span> &amp;&amp; mean.cols == data.cols) || (mean.cols == <span class="number">1</span> &amp;&amp; mean.rows == data.rows)));</span><br><span class="line">    Mat tmp_data, tmp_mean = <span class="built_in">repeat</span>(mean, data.rows/mean.rows, data.cols/mean.cols);</span><br><span class="line">    <span class="keyword">int</span> ctype = mean.<span class="built_in">type</span>();</span><br><span class="line">    <span class="keyword">if</span>( data.<span class="built_in">type</span>() != ctype || tmp_mean.data == mean.data )</span><br><span class="line">    &#123;</span><br><span class="line">        data.<span class="built_in">convertTo</span>( tmp_data, ctype );</span><br><span class="line">        <span class="built_in">subtract</span>( tmp_data, tmp_mean, tmp_data );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">subtract</span>( data, tmp_mean, tmp_mean );</span><br><span class="line">        tmp_data = tmp_mean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( mean.rows == <span class="number">1</span> )</span><br><span class="line">        <span class="built_in">gemm</span>( tmp_data, eigenvectors, <span class="number">1</span>, <span class="built_in">Mat</span>(), <span class="number">0</span>, result, GEMM_2_T );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">gemm</span>( eigenvectors, tmp_data, <span class="number">1</span>, <span class="built_in">Mat</span>(), <span class="number">0</span>, result, <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">PCA::project</span><span class="params">(InputArray data)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat result;</span><br><span class="line">    <span class="built_in">project</span>(data, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PCA::backProject</span><span class="params">(InputArray _data, OutputArray result)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat data = _data.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="built_in">CV_Assert</span>( !mean.<span class="built_in">empty</span>() &amp;&amp; !eigenvectors.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">        ((mean.rows == <span class="number">1</span> &amp;&amp; eigenvectors.rows == data.cols) ||</span><br><span class="line">         (mean.cols == <span class="number">1</span> &amp;&amp; eigenvectors.rows == data.rows)));</span><br><span class="line"></span><br><span class="line">    Mat tmp_data, tmp_mean;</span><br><span class="line">    data.<span class="built_in">convertTo</span>(tmp_data, mean.<span class="built_in">type</span>());</span><br><span class="line">    <span class="keyword">if</span>( mean.rows == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_mean = <span class="built_in">repeat</span>(mean, data.rows, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">gemm</span>( tmp_data, eigenvectors, <span class="number">1</span>, tmp_mean, <span class="number">1</span>, result, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp_mean = <span class="built_in">repeat</span>(mean, <span class="number">1</span>, data.cols);</span><br><span class="line">        <span class="built_in">gemm</span>( eigenvectors, tmp_data, <span class="number">1</span>, tmp_mean, <span class="number">1</span>, result, GEMM_1_T );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">PCA::backProject</span><span class="params">(InputArray data)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat result;</span><br><span class="line">    <span class="built_in">backProject</span>(data, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCACompute</span><span class="params">(InputArray data, InputOutputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    OutputArray eigenvectors, <span class="keyword">int</span> maxComponents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    <span class="built_in">pca</span>(data, mean, <span class="number">0</span>, maxComponents);</span><br><span class="line">    pca.mean.<span class="built_in">copyTo</span>(mean);</span><br><span class="line">    pca.eigenvectors.<span class="built_in">copyTo</span>(eigenvectors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCACompute</span><span class="params">(InputArray data, InputOutputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    OutputArray eigenvectors, OutputArray eigenvalues,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> maxComponents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    <span class="built_in">pca</span>(data, mean, <span class="number">0</span>, maxComponents);</span><br><span class="line">    pca.mean.<span class="built_in">copyTo</span>(mean);</span><br><span class="line">    pca.eigenvectors.<span class="built_in">copyTo</span>(eigenvectors);</span><br><span class="line">    pca.eigenvalues.<span class="built_in">copyTo</span>(eigenvalues);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCACompute</span><span class="params">(InputArray data, InputOutputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    OutputArray eigenvectors, <span class="keyword">double</span> retainedVariance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    <span class="built_in">pca</span>(data, mean, <span class="number">0</span>, retainedVariance);</span><br><span class="line">    pca.mean.<span class="built_in">copyTo</span>(mean);</span><br><span class="line">    pca.eigenvectors.<span class="built_in">copyTo</span>(eigenvectors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCACompute</span><span class="params">(InputArray data, InputOutputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    OutputArray eigenvectors, OutputArray eigenvalues,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">double</span> retainedVariance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    <span class="built_in">pca</span>(data, mean, <span class="number">0</span>, retainedVariance);</span><br><span class="line">    pca.mean.<span class="built_in">copyTo</span>(mean);</span><br><span class="line">    pca.eigenvectors.<span class="built_in">copyTo</span>(eigenvectors);</span><br><span class="line">    pca.eigenvalues.<span class="built_in">copyTo</span>(eigenvalues);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCAProject</span><span class="params">(InputArray data, InputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    InputArray eigenvectors, OutputArray result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    pca.mean = mean.<span class="built_in">getMat</span>();</span><br><span class="line">    pca.eigenvectors = eigenvectors.<span class="built_in">getMat</span>();</span><br><span class="line">    pca.<span class="built_in">project</span>(data, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCABackProject</span><span class="params">(InputArray data, InputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    InputArray eigenvectors, OutputArray result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    pca.mean = mean.<span class="built_in">getMat</span>();</span><br><span class="line">    pca.eigenvectors = eigenvectors.<span class="built_in">getMat</span>();</span><br><span class="line">    pca.<span class="built_in">backProject</span>(data, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类中的calcCovarMatrix函数实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcCovarMatrix</span><span class="params">( <span class="keyword">const</span> Mat* data, <span class="keyword">int</span> nsamples, Mat&amp; covar, Mat&amp; _mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> ctype )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert_N</span>( data, nsamples &gt; <span class="number">0</span> );</span><br><span class="line">    Size size = data[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> sz = size.width * size.height, esz = (<span class="keyword">int</span>)data[<span class="number">0</span>].<span class="built_in">elemSize</span>();</span><br><span class="line">    <span class="keyword">int</span> type = data[<span class="number">0</span>].<span class="built_in">type</span>();</span><br><span class="line">    Mat mean;</span><br><span class="line">    ctype = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(<span class="built_in">CV_MAT_DEPTH</span>(ctype &gt;= <span class="number">0</span> ? ctype : type), _mean.<span class="built_in">depth</span>()), CV_32F);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (flags &amp; CV_COVAR_USE_AVG) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_Assert</span>( _mean.<span class="built_in">size</span>() == size );</span><br><span class="line">        <span class="keyword">if</span>( _mean.<span class="built_in">isContinuous</span>() &amp;&amp; _mean.<span class="built_in">type</span>() == ctype )</span><br><span class="line">            mean = _mean.<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _mean.<span class="built_in">convertTo</span>(mean, ctype);</span><br><span class="line">            mean = mean.<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat _data(nsamples, sz, type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nsamples; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_Assert_N</span>( data[i].<span class="built_in">size</span>() == size, data[i].<span class="built_in">type</span>() == type );</span><br><span class="line">        <span class="keyword">if</span>( data[i].<span class="built_in">isContinuous</span>() )</span><br><span class="line">            <span class="built_in">memcpy</span>( _data.<span class="built_in">ptr</span>(i), data[i].<span class="built_in">ptr</span>(), sz*esz );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Mat <span class="built_in">dataRow</span>(size.height, size.width, type, _data.<span class="built_in">ptr</span>(i));</span><br><span class="line">            data[i].<span class="built_in">copyTo</span>(dataRow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calcCovarMatrix</span>( _data, covar, mean, (flags &amp; ~(CV_COVAR_ROWS|CV_COVAR_COLS)) | CV_COVAR_ROWS, ctype );</span><br><span class="line">    <span class="keyword">if</span>( (flags &amp; CV_COVAR_USE_AVG) == <span class="number">0</span> )</span><br><span class="line">        _mean = mean.<span class="built_in">reshape</span>(<span class="number">1</span>, size.height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcCovarMatrix</span><span class="params">( InputArray _src, OutputArray _covar, InputOutputArray _mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> ctype )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_src.<span class="built_in">kind</span>() == _InputArray::STD_VECTOR_MAT || _src.<span class="built_in">kind</span>() == _InputArray::STD_ARRAY_MAT)</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;cv::Mat&gt; src;</span><br><span class="line">        _src.<span class="built_in">getMatVector</span>(src);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CV_Assert</span>( src.<span class="built_in">size</span>() &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Size size = src[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> type = src[<span class="number">0</span>].<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">        ctype = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(<span class="built_in">CV_MAT_DEPTH</span>(ctype &gt;= <span class="number">0</span> ? ctype : type), _mean.<span class="built_in">depth</span>()), CV_32F);</span><br><span class="line"></span><br><span class="line">        Mat _data(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(src.<span class="built_in">size</span>()), size.<span class="built_in">area</span>(), type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(std::vector&lt;cv::Mat&gt;::iterator each = src.<span class="built_in">begin</span>(); each != src.<span class="built_in">end</span>(); ++each, ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CV_Assert_N</span>( (*each).<span class="built_in">size</span>() == size, (*each).<span class="built_in">type</span>() == type );</span><br><span class="line">            <span class="function">Mat <span class="title">dataRow</span><span class="params">(size.height, size.width, type, _data.ptr(i))</span></span>;</span><br><span class="line">            (*each).<span class="built_in">copyTo</span>(dataRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Mat mean;</span><br><span class="line">        <span class="keyword">if</span>( (flags &amp; CV_COVAR_USE_AVG) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CV_Assert</span>( _mean.<span class="built_in">size</span>() == size );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( mean.<span class="built_in">type</span>() != ctype )</span><br><span class="line">            &#123;</span><br><span class="line">                mean = _mean.<span class="built_in">getMat</span>();</span><br><span class="line">                _mean.<span class="built_in">create</span>(mean.<span class="built_in">size</span>(), ctype);</span><br><span class="line">                Mat tmp = _mean.<span class="built_in">getMat</span>();</span><br><span class="line">                mean.<span class="built_in">convertTo</span>(tmp, ctype);</span><br><span class="line">                mean = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mean = _mean.<span class="built_in">getMat</span>().<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">calcCovarMatrix</span>( _data, _covar, mean, (flags &amp; ~(CV_COVAR_ROWS|CV_COVAR_COLS)) | CV_COVAR_ROWS, ctype );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (flags &amp; CV_COVAR_USE_AVG) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            mean = mean.<span class="built_in">reshape</span>(<span class="number">1</span>, size.height);</span><br><span class="line">            mean.<span class="built_in">copyTo</span>(_mean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat data = _src.<span class="built_in">getMat</span>(), mean;</span><br><span class="line">    <span class="built_in">CV_Assert</span>( ((flags &amp; CV_COVAR_ROWS) != <span class="number">0</span>) ^ ((flags &amp; CV_COVAR_COLS) != <span class="number">0</span>) );</span><br><span class="line">    <span class="keyword">bool</span> takeRows = (flags &amp; CV_COVAR_ROWS) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> type = data.<span class="built_in">type</span>();</span><br><span class="line">    <span class="keyword">int</span> nsamples = takeRows ? data.rows : data.cols;</span><br><span class="line">    <span class="built_in">CV_Assert</span>( nsamples &gt; <span class="number">0</span> );</span><br><span class="line">    Size size = takeRows ? <span class="built_in">Size</span>(data.cols, <span class="number">1</span>) : <span class="built_in">Size</span>(<span class="number">1</span>, data.rows);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (flags &amp; CV_COVAR_USE_AVG) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        mean = _mean.<span class="built_in">getMat</span>();</span><br><span class="line">        ctype = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(<span class="built_in">CV_MAT_DEPTH</span>(ctype &gt;= <span class="number">0</span> ? ctype : type), mean.<span class="built_in">depth</span>()), CV_32F);</span><br><span class="line">        <span class="built_in">CV_Assert</span>( mean.<span class="built_in">size</span>() == size );</span><br><span class="line">        <span class="keyword">if</span>( mean.<span class="built_in">type</span>() != ctype )</span><br><span class="line">        &#123;</span><br><span class="line">            _mean.<span class="built_in">create</span>(mean.<span class="built_in">size</span>(), ctype);</span><br><span class="line">            Mat tmp = _mean.<span class="built_in">getMat</span>();</span><br><span class="line">            mean.<span class="built_in">convertTo</span>(tmp, ctype);</span><br><span class="line">            mean = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ctype = std::<span class="built_in">max</span>(<span class="built_in">CV_MAT_DEPTH</span>(ctype &gt;= <span class="number">0</span> ? ctype : type), CV_32F);</span><br><span class="line">        <span class="built_in">reduce</span>( _src, _mean, takeRows ? <span class="number">0</span> : <span class="number">1</span>, CV_REDUCE_AVG, ctype );</span><br><span class="line">        mean = _mean.<span class="built_in">getMat</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mulTransposed</span>( data, _covar, ((flags &amp; CV_COVAR_NORMAL) == <span class="number">0</span>) ^ takeRows,</span><br><span class="line">        mean, (flags &amp; CV_COVAR_SCALE) != <span class="number">0</span> ? <span class="number">1.</span>/nsamples : <span class="number">1</span>, ctype );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calcCovarMatrix函数中，mulTransposed函数的实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mulTransposed</span><span class="params">(InputArray _src, OutputArray _dst, <span class="keyword">bool</span> ata,</span></span></span><br><span class="line"><span class="params"><span class="function">                   InputArray _delta, <span class="keyword">double</span> scale, <span class="keyword">int</span> dtype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    Mat src = _src.<span class="built_in">getMat</span>(), delta = _delta.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> gemm_level = <span class="number">100</span>; <span class="comment">// boundary above which GEMM is faster.</span></span><br><span class="line">    <span class="keyword">int</span> stype = src.<span class="built_in">type</span>();</span><br><span class="line">    dtype = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(<span class="built_in">CV_MAT_DEPTH</span>(dtype &gt;= <span class="number">0</span> ? dtype : stype), delta.<span class="built_in">depth</span>()), CV_32F);</span><br><span class="line">    <span class="built_in">CV_Assert</span>( src.<span class="built_in">channels</span>() == <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !delta.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_Assert_N</span>( delta.<span class="built_in">channels</span>() == <span class="number">1</span>,</span><br><span class="line">            (delta.rows == src.rows || delta.rows == <span class="number">1</span>),</span><br><span class="line">            (delta.cols == src.cols || delta.cols == <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>( delta.<span class="built_in">type</span>() != dtype )</span><br><span class="line">            delta.<span class="built_in">convertTo</span>(delta, dtype);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dsize = ata ? src.cols : src.rows;</span><br><span class="line">    _dst.<span class="built_in">create</span>( dsize, dsize, dtype );</span><br><span class="line">    Mat dst = _dst.<span class="built_in">getMat</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( src.data == dst.data || (stype == dtype &amp;&amp;</span><br><span class="line">        (dst.cols &gt;= gemm_level &amp;&amp; dst.rows &gt;= gemm_level &amp;&amp;</span><br><span class="line">         src.cols &gt;= gemm_level &amp;&amp; src.rows &gt;= gemm_level)))</span><br><span class="line">    &#123;</span><br><span class="line">        Mat src2;</span><br><span class="line">        <span class="keyword">const</span> Mat* tsrc = &amp;src;</span><br><span class="line">        <span class="keyword">if</span>( !delta.<span class="built_in">empty</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( delta.<span class="built_in">size</span>() == src.<span class="built_in">size</span>() )</span><br><span class="line">                <span class="built_in">subtract</span>( src, delta, src2 );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">repeat</span>(delta, src.rows/delta.rows, src.cols/delta.cols, src2);</span><br><span class="line">                <span class="built_in">subtract</span>( src, src2, src2 );</span><br><span class="line">            &#125;</span><br><span class="line">            tsrc = &amp;src2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">gemm</span>( *tsrc, *tsrc, scale, <span class="built_in">Mat</span>(), <span class="number">0</span>, dst, ata ? GEMM_1_T : GEMM_2_T );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        MulTransposedFunc func = <span class="built_in">getMulTransposedFunc</span>(stype, dtype, ata);</span><br><span class="line">        <span class="keyword">if</span>( !func )</span><br><span class="line">            <span class="built_in">CV_Error</span>( CV_StsUnsupportedFormat, <span class="string">&quot;&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">func</span>( src, dst, delta, scale );</span><br><span class="line">        <span class="built_in">completeSymm</span>( dst, <span class="literal">false</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是getMulTransposedFunc函数的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MulTransposedFunc <span class="title">getMulTransposedFunc</span><span class="params">(<span class="keyword">int</span> stype, <span class="keyword">int</span> dtype, <span class="keyword">bool</span> ata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MulTransposedFunc func = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (stype == CV_8U &amp;&amp; dtype == CV_32F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;uchar,<span class="keyword">float</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;uchar,<span class="keyword">float</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stype == CV_8U &amp;&amp; dtype == CV_64F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;uchar,<span class="keyword">double</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;uchar,<span class="keyword">double</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_16U &amp;&amp; dtype == CV_32F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;ushort,<span class="keyword">float</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;ushort,<span class="keyword">float</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_16U &amp;&amp; dtype == CV_64F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;ushort,<span class="keyword">double</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;ushort,<span class="keyword">double</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_16S &amp;&amp; dtype == CV_32F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;<span class="keyword">short</span>,<span class="keyword">float</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;<span class="keyword">short</span>,<span class="keyword">float</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_16S &amp;&amp; dtype == CV_64F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;<span class="keyword">short</span>,<span class="keyword">double</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;<span class="keyword">short</span>,<span class="keyword">double</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_32F &amp;&amp; dtype == CV_32F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;<span class="keyword">float</span>,<span class="keyword">float</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;<span class="keyword">float</span>,<span class="keyword">float</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_32F &amp;&amp; dtype == CV_64F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;<span class="keyword">float</span>,<span class="keyword">double</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;<span class="keyword">float</span>,<span class="keyword">double</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_64F &amp;&amp; dtype == CV_64F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CV_Assert</span>(func &amp;&amp; <span class="string">&quot;Not supported&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是MulTransposedR和MulTransposedL的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> sT, <span class="keyword">typename</span> dT&gt; <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">MulTransposedR</span><span class="params">(<span class="keyword">const</span> Mat&amp; srcmat, <span class="keyword">const</span> Mat&amp; dstmat, <span class="keyword">const</span> Mat&amp; deltamat, <span class="keyword">double</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">const</span> sT* src = srcmat.ptr&lt;sT&gt;();</span><br><span class="line">    dT* dst = (dT*)dstmat.ptr&lt;dT&gt;();</span><br><span class="line">    <span class="keyword">const</span> dT* delta = deltamat.ptr&lt;dT&gt;();</span><br><span class="line">    <span class="keyword">size_t</span> srcstep = srcmat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(src[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">size_t</span> dststep = dstmat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(dst[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">size_t</span> deltastep = deltamat.rows &gt; <span class="number">1</span> ? deltamat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(delta[<span class="number">0</span>]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> delta_cols = deltamat.cols;</span><br><span class="line">    Size size = srcmat.<span class="built_in">size</span>();</span><br><span class="line">    dT* tdst = dst;</span><br><span class="line">    dT* col_buf = <span class="number">0</span>;</span><br><span class="line">    dT* delta_buf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buf_size = size.height*<span class="built_in"><span class="keyword">sizeof</span></span>(dT);</span><br><span class="line">    AutoBuffer&lt;uchar&gt; buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( delta &amp;&amp; delta_cols &lt; size.width )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>( delta_cols == <span class="number">1</span> );</span><br><span class="line">        buf_size *= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf.<span class="built_in">allocate</span>(buf_size);</span><br><span class="line">    col_buf = (dT*)buf.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( delta &amp;&amp; delta_cols &lt; size.width )</span><br><span class="line">    &#123;</span><br><span class="line">        delta_buf = col_buf + size.height;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size.height; i++ )</span><br><span class="line">            delta_buf[i*<span class="number">4</span>] = delta_buf[i*<span class="number">4</span>+<span class="number">1</span>] =</span><br><span class="line">                delta_buf[i*<span class="number">4</span>+<span class="number">2</span>] = delta_buf[i*<span class="number">4</span>+<span class="number">3</span>] = delta[i*deltastep];</span><br><span class="line">        delta = delta_buf;</span><br><span class="line">        deltastep = deltastep ? <span class="number">4</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CV_SIMD_64F</span></span><br><span class="line">    v_float64x2 v_scale = <span class="built_in">v_setall_f64</span>(scale);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !delta )</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size.width; i++, tdst += dststep )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++ )</span><br><span class="line">                col_buf[k] = src[k*srcstep+i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( j = i; j &lt;= size.width - <span class="number">4</span>; j += <span class="number">4</span> )</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CV_SIMD_64F</span></span><br><span class="line">                <span class="keyword">if</span> (DataType&lt;sT&gt;::depth == CV_64F &amp;&amp; DataType&lt;dT&gt;::depth == CV_64F)</span><br><span class="line">                &#123;</span><br><span class="line">                    v_float64x2 s0 = <span class="built_in">v_setzero_f64</span>(), s1 = <span class="built_in">v_setzero_f64</span>();</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *tsrc = (<span class="keyword">double</span>*)(src + j);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc += srcstep )</span><br><span class="line">                    &#123;</span><br><span class="line">                        v_float64x2 a = <span class="built_in">v_setall_f64</span>((<span class="keyword">double</span>)col_buf[k]);</span><br><span class="line">                        s0 += a * <span class="built_in">v_load</span>(tsrc+<span class="number">0</span>);</span><br><span class="line">                        s1 += a * <span class="built_in">v_load</span>(tsrc+<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">v_store</span>((<span class="keyword">double</span>*)(tdst+j), s0*v_scale);</span><br><span class="line">                    <span class="built_in">v_store</span>((<span class="keyword">double</span>*)(tdst+j+<span class="number">2</span>), s1*v_scale);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">double</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">const</span> sT *tsrc = src + j;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc += srcstep )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">double</span> a = col_buf[k];</span><br><span class="line">                        s0 += a * tsrc[<span class="number">0</span>];</span><br><span class="line">                        s1 += a * tsrc[<span class="number">1</span>];</span><br><span class="line">                        s2 += a * tsrc[<span class="number">2</span>];</span><br><span class="line">                        s3 += a * tsrc[<span class="number">3</span>];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    tdst[j] = (dT)(s0*scale);</span><br><span class="line">                    tdst[j+<span class="number">1</span>] = (dT)(s1*scale);</span><br><span class="line">                    tdst[j+<span class="number">2</span>] = (dT)(s2*scale);</span><br><span class="line">                    tdst[j+<span class="number">3</span>] = (dT)(s3*scale);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( ; j &lt; size.width; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> s0 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> sT *tsrc = src + j;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc += srcstep )</span><br><span class="line">                    s0 += (<span class="keyword">double</span>)col_buf[k] * tsrc[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                tdst[j] = (dT)(s0*scale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size.width; i++, tdst += dststep )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !delta_buf )</span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++ )</span><br><span class="line">                    col_buf[k] = src[k*srcstep+i] - delta[k*deltastep+i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++ )</span><br><span class="line">                    col_buf[k] = src[k*srcstep+i] - delta_buf[k*deltastep];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( j = i; j &lt;= size.width - <span class="number">4</span>; j += <span class="number">4</span> )</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CV_SIMD_64F</span></span><br><span class="line">                <span class="keyword">if</span> (DataType&lt;sT&gt;::depth == CV_64F &amp;&amp; DataType&lt;dT&gt;::depth == CV_64F)</span><br><span class="line">                &#123;</span><br><span class="line">                    v_float64x2 s0 = <span class="built_in">v_setzero_f64</span>(), s1 = <span class="built_in">v_setzero_f64</span>();</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *tsrc = (<span class="keyword">double</span>*)(src + j);</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *d = (<span class="keyword">double</span>*)(delta_buf ? delta_buf : delta + j);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc+=srcstep, d+=deltastep )</span><br><span class="line">                    &#123;</span><br><span class="line">                        v_float64x2 a = <span class="built_in">v_setall_f64</span>((<span class="keyword">double</span>)col_buf[k]);</span><br><span class="line">                        s0 += a * (<span class="built_in">v_load</span>(tsrc+<span class="number">0</span>) - <span class="built_in">v_load</span>(d+<span class="number">0</span>));</span><br><span class="line">                        s1 += a * (<span class="built_in">v_load</span>(tsrc+<span class="number">2</span>) - <span class="built_in">v_load</span>(d+<span class="number">2</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">v_store</span>((<span class="keyword">double</span>*)(tdst+j), s0*v_scale);</span><br><span class="line">                    <span class="built_in">v_store</span>((<span class="keyword">double</span>*)(tdst+j+<span class="number">2</span>), s1*v_scale);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">double</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">const</span> sT *tsrc = src + j;</span><br><span class="line">                    <span class="keyword">const</span> dT *d = delta_buf ? delta_buf : delta + j;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc+=srcstep, d+=deltastep )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">double</span> a = col_buf[k];</span><br><span class="line">                        s0 += a * (tsrc[<span class="number">0</span>] - d[<span class="number">0</span>]);</span><br><span class="line">                        s1 += a * (tsrc[<span class="number">1</span>] - d[<span class="number">1</span>]);</span><br><span class="line">                        s2 += a * (tsrc[<span class="number">2</span>] - d[<span class="number">2</span>]);</span><br><span class="line">                        s3 += a * (tsrc[<span class="number">3</span>] - d[<span class="number">3</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    tdst[j] = (dT)(s0*scale);</span><br><span class="line">                    tdst[j+<span class="number">1</span>] = (dT)(s1*scale);</span><br><span class="line">                    tdst[j+<span class="number">2</span>] = (dT)(s2*scale);</span><br><span class="line">                    tdst[j+<span class="number">3</span>] = (dT)(s3*scale);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( ; j &lt; size.width; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> s0 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> sT *tsrc = src + j;</span><br><span class="line">                <span class="keyword">const</span> dT *d = delta_buf ? delta_buf : delta + j;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc+=srcstep, d+=deltastep )</span><br><span class="line">                    s0 += (<span class="keyword">double</span>)col_buf[k] * (tsrc[<span class="number">0</span>] - d[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                tdst[j] = (dT)(s0*scale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> sT, <span class="keyword">typename</span> dT&gt; <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">MulTransposedL</span><span class="params">(<span class="keyword">const</span> Mat&amp; srcmat, <span class="keyword">const</span> Mat&amp; dstmat, <span class="keyword">const</span> Mat&amp; deltamat, <span class="keyword">double</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">const</span> sT* src = srcmat.ptr&lt;sT&gt;();</span><br><span class="line">    dT* dst = (dT*)dstmat.ptr&lt;dT&gt;();</span><br><span class="line">    <span class="keyword">const</span> dT* delta = deltamat.ptr&lt;dT&gt;();</span><br><span class="line">    <span class="keyword">size_t</span> srcstep = srcmat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(src[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">size_t</span> dststep = dstmat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(dst[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">size_t</span> deltastep = deltamat.rows &gt; <span class="number">1</span> ? deltamat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(delta[<span class="number">0</span>]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> delta_cols = deltamat.cols;</span><br><span class="line">    Size size = srcmat.<span class="built_in">size</span>();</span><br><span class="line">    dT* tdst = dst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !delta )</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size.height; i++, tdst += dststep )</span><br><span class="line">            <span class="keyword">for</span>( j = i; j &lt; size.height; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> sT *tsrc1 = src + i*srcstep;</span><br><span class="line">                <span class="keyword">const</span> sT *tsrc2 = src + j*srcstep;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CV_SIMD_64F</span></span><br><span class="line">                <span class="keyword">if</span> (DataType&lt;sT&gt;::depth == CV_64F &amp;&amp; DataType&lt;dT&gt;::depth == CV_64F)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *v_tsrc1 = (<span class="keyword">double</span> *)(tsrc1);</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *v_tsrc2 = (<span class="keyword">double</span> *)(tsrc2);</span><br><span class="line">                    v_float64x2 v_s = <span class="built_in">v_setzero_f64</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt;= size.width - <span class="number">4</span>; k += <span class="number">4</span> )</span><br><span class="line">                        v_s += (<span class="built_in">v_load</span>(v_tsrc1+k) * <span class="built_in">v_load</span>(v_tsrc2+k)) +</span><br><span class="line">                               (<span class="built_in">v_load</span>(v_tsrc1+k+<span class="number">2</span>) * <span class="built_in">v_load</span>(v_tsrc2+k+<span class="number">2</span>));</span><br><span class="line">                    s += <span class="built_in">v_reduce_sum</span>(v_s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt;= size.width - <span class="number">4</span>; k += <span class="number">4</span> )</span><br><span class="line">                        s += (<span class="keyword">double</span>)tsrc1[k]*tsrc2[k] + (<span class="keyword">double</span>)tsrc1[k+<span class="number">1</span>]*tsrc2[k+<span class="number">1</span>] +</span><br><span class="line">                             (<span class="keyword">double</span>)tsrc1[k+<span class="number">2</span>]*tsrc2[k+<span class="number">2</span>] + (<span class="keyword">double</span>)tsrc1[k+<span class="number">3</span>]*tsrc2[k+<span class="number">3</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>( ; k &lt; size.width; k++ )</span><br><span class="line">                    s += (<span class="keyword">double</span>)tsrc1[k] * tsrc2[k];</span><br><span class="line">                tdst[j] = (dT)(s*scale);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dT delta_buf[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> delta_shift = delta_cols == size.width ? <span class="number">4</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="function">AutoBuffer&lt;uchar&gt; <span class="title">buf</span><span class="params">(size.width*<span class="keyword">sizeof</span>(dT))</span></span>;</span><br><span class="line">        dT* row_buf = (dT*)buf.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size.height; i++, tdst += dststep )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> sT *tsrc1 = src + i*srcstep;</span><br><span class="line">            <span class="keyword">const</span> dT *tdelta1 = delta + i*deltastep;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( delta_cols &lt; size.width )</span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.width; k++ )</span><br><span class="line">                    row_buf[k] = tsrc1[k] - tdelta1[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.width; k++ )</span><br><span class="line">                    row_buf[k] = tsrc1[k] - tdelta1[k];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( j = i; j &lt; size.height; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> sT *tsrc2 = src + j*srcstep;</span><br><span class="line">                <span class="keyword">const</span> dT *tdelta2 = delta + j*deltastep;</span><br><span class="line">                <span class="keyword">if</span>( delta_cols &lt; size.width )</span><br><span class="line">                &#123;</span><br><span class="line">                    delta_buf[<span class="number">0</span>] = delta_buf[<span class="number">1</span>] =</span><br><span class="line">                        delta_buf[<span class="number">2</span>] = delta_buf[<span class="number">3</span>] = tdelta2[<span class="number">0</span>];</span><br><span class="line">                    tdelta2 = delta_buf;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CV_SIMD_64F</span></span><br><span class="line">                <span class="keyword">if</span> (DataType&lt;sT&gt;::depth == CV_64F &amp;&amp; DataType&lt;dT&gt;::depth == CV_64F)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *v_tsrc2 = (<span class="keyword">double</span> *)(tsrc2);</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *v_tdelta2 = (<span class="keyword">double</span> *)(tdelta2);</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *v_row_buf = (<span class="keyword">double</span> *)(row_buf);</span><br><span class="line">                    v_float64x2 v_s = <span class="built_in">v_setzero_f64</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt;= size.width - <span class="number">4</span>; k += <span class="number">4</span>, v_tdelta2 += delta_shift )</span><br><span class="line">                        v_s += ((<span class="built_in">v_load</span>(v_tsrc2+k) - <span class="built_in">v_load</span>(v_tdelta2)) * <span class="built_in">v_load</span>(v_row_buf+k)) +</span><br><span class="line">                               ((<span class="built_in">v_load</span>(v_tsrc2+k+<span class="number">2</span>) - <span class="built_in">v_load</span>(v_tdelta2+<span class="number">2</span>)) * <span class="built_in">v_load</span>(v_row_buf+k+<span class="number">2</span>));</span><br><span class="line">                    s += <span class="built_in">v_reduce_sum</span>(v_s);</span><br><span class="line"></span><br><span class="line">                    tdelta2 = (<span class="keyword">const</span> dT *)(v_tdelta2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt;= size.width<span class="number">-4</span>; k += <span class="number">4</span>, tdelta2 += delta_shift )</span><br><span class="line">                        s += (<span class="keyword">double</span>)row_buf[k]*(tsrc2[k] - tdelta2[<span class="number">0</span>]) +</span><br><span class="line">                             (<span class="keyword">double</span>)row_buf[k+<span class="number">1</span>]*(tsrc2[k+<span class="number">1</span>] - tdelta2[<span class="number">1</span>]) +</span><br><span class="line">                             (<span class="keyword">double</span>)row_buf[k+<span class="number">2</span>]*(tsrc2[k+<span class="number">2</span>] - tdelta2[<span class="number">2</span>]) +</span><br><span class="line">                             (<span class="keyword">double</span>)row_buf[k+<span class="number">3</span>]*(tsrc2[k+<span class="number">3</span>] - tdelta2[<span class="number">3</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>( ; k &lt; size.width; k++, tdelta2++ )</span><br><span class="line">                    s += (<span class="keyword">double</span>)row_buf[k]*(tsrc2[k] - tdelta2[<span class="number">0</span>]);</span><br><span class="line">                tdst[j] = (dT)(s*scale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面是OpenCV对于PCA算法的c++实现&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/04/excalidraw/bi-ye-she-ji/"/>
    <id>http://example.com/2023/03/04/excalidraw/bi-ye-she-ji/</id>
    <published>2023-03-04T13:17:29.290Z</published>
    <updated>2023-03-05T08:56:44.930Z</updated>
    
    <content type="html"><![CDATA[<p>==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==</p><h1 id="Text-Elements"><a href="#Text-Elements" class="headerlink" title="Text Elements"></a>Text Elements</h1><h1 id="Embedded-files"><a href="#Embedded-files" class="headerlink" title="Embedded files"></a>Embedded files</h1><p>5a757ff9f9b8f677b0343565157de4c2cc016b5d: [[Excalidraw/assets/毕业设计/Pasted Image 20230305165632_075.png]]</p><p>%%</p><h1 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;excalidraw&quot;</span>,</span><br><span class="line"><span class="attr">&quot;version&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">&quot;source&quot;</span>: <span class="string">&quot;https://excalidraw.com&quot;</span>,</span><br><span class="line"><span class="attr">&quot;elements&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;image&quot;</span>,</span><br><span class="line"><span class="attr">&quot;version&quot;</span>: <span class="number">76</span>,</span><br><span class="line"><span class="attr">&quot;versionNonce&quot;</span>: <span class="number">418227959</span>,</span><br><span class="line"><span class="attr">&quot;isDeleted&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: <span class="string">&quot;2UQPP8zmlbUeA063mCDd8&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fillStyle&quot;</span>: <span class="string">&quot;hachure&quot;</span>,</span><br><span class="line"><span class="attr">&quot;strokeWidth&quot;</span>: <span class="number">0.5</span>,</span><br><span class="line"><span class="attr">&quot;strokeStyle&quot;</span>: <span class="string">&quot;solid&quot;</span>,</span><br><span class="line"><span class="attr">&quot;roughness&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;opacity&quot;</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">&quot;angle&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;x&quot;</span>: <span class="number">-102.02320969266435</span>,</span><br><span class="line"><span class="attr">&quot;y&quot;</span>: <span class="number">-249.09310605686437</span>,</span><br><span class="line"><span class="attr">&quot;strokeColor&quot;</span>: <span class="string">&quot;transparent&quot;</span>,</span><br><span class="line"><span class="attr">&quot;backgroundColor&quot;</span>: <span class="string">&quot;transparent&quot;</span>,</span><br><span class="line"><span class="attr">&quot;width&quot;</span>: <span class="number">198.45414320576464</span>,</span><br><span class="line"><span class="attr">&quot;height&quot;</span>: <span class="number">459.4436755889085</span>,</span><br><span class="line"><span class="attr">&quot;seed&quot;</span>: <span class="number">1699889911</span>,</span><br><span class="line"><span class="attr">&quot;groupIds&quot;</span>: [],</span><br><span class="line"><span class="attr">&quot;strokeSharpness&quot;</span>: <span class="string">&quot;round&quot;</span>,</span><br><span class="line"><span class="attr">&quot;boundElements&quot;</span>: [],</span><br><span class="line"><span class="attr">&quot;updated&quot;</span>: <span class="number">1678006603368</span>,</span><br><span class="line"><span class="attr">&quot;link&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">&quot;locked&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">&quot;status&quot;</span>: <span class="string">&quot;pending&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fileId&quot;</span>: <span class="string">&quot;5a757ff9f9b8f677b0343565157de4c2cc016b5d&quot;</span>,</span><br><span class="line"><span class="attr">&quot;scale&quot;</span>: [</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">1</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;appState&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;theme&quot;</span>: <span class="string">&quot;light&quot;</span>,</span><br><span class="line"><span class="attr">&quot;viewBackgroundColor&quot;</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemStrokeColor&quot;</span>: <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemBackgroundColor&quot;</span>: <span class="string">&quot;transparent&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemFillStyle&quot;</span>: <span class="string">&quot;hachure&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemStrokeWidth&quot;</span>: <span class="number">0.5</span>,</span><br><span class="line"><span class="attr">&quot;currentItemStrokeStyle&quot;</span>: <span class="string">&quot;solid&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemRoughness&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;currentItemOpacity&quot;</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">&quot;currentItemFontFamily&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">&quot;currentItemFontSize&quot;</span>: <span class="number">28</span>,</span><br><span class="line"><span class="attr">&quot;currentItemTextAlign&quot;</span>: <span class="string">&quot;left&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemStrokeSharpness&quot;</span>: <span class="string">&quot;sharp&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemStartArrowhead&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">&quot;currentItemEndArrowhead&quot;</span>: <span class="string">&quot;arrow&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemLinearStrokeSharpness&quot;</span>: <span class="string">&quot;round&quot;</span>,</span><br><span class="line"><span class="attr">&quot;gridSize&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">&quot;colorPalette&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;files&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%%</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==&lt;/p&gt;
&lt;h1 id=&quot;Text-Elements&quot;&gt;&lt;a href=&quot;#Text-Elements&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="excalidraw" scheme="http://example.com/tags/excalidraw/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/04/bi-ye-lun-wen/f014-bi-ye-lun-wen-chu-gao-01/"/>
    <id>http://example.com/2023/03/04/bi-ye-lun-wen/f014-bi-ye-lun-wen-chu-gao-01/</id>
    <published>2023-03-04T12:37:32.084Z</published>
    <updated>2023-03-05T15:32:06.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><p>录入新员工功能包括:   获取新员工信息,   训练模型;   </p><p>打卡功能包括:   加载训练模型,   获取人脸图片,   识别人脸;   </p><img src="D:/Program%20Files/Typora/img/image-20230305221759217.png" alt="image-20230305221759217" style="zoom:80%;" /><ol><li><p>录入新员工功能</p><p>录取新员工首先要获取新员工的信息,   包括姓名与人脸图片，首先需要打开摄像头，从摄像头中不断捕捉图像帧，检测到捕捉的图像帧有人脸信息之后，才将图片存入人脸；将图片存入本地之后，需要对存入的图片进行训练，将得到训练模型存入本地，方便下此调用。</p></li><li><p>打卡功能</p><p>加载训练好的模型文件，打开摄像头，从摄像头中不断捕获图像帧，识别到捕捉的图像帧有人脸信息后，对该图像帧进行人脸识别，并返回识别结果。</p></li></ol><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>按照模块划分，人脸识别考勤系统可以分为用户界面模块，人脸识别模块，数据存储模块。</p><p>用户界面模块与用户和人脸识别模块进行交互。用户界面模块的功能包括：显示可视化界面及其对应的功能按钮、显示提示信息、读取图片并传入人脸识别模块、显示人脸识别模块传来的识别信息。</p><p>人脸识别模块是该系统的核心模块，它提供如下功能：</p><ol><li><p>人脸检测功能。主要为用户界面模块所调用，使其能够提供真正拥有人脸信息的图像。</p></li><li><p>生成存储图片的信息。为存储的图片生成对应的文件夹。</p></li><li><p>训练模型文件。将用户界面传过来的图片进行预处理，包括统一尺寸、灰度图与二值图的调整，然后进行模型训练，将训练好的模型传给数据存储模块。</p></li><li><p>人脸识别。读取数据存储模块提供的模型文件，对用户界面模块传来的人脸图片通过模型文件进行对比，将识别结果交付给用户界面模块，并将更新的信息传递给数据存储模块。</p></li></ol><p>数据存储模块与人脸识别模块进行交互。由于存在图片数据和员工信息数据，所以存储地点分为本地和数据库。本地负责存储员工人脸图片和模型文件，数据库负责存储员工姓名等信息。它的功能包括：存储信息、将数据传递给人脸识别模块、更新并保存从人脸识别模块传来的相关信息。</p><p>功能测试模块的功能包括调试、日志信息打印。</p><h1 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h1><h2 id="模块实现"><a href="#模块实现" class="headerlink" title="模块实现"></a>模块实现</h2><h3 id="用户界面模块"><a href="#用户界面模块" class="headerlink" title="用户界面模块"></a>用户界面模块</h3><p>用户界面模块是基于Java提供的原生套件Swing来实现的。其主要逻辑：提供一个唯一的主窗体，以及不同的面板，面板中显示所需要显示的各种信息与按键，面板显示在唯一主窗体上。当用户想要切换界面时，将唯一主窗体上现有的面板组件全部移除，创建新的所需要的面板，并放置在唯一主窗体上，通过这样的思路达到面板切换的功能。下面介绍主窗体与主要面板。</p><ol><li><p>主窗体</p><p>由于主窗体是全局唯一的，为了避免不必要的错误，使用单例模式创建主窗体类的对象，在主窗体类文件中创建其对象，并设置其类型为private static final，再设置该类的唯一构造方法为私有，对外只提供获取该对象指针的函数。主窗体提供的功能包括设置窗体关闭按钮监听、设置新面板的方法。</p></li><li><p>主面板</p><p>主面板提供的功能按钮包括打卡按钮和员工管理按钮。</p><p>打卡按钮监听：按下按钮后，调起摄像头并捕捉图像帧，通过人脸识别模块提供的人脸检测函数进行人脸检测，将含有人脸信息的图像传递给人脸识别模块进行人脸识别。</p><p>员工管理按钮监听：按下按钮后，进入员工管理面板。</p><p>主面板还包括一个信息提示框和摄像头实时显示框。在人脸识别模块将人脸识别的信息传递过来之后，主面板将该信息整合并显示到信息提示框上。当UI界面、摄像头实时显示框和打卡功能同时使用唯一主线程的时候，在按下打卡按钮进行人脸识别时，摄像头实时显示框会出现卡顿现象，这是由于不同功能同时使用主线程，导致主线程不得不来回中断以执行不同的功能。所以在实现的时候，另起一线程来完成摄像头实时显示的功能。</p><p>调起摄像头并获取摄像头的图像帧的功能可以通过OpenCV的jar包自带的操作摄像头相关的类来实现，也可以通过其他的jar包比如webcam来实现。考虑到摄像头需要实时显示在Swing提供的JPanel面板上，而webcam本来就提供继承于JPanel的WebcamPanel类，所以本系统采用webcam来实现摄像头相关功能。</p></li><li><p>员工管理面板</p><p>读取缓存类提供的员工信息，并将对应的信息显示在员工管理面板上，并提供返回主面板和转到录入新员工面板的按钮。</p></li><li><p>录入新员工面板</p><p>在该面板中完成新员工录入的功能。它包括一个姓名输入框，一个启动录入人脸功能的按钮，以及摄像头实时显示框。同样的，为了保证UI界面的流畅度，摄像头开启功能、录入人脸功能和摄像头实时显示功能采用异步的方式实现。</p><p>其中添加新员工功能流程图如下：</p><img src="D:/Program%20Files/Typora/img/image-20230305221722587.png" alt="image-20230305221722587" style="zoom:80%;" /><p>其中进行人脸检测的函数、将图片存入本地的函数都由人脸识别模块提供。</p></li></ol><h3 id="人脸识别模块"><a href="#人脸识别模块" class="headerlink" title="人脸识别模块"></a>人脸识别模块</h3><p>人脸识别模块所提供的功能有：保存人脸图片、引擎选择、人脸检测、人脸识别。</p><ol><li><p>保存人脸图片</p><p>人脸识别模块接收用户界面模块传来的人脸图片集合，将人脸图片存入本地。其流程为：</p><img src="D:/Program%20Files/Typora/img/image-20230305221652251.png" alt="image-20230305221652251" style="zoom:80%;" /><p>其中拼音转换功能使用的是pinyin4j的jar包，该jar包可以对同音的中文汉字进行不同拼音的转化，还可以对于非中文汉字字符选择性不转化。</p></li><li><p>引擎选择</p><p>本系统支持2种引擎，一是虹软科技提供的人脸识别引擎，二是通过OpenCV提供的人脸识别接口实现的引擎。</p><p>本系统提供配置文件对引擎进行选择，只需修改配置文件中的值就可以进行引擎的切换。</p><p>两种引擎都实现了人脸检测和人脸识别的功能。</p></li><li><p>人脸检测</p><p>（1）虹软引擎的人脸检测。流程如下：</p><img src="D:/Program%20Files/Typora/img/image-20230305222840644.png" alt="image-20230305222840644" style="zoom:80%;" /><p>其中，保存图像信息、人脸信息、人脸特征所需要的ImageInfo类、FaceInfo类和faceFeature类，以及对应的方法调用都来自于虹软引擎的开放API。</p><p>（2）基于OpenCV的人脸检测。其流程图如下：</p><img src="D:/Program%20Files/Typora/img/image-20230305224809284.png" alt="image-20230305224809284" style="zoom:80%;" /><p>需要注意的是，OpenCV人脸检测所得到的人脸检测结果为OpenCV提供的MatOfRect类，用于存储多个矩阵，也就是多张对输入图片进行检测并切分后的人脸图片，而虹软引擎最后的人脸特征为虹软人脸引擎API提供的FaceFeature类。但是由于这是人脸检测，所以只需要判断最后结果的有无，即对返回结果的判空即可。</p></li><li><p>人脸识别</p><p>人脸检测在本系统中只是起到一个优化系统的作用，真正实现考勤功能的是人脸识别功能。人脸识别功能可以分为两步，一是对目标图像进行训练，生成对应的模型文件，二是对所给定的图像进行比对，通过该图像上的人脸进行判别，进而确定此人的身份。</p><p>人脸识别功能需要对训练图像进行预分类，并设置每一类图像的标签之后，才能对给定的图像进行人脸识别，并返回标签。</p><p>而在本系统中，由于每个人的人脸图片的文件夹名称为相对应的人名的拼音，所以完全可以将每个人的文件夹名称作为该类图像的标签。</p><p>（1）虹软引擎的人脸识别训练。流程图如下：</p><img src="D:/Program%20Files/Typora/img/image-20230305233016778.png" alt="image-20230305233016778" style="zoom:80%;" /><p>其中faceMap类型为Java提供的集合HashMap。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;系统设计&quot;&gt;&lt;a href=&quot;#系统设计&quot; class=&quot;headerlink&quot; title=&quot;系统设计&quot;&gt;&lt;/a&gt;系统设计&lt;/h1&gt;&lt;h2 id=&quot;功能设计&quot;&gt;&lt;a href=&quot;#功能设计&quot; class=&quot;headerlink&quot; title=&quot;功能设计&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/01/shui-mian-yan-jiu/shui-mian-yan-jiu-jie-guo/"/>
    <id>http://example.com/2023/03/01/shui-mian-yan-jiu/shui-mian-yan-jiu-jie-guo/</id>
    <published>2023-03-01T08:42:25.017Z</published>
    <updated>2023-03-06T06:59:39.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="睡眠质量研究结果"><a href="#睡眠质量研究结果" class="headerlink" title="睡眠质量研究结果"></a>睡眠质量研究结果</h1><p>​    说是研究结果,   其实是自己摸索出来的一套能够提高睡眠质量的办法而已;   </p><h2 id="何谓睡得好"><a href="#何谓睡得好" class="headerlink" title="何谓睡得好"></a>何谓睡得好</h2><p>​    本人在高中时期就体验过一次,   那天午觉睡到了下午三点,   睡醒之后就觉得神清气爽的,   去教学楼的路上被叫去打篮球,   然后把对手打爆了🤣;   在大三下期结束后的那个暑假的一段时间里,   本人睡眠质量突然变好了,   而且感觉似乎是身体中有一股气在憋着,   这股气能够抵抗一些对睡眠时造成影响的因素;   但是很奇怪,   从那段时间之后,   那种尤为清醒的状态就再也没出现过了;   </p><p>​    而所谓的睡得好,   其实不是看刚睡醒时的清醒程度,   而是看睡醒之后学习时的大脑灵活度,   就是看大脑转得快不快,   如果快,   那就是睡了个好觉;   </p><p>​    而本人现在其实并不需要这种检测手段,   只需要稍微感受一下就知道自己是否睡好;   </p><p>​    <strong><font color='red'>说明:   睡眠质量对于一天的学习与工作的影响是没有任何其他手段能够更改或者提高的,   一个人可以以某种火热的激情投身学习,   但是不管动力如何强大,   精力与效率一定会大幅度受到睡眠质量的影响, </font></strong>   这也是本人一直努力寻找提升睡眠质量方法的原因;   </p><h2 id="不能提高睡眠质量的举措"><a href="#不能提高睡眠质量的举措" class="headerlink" title="不能提高睡眠质量的举措"></a>不能提高睡眠质量的举措</h2><p>(1) 负离子发生机<br>        本人错误地高估了负离子对于睡眠质量的提高程度;   实际上,   睡眠质量与空气负离子程度没有太大关系;   开启负离子发生机能够使人提前醒来,   这可能没有什么用,   因为不清楚其机制是什么,   是让人在睡眠循环的末尾进入浅睡眠状态然后提高苏醒的几率? 还是直接叫醒,   这一点还需要观察;   </p><p>(2) 服用艾草水,   使用艾草水泡脚或者进行艾灸<br>        前俩玩意儿对睡眠质量其实没有什么影响,   而且包括睡前泡脚和睡前洗澡,   其实对睡眠的影响都不大,   而艾灸后对睡眠有一定的影响,   不过我认为其影响应该是艾灸过程中释放的艾灸烟,   但是艾灸烟的过量吸入其实并不好;   </p><p>(3) 睡前服用某菊茶<br>        没用,   而且难喝!</p><p>(4) 睡前听ASMR<br>        对睡眠质量没啥影响,   但是我爱听🙃(好好想想你丫的为什么爱听!);   </p><p>(5) 挂遮光帘<br>        睡眠时的光线其实对睡眠有影响,   但是也没有太严重,   而如果光线全部遮挡完,   其实是不益于从睡眠中醒来的,   这一点稍后再谈;   </p><p>(6) 睡前积累几件今天做的好事🤣<br>        没用;   不仅对睡眠质量没影响,   对心情好像也没什么影响;   </p><p>(7) 听Subliminal🤣🤣🤣<br>        提示:   作为坚定的无产阶级战士,   笃信马克思哲学的我反对一切虚无缥缈的事物;   Subliminal说是利用音频来刺激人的潜意识啥的,   以前我可能还会信,   但是现在我一眼就认出来,   这玩意儿和七田真的照相记忆没啥区别嘛,   都是宣称能够利用潜意识来搞事情的;   而且没有达到效果的说辞非常多,   哎呀你肯定是没有找到合适的音频,   哎呀你肯定是心不够诚,   那人家七田真也有理由说呀,   哎呀你肯定是没有掌握其中的精髓…作为无产阶级战士,   需要坚信:   一切靠自己的打拼得来,   不要去想什么歪门邪道;   </p><p>(8) 对胃做功夫<br>        以前我认为睡不好,   很有可能是</p><h2 id="可以提高睡眠质量的举措"><a href="#可以提高睡眠质量的举措" class="headerlink" title="可以提高睡眠质量的举措"></a>可以提高睡眠质量的举措</h2><p>(1) 蚊帐<br>        本人是吸蚊体质,   所以深受蚊子的侵害;   其实蚊子叮咬对睡眠质量倒是没太大影响,   主要是蚊子在本人耳边飞过的时候所制造的噪音,   非常影响睡眠;   所以挂一个蚊帐非常有必要;   </p><p>(2) 增加睡眠时间<br>        睡眠时间与睡眠质量息息相关,   但并不是睡得越多越好;   睡得太短肯定不行,   比如有时本人午觉时被吵醒,   没有达到对应的睡眠时间,   下午不仅精神不好,   而且到一定时间还会继续睡😅;   但是适度增加睡眠时间是可以的;   稍微睡长一点反而会得到较好的睡眠质量;   </p><p>​    这里说一下赖床问题,   本人不怎么赖床,   如果一个人赖床了,   估计就是没睡够,   解决方法就是拿十几天想睡多久就睡多久,   自然会调整回来的;   </p><p>(3) 维持自身温度<br>        这一点非常非常重要 ! 在夏天一定不能让自己的睡眠环境太热,   这会影响睡眠质量;   在冬天一定不能让自己的睡眠环境太冷,   如果棉被太薄就再盖一件衣物;   本人就是这样,   冬天在家里睡得好好的,   一到学校睡眠质量就开始变差,   原因找来找去,   最后发现很有可能是南山上面较其他地区而言更冷;   而夏天,   家里人不允许一整夜开空调,   真是气煞我也;   </p><p>(4) 减少光线<br>        减少光线其实说的并不是很准确,   应该说是—减少<strong>人为直射</strong>光线;   夜晚本来应该是漆黑一片的,   但是电力的大范围使用,   夜晚之人类社会的各个角落都被人造光所填满,   而这些光线并不是人类睡眠所需要的,   尤其是这些光线成分中的蓝光,   其实在太阳下山之后就应该减少暴露在人造光下面的时间了,   日出而作,   日落而息就是最好的睡眠习惯;   前面提到,   遮光帘的确能够遮挡光线,   但是它的缺点是,   在太阳升起的时候依然遮住了阳光,   这就会让人体的机制认为还没有到白天,   一旦醒过来之后,   也会昏昏沉沉的;   减少光线的另一个点就是直射,   个人认为,   如果人造光不是直接射到人的脸上,   则稍微有一点也并无大碍,   但最好还是自然的没有(也就是夜晚目及之处没有光线与光源,   这是最好的);   </p><p>(5) 一个人睡<br>        一个人睡其实也就是避免室友的鼾声的影响;   由于本人高中和大学都在住校,   并且高中和大学的寝室里面各自都有不下两个人有打呼噜的习惯,   所以本人非常痛恨打呼噜的人;   别人的呼噜影响本人的入睡,   这是肯定的;   但是别人的呼噜是否会影响本人入睡后的睡眠质量,   这个我就不得而知了,   估计是有影响的;   希望工作之后能够一个人睡吧;   </p><p>(6) 养成喝豆浆的习惯</p><blockquote><p>这里总结一下那段时期的变量:   喝豆浆坚持约一个月、一个人睡、刚降温、没有太大的压力、没有早上打篮球、有练声的习惯;   </p></blockquote><p>​    喝豆浆是从那一段睡眠质量飙升的时期中积累下来的经验;   不过在那段时间之后我尝试复刻,   但是豆浆对于睡眠质量的影响好像并不大,   也可能是豆浆的量和黄豆的量的摄入不足,   因为那时候豆浆一天起码一升半;   “量”这个问题还是得好好研究一下;   </p><p>(7) 冥想<br>        指的是广义的冥想,   其实就是用感官去感受周围的一切,   冥想的时候我的心情是平静且愉悦的;   并不是说想要从宇宙中下载啥啥信息下来,   只是多利用一下感官而已;   吃饭走路发呆都可以冥想;   不过冥想对于睡眠质量的影响呢… 似乎没什么短期的正面影响;   </p><p>(8) 有了睡意再睡<br>        这一点非常重要,   如果能够搭配维持体温,   十有八九就能睡个好觉了;   重点就在于有睡意,   如果没有睡意硬躺下闭上眼的话,   其实醒来的精神是很差的;   </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>找一份朝九晚五的压力不这么大的工作,   一个人住,   一个人睡,   每天坚持喝自己打的豆浆,   把可支配的大部分时间花在自己感兴趣又能提升自己的事情上,   在心情和睡眠上形成正反馈,   安安稳稳快快乐乐平平淡淡地过完一生;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;睡眠质量研究结果&quot;&gt;&lt;a href=&quot;#睡眠质量研究结果&quot; class=&quot;headerlink&quot; title=&quot;睡眠质量研究结果&quot;&gt;&lt;/a&gt;睡眠质量研究结果&lt;/h1&gt;&lt;p&gt;​    说是研究结果,   其实是自己摸索出来的一套能够提高睡眠质量的办法而已;   &lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/01/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-036-you-xu-biao-02/"/>
    <id>http://example.com/2023/03/01/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-036-you-xu-biao-02/</id>
    <published>2023-03-01T07:21:49.247Z</published>
    <updated>2023-03-02T08:32:09.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有序表02"><a href="#有序表02" class="headerlink" title="有序表02"></a>有序表02</h1><h2 id="sb树基础"><a href="#sb树基础" class="headerlink" title="sb树基础"></a>sb树基础</h2><p>搜索二叉树可以看成是一个非抽象父类,   它有自己的功能,   也就是搜索功能,   它实现了两个供子类用的方法,   左旋和右旋;   继承于它的子类通过父亲给的这两个方法,   实现自己的平衡策略;   </p><p>AVL树的平衡策略是|左树高度-右树高度| &lt; 2;   </p><p>而SizeBalancedTree的平衡策略是—以叔叔节点为头的子树的节点个数必须大于等于以它侄子节点为头的子树的节点个数;   </p><blockquote><p>因为是二叉树,   所以一个节点只有两个子节点,   也就是说每一个节点的叔叔节点只有一个,   而每一个节点的侄子节点只有两个;   </p></blockquote><p>现在看来,   如果平衡性是从下往上保证的,   那就是要找到每一个节点的叔叔节点,   然后再比较;   如果平衡性是从上往下保证的,   那就要找到每一节点的侄子节点,   然后再比较;   </p><blockquote><p>时间复杂度估计:   因为在这种平衡机制的作用下,   最悬殊的情况也就是某个爷节点的左孩子的节点个数与右孩子的左(右)孩子节点的节点个数相等,   也就是说,   爷节点的左孩子的节点个数为右孩子的节点个数的1/2,   而这样,   在查询的时候,   从上往下,   每下一层,   最少也会抛弃1/3的节点,   所以在这种平衡机制下,   查询的时间复杂度为O(logN);   </p></blockquote><h2 id="sb树破坏类型"><a href="#sb树破坏类型" class="headerlink" title="sb树破坏类型"></a>sb树破坏类型</h2><p>也有四种,   LL型,   LR型,   RL型,   RR型;   </p><p>设爷节点为Z,   两个孩子分别是X和Y,   破坏类型为AB型;   如果说节点X违规了,   则说明节点X的节点数量比爷节点Z的A边的B边的节点的节点数量要少;   </p><blockquote><p>也就是说,   如果节点X为左孩子节点,   它只能产生RL型和RR型的违规;   右孩子节点则对应之;   </p><p>下面统一把爷节点称为父节点;   </p></blockquote><p>对于LL型的违规,   把父节点传到函数中,   因为这个过程可能会换头,   所以需要有一个节点类型的返回值;   而具体而言,   如果发现右孩子因为左孩子的左孩子的节点数量而违规,   则需要让整棵树右旋,   然后看哪些节点的子树发生了变化,   对于那些子树变化了的头节点,   需要递归调用该函数;   </p><blockquote><p>只要换了孩子的节点都要递归,   因为不能够确定新换过来的孩子是否能够干得过叔叔节点;   </p><p>AVL树的平衡性非常敏感,   也就意味着每旋转一次可能都会有平衡性的调整,   而sb树的平衡性相对于AVL树而言不那么敏感,   所以它调整的次数比较少,   而真正需要调整的时候,   调整的次数&gt;1,   但是数学上可以证明时间复杂度最终收敛为O(logN);   也就是说加节点的时候,   进行平衡性的调整,   而删除节点的时候就不进行平衡性的调整,   由于整体的高度为logN,   所以就算长时间不添加节点,   整棵树的高度也不会太大,   所以在删除节点的时候可以不进行平衡性的调整;   </p></blockquote><blockquote><p>积压结构:   ArrayList会进行自动扩容,   而在扩容的时候,   本质上是开辟一块新空间,   然后把旧的数据拷贝进去,   也就是说ArrayList会在扩容的时候迎来一个性能瓶颈;   在1的时候扩容,   在2的时候扩容,   在4的时候扩容,   在8的时候扩容…    也就是说拷贝的次数是一个等比数列,   所以拷贝的次数为O(N),   而又因为加了N个节点,   所以均摊下来时间复杂度为O(1);   </p><p>红黑树和sb树都属于积压结构,   所以这些树经常用于硬盘结构,   老长时间不变动,   等到积压够了就进行一次大变动,   如果频繁地读取数据,   硬盘IO的瓶颈就展现了;   而在CPU的高速缓存当中,   AVL树的频繁读写可以很快;   </p></blockquote><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表的每一个节点都有许多的链表指针,   以及一个存放该节点值的变量;   </p><p>步骤:   </p><p>(1) 独立步骤—摇色子:   对于每一个节点,   在创建之初,   都进行摇色子的步骤;   每一个节点的链表指针数量为1,   通过摇色子,   0.5概率使指针的数量+1,   0.5的概率不改变指针数量,   而色子一直摇,   直到摇到不改变指针数量这种情况结束,   这个节点的链表指针数量也就定了;   </p><p>(2) 一开始时,   头节点没有链表指针,   在尝试把第一个值纳入跳表中时,   创建第一个节点,   把这个值放入节点中,   并对第一个节点摇色子,   获得第一节点的链表指针数量;   建立起头节点的链表指针,   其数量和第一节点的链表指针数量一致;   将头节点的所有链表指针指向第一节点;   </p><p>(3) 跳表运行一段时间之后,   当新加入一个值X的时候,   对头结点的链表指针做如下操作:   现在遍历到头结点的第i个链表指针,   找到该指针所对应的链表中的第一个节点值大于X的节点Z,   设节点Z之前的节点为节点Y,   将这个新加入的节点放在节点Y和节点Z中间,   也就是让节点Y对应的第i个链表指针指向新节点,   然后让新节点的第i个链表指针指向节点Z;   </p><p>(4) 现在节点Y的第i个链表指针指向了新节点,   此时,   跳到节点Y的第i-1个链表指针,   重复上面的操作,   直到链表指针的标号为1,   并挂完这个新节点;   </p><p>对于某一个输入值X,   随机摇色子,   假设扔出了a层,   所以这个输入值X在[1~a]层都有值,   所以节点的分布规律与输入数据规律无关,   完全随运气决定,   由于各个节点每往上一层,   概率就小0.5,   所以假设有N个节点,   底层(第一层)就一定有N个节点,   而第二层就只有N/2个节点,   第三层就只有N/4个节点;   也就是说,   跳表通过随机因素把输入数据规律解耦掉了;   </p><p>加入一个节点的时间复杂度分析:   当想要加入一个节点时,   从头节点的最高一层链表指针开始,   往右一直找,   找到了就停,   然后从找到的节点开始又继续往右找,   一直到第一层,   每找一次都要跨过最底层的N个节点中的不知道多少个节点,   想象最坏的情况,   每一次就是每一层遍历都要遍历到当前层的最右边,   设总共m层,   也就是说,   最顶层跨过N/2<sup>m-1</sup>个节点,   下一层跨过N/2<sup>m-2</sup>-N/2<sup>m-1</sup>个节点,   一直往下,   总共时间复杂度就为O(logN);   </p><p>实现暂时放放吧;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有序表02&quot;&gt;&lt;a href=&quot;#有序表02&quot; class=&quot;headerlink&quot; title=&quot;有序表02&quot;&gt;&lt;/a&gt;有序表02&lt;/h1&gt;&lt;h2 id=&quot;sb树基础&quot;&gt;&lt;a href=&quot;#sb树基础&quot; class=&quot;headerlink&quot; title=&quot;sb树</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/01/hou-duan-gong-cheng-shi/spring01/"/>
    <id>http://example.com/2023/03/01/hou-duan-gong-cheng-shi/spring01/</id>
    <published>2023-03-01T00:38:33.216Z</published>
    <updated>2023-03-01T07:08:02.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring01"><a href="#Spring01" class="headerlink" title="Spring01"></a>Spring01</h1><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><ol><li><p>JSP+Servlet+JavaBean</p><p>JSP就是前端页面,   Servlet用于接收和处理请求,   JavaBean为相应的对象类,   有了这三个东西,   就可以组建一个服务了;   </p><p>而Web端开发,   实际上就是前端页面和后端处理的过程,    这两者之间的连接就是请求,   所以开发者通常需要在Servlet中撰写多个xml文件,   来实现前端打过来的请求的处理;   </p></li><li><p>MVC三层架构</p><p>browser层用于传递http请求和接收http请求;   controller层用于接收browser层传递过来的请求,   并向model层提交请求,   获取数据,   当然也可以接收model层传递的数据并将数据打包成http请求发给browser层;   而controller层如果直接返回接收到的数据,   那么browser层所接收到的就是一行一行的数据,   所以在返回的时候,   需要view层对数据进行渲染;   </p></li><li><p>EJB</p><p>重量型框架,   依赖和接口比较多,   对项目的侵入性强;   </p></li><li><p>SSH</p><p>配置麻烦;   </p></li><li><p>SSM</p><p><strong>Spring官网</strong> </p><p><a href="https://spring.io/projects/spring-framework#overview">官网地址</a> </p><p><a href="https://repo.spring.io/release/org/springframework/spring/">压缩包下载地址</a> </p><p><a href="https://github.com/spring-projects/spring-framework">源码地址</a> </p><blockquote><p>生态:   可能以后会出现超越Spring的更加优秀的框架,   那时,   要想Spring能够继续被用户使用,   就需要建立一个生态,   也就是说,   需要提供开发所需要的完整组件,   Spring能够和那些组件进行关联,   让开发者在使用Spring的时候,   如果Spring相关的组件,   能够简化开发,   久而久之,   就离不开Spring了;   </p></blockquote></li><li><p>SpringBoot</p></li></ol><h2 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h2><p>实现一个具体的业务代码,   一个服务类为了获取某些数据,   需要获取一个数据类的对象,   如果直接在这个服务类中实现对应的数据类的话,   在修改这个数据类的实现子类时,   会出现大量需要修改的地方;   所以可以在测试类中进行该数据类的对象创建,   然后传入服务类,   服务类在接收数据类对象的时候,   直接接收其抽象类;   </p><p>而这个过程中,   测试类的对象创建过程其实可以交给Spring来做,   这就是Ioc控制反转思想;   </p><blockquote><p>以前在创建对象的时候,   都是自己主动去创建对象,   而引入Ioc思想之后,   就是被动的接受对象,   仅需要把自己的需求交给提供者,   复杂的工作由提供者来做,   自己只需要被动接受即可;   </p><p>类似于共产社会当中,   每户家庭只需要把自己今天想吃的菜单放在门口,   国家会派专人往菜篮子里放菜;   </p></blockquote><p>有了IoC容器之后,   就会由IoC容器来控制对象;   </p><p>引入IoC容器可以解耦合;   在未引入IoC容器之时,   一个系统的各个对象很有可能是”你中调我,   我中调你”的;   引入之后,   IoC能够将各个对象进行解耦;   </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>导入beans,   context,   core,   expression,   以及common-logging的jar包,   即可使用Spring;   </p><p>首先创建对应的xml文件,   要使用spring config类型(要记住,   maven项目中,   xml文件是需要放在resources文件夹中的);   </p><p>然后在xml文件中写下对应的bean:   </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean标签表示要创建的对象</span></span><br><span class="line"><span class="comment">    id为bean的唯一标识, 为了跟其他的bean区分开来; 不能存在两个带有相同id的bean;</span></span><br><span class="line"><span class="comment">    class为要创建的bean的完全限定名,</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;T002_SpringIoC02.bean.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给属性赋值需要使用property标签</span></span><br><span class="line"><span class="comment">        name表示属性的名称;</span></span><br><span class="line"><span class="comment">        value表示具体的属性值;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Faker&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在测试类中,   生成对应的ApplicationContext,   通过强转或者反射机制来实现对象的获取:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*applicationContext表示IoC容器的入口,</span></span><br><span class="line"><span class="comment">        想要获取对象的话, 必须要创建该类, 该类由两个读取配置文件的实现类</span></span><br><span class="line"><span class="comment">        ClasspathXmlApplicationContext: 从classpath中读取数据</span></span><br><span class="line"><span class="comment">        FileSystemXmlApplicationContext: 从当前文件系统读取数据*/</span></span><br><span class="line">    ApplicationContext context =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;ioc.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取具体的bean实例对象, 需要进行强制类型转换</span></span><br><span class="line">    Person person = (Person) context.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">    Person person1 = context.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Person对象是何时被创建的? </p><p>容器中的对象在容器创建完成之前就已经把对象创建hk’le</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring01&quot;&gt;&lt;a href=&quot;#Spring01&quot; class=&quot;headerlink&quot; title=&quot;Spring01&quot;&gt;&lt;/a&gt;Spring01&lt;/h1&gt;&lt;h2 id=&quot;初识&quot;&gt;&lt;a href=&quot;#初识&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/26/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-035-you-xu-biao-01/"/>
    <id>http://example.com/2023/02/26/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-035-you-xu-biao-01/</id>
    <published>2023-02-26T02:21:47.066Z</published>
    <updated>2023-02-28T12:55:15.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有序表01"><a href="#有序表01" class="headerlink" title="有序表01"></a>有序表01</h1><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><h3 id="有序表基础"><a href="#有序表基础" class="headerlink" title="有序表基础"></a>有序表基础</h3><p>​        对于关系型数据库,   查询数据的时候需要从头开始,   这样非常影响效率,   所以关系型数据库引入了索引,   索引可以对可排序的数据建立起某种联结,   方便查询,   比如搜索二叉树,   对于数据库中的主键数据进行排序,   建立搜索二叉树,   比当前节点大的就放它的右边,   比当前节点小的就放它的左边;   </p><p>​        这样做的问题就是,   用户所给的数据本来就是有序的,   比如从小到大,   那么这棵树就会一直往右边倾斜,   这样的话还不如直接在硬盘中进行存储;   也就是说,   搜索二叉树的高度影响着性能;   </p><blockquote><p>如果说使用哈希表或者基于哈希思想的数据结构来存储数据的话,   单个数据查询的平均复杂度可以为O(1),   但是它们不提供范围查询,   而关系型数据库实际上是要提供这样的功能的;   </p></blockquote><p>​        所以引入左旋和右旋;   对于下面这一棵树,   如果这是一棵搜索二叉树,   则A的左子树T上面的所有的节点都小于A,   A的右子树的头节点B下面的所有节点的索引值都大于A;   </p><img src="D:/Program%20Files/Typora/img/image-20230226104844514.png" alt="image-20230226104844514" style="zoom:80%;" /><p>在这样的基础之上,   对该树进行左旋,   也就是**<font color='red'>把头节点A往左边旋转,   也就是让B作为头节点</font><strong>,   但是需要使旋转过后的整棵树依然为搜索二叉树;   也就意味着B要拿掉一个分支,   不然就成三叉树了;   旋转过后的树为搜索二叉树,   所以要满足B节点左边的所有节点都比B小,   B节点右边的所有节点都比B大,   那么这样显而易见</strong><font color='red'>拿掉的就是C节点及其子节点</font>**了,   <strong><font color='red'>拿掉的这棵子树放在A的右指针上</font></strong>;   </p><h3 id="有序表增加与删除"><a href="#有序表增加与删除" class="headerlink" title="有序表增加与删除"></a>有序表增加与删除</h3><p>有序表节点的增加其实很好办,   就让这个节点按照规则顺着树一直往下找,   直到找到一个空指针,   然后把这个节点挂在空指针的位置就可以了,   而删除操作需要分情况:   </p><p>(1) 如果这个节点没有左孩子和有孩子,   直接删除</p><p>(2) 如果这个节点只有一个左孩子或者只有一个右孩子,   拿那个孩子来替这个被删除的节点的位置</p><p>(3) 如果这个节点X既有左孩子又有右孩子,   则找到这个节点X的左孩子的最右节点A,   也就是比节点X小的最大节点,   来替换节点X;   或者找到节点X的右孩子的最左节点B,   也就是比节点X大的最左节点,   来替换节点X;   </p><blockquote><p>由于节点A在节点X的左树上,   且是最大的,   意味着节点A比左树上的所有节点都大,   比右树上的所有节点都小,   替换过后不会破坏搜索性质;   </p><p>由于节点B在节点X的右树上,   且是最小的,   意味着节点B比右树上的所有节点都小,   比左树上的所有节点都大,   替换过后不会破坏搜索性质;   </p></blockquote><h3 id="AVL树的破坏平衡型类型及其补丁"><a href="#AVL树的破坏平衡型类型及其补丁" class="headerlink" title="AVL树的破坏平衡型类型及其补丁"></a>AVL树的破坏平衡型类型及其补丁</h3><p>由于AVL树要保证每一个节点的左右子树高度差小于2(也就是最多为1),   则在平衡性被破坏的情况下,   需要靠左旋和右旋来调整;   </p><p>有四种情况,   LL型,   LR型,   RR型,   RL型;   其中LL型为连续在一个节点的右边增加了连续靠右的两个节点,   导致平衡性被破坏,   而LR型为在一个节点的左边连续增加两个节点,   往左一个往右一个;   RR型和RL型也是一个样;   </p><p>LL型的违规就做一个右旋,   RR型的违规就做一个左旋;   </p><blockquote><p>LR型为头节点的左孩子的右子树过长导致违规,   比如下面这棵树:   </p><img src="D:/Program%20Files/Typora/img/image-20230226155139873.png" alt="image-20230226155139873" style="zoom:80%;" /><p>由于节点B的右子树过长,   所以这个是LR型的违规,   那么要把它调整平衡,   就需要让节点C,   也就是LR型所指代的末端节点,   变为整棵树的头节点;   也就是先对节点B为头的子树做一个左旋,   变为下面这样:   </p><img src="D:/Program%20Files/Typora/img/image-20230226155713432.png" alt="image-20230226155713432" style="zoom:80%;" /><p>然后对整棵树进行右旋,   </p><img src="D:/Program%20Files/Typora/img/image-20230226160017224.png" alt="image-20230226160017224" style="zoom:80%;" /><p>而如果是RL型的话,   自然就是把RL所指代的节点拿到头部去了;   </p></blockquote><p>也就是说,   遇到LL或者RR型,   就把父提到头节点的位置,   遇到LR或者RL型,   就把孙提到头节点的位置;   如果遇到LL型和LR型的组合型破坏,   则只做一次右旋(即对LL型的补丁)即可;   如果遇到RR型和RL型的组合型破坏,   则只做一次左旋(即对RR型的补丁)即可;   </p><blockquote><p>出现LL型和LR型的情况及其解决方案:   </p><p>什么时候会出现LL型和LR型的组合破坏? 就是当下面这种情况出现的时候</p><img src="D:/Program%20Files/Typora/img/image-20230227105201235.png" alt="image-20230227105201235" style="zoom: 67%;" /><p>节点头节点C的左孩子节点B的高度为7,   节点B下面存在两条高度相同的子树K和E,   高度都为6,   头节点C的右孩子节点A的高度为6,   节点A右子树T高度为5,   子树T的最长枝桠中挂着一个Q,   整体满足平衡性,   这时候删掉节点Q,   使得头节点C的右子树整体高度为5,   打破平衡性,   同时因为头节点C的左子树头节点B的左右两棵子树都为6,   所以同时出现了LL型和LR型的破坏;   </p><p>如果说可以证明”当同时出现LL型和LR型时,   可以用LL型的补丁解决不平衡性问题,   但是不能用LR型的补丁解决平衡性问题”,   那就可以得出”当同时出现LL型和LR型时,   只需要使用LL型的补丁解决问题即可”的结论;   </p></blockquote><h3 id="AVL树的调整"><a href="#AVL树的调整" class="headerlink" title="AVL树的调整"></a>AVL树的调整</h3><p>(1) 加入节点</p><p>对于加入节点及其所有的祖先节点,   都要进行破坏类型的判断及其修正,   一直到整棵树的头节点,   由于每一种破坏类型的调整的时间复杂度都为O(1),   所以每一个节点加入过后的调整代价都为O(logN);   </p><p>(2) 删除节点</p><p>由于删除节点X的时候,   是拿的节点X的左子树的最右节点A(或者节点X的右子树的最左节点B)来替换的节点X,   所以查询平衡性是否被破坏需要从节点A(或者节点B)的父节点开始网上查;   </p><h3 id="AVL树的实现"><a href="#AVL树的实现" class="headerlink" title="AVL树的实现"></a>AVL树的实现</h3><p>要求:   </p><p>(1) AVL树是为了实现关系型数据库的索引机制,   所以每一个AVL树的节点都需要存储一个键值对&lt;K,   V&gt;;   </p><p>(2) 由于在通过键查找某一个值的时候,   需要依靠键的比较来达到滑动查找的目的,   所以AVL树需要实现Key的可排序,   这是有序表的基础,   即搜索性;   </p><blockquote><p>突然想到的关于AVL树的几点:   </p><ol><li><p>AVL树整体来看,   从左到右,   节点的值依次增大;   所以小于头节点的最大节点在头节点的左子树的最右节点,   大于头节点的最小节点在头节点的右子树的最左节点,   这一点可以延伸到AVL树节点的删除功能;   </p></li><li><p>当想要通过键查找某一个数据(值)的时候,   如果使用线性结构,   不妨假设线性结构的键值对是从上往下排列的,   这样查询的代价就是O(N);   而如果使用AVL树,   虽然也是从上往下排列,   也是从上往下查询的,   但是AVL树通过不断二分的方式,   将查询代价缩减到了O(logN);   </p></li></ol></blockquote><p>(3) AVL树除了需要满足搜索性之外,   为了在特殊时刻不退变成棒状结构,   还需要满足平衡性,   这就使得每一个AVL树的节点都需要携带一个用于记录高度的变量;   </p><p>(4) 因为这是一棵树,   所以每一个节点肯定需要有左右孩子节点的指针;   </p><ol><li><p>AVL树的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLNode</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> K k;</span><br><span class="line">    <span class="keyword">public</span> V v;</span><br><span class="line">    <span class="keyword">public</span> AVLNode&lt;K, V&gt; l;</span><br><span class="line">    <span class="keyword">public</span> AVLNode&lt;K, V&gt; r;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLNode</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AVL树的右旋</p><p>对当前节点cur进行右旋,   也就是将当前节点的左孩子提上来,   自己下去;   </p><p>首先拿个指针指一下cur节点的左孩子,   然后修改指针,   可以直观地想象一下把cur节点指向左孩子的左指针变为左孩子指向cur节点的右指针,   当前在这之前,   需要把cur节点的左指针指向左孩子的右节点,   这也是拿个指针先抓取一下左孩子的原因;   然后就是调节cur节点和左孩子的高度了,   由于现在cur节点是左孩子的右孩子,   所以应该先调整cur节点,   然后再调整左孩子节点;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AVLNode&lt;K, V&gt; <span class="title">rightRotate</span><span class="params">(AVLNode&lt;K, V&gt; curNode)</span> </span>&#123;</span><br><span class="line">    AVLNode&lt;K, V&gt; left = curNode.l;</span><br><span class="line">    curNode.l = left.r;</span><br><span class="line">    left.r = curNode;</span><br><span class="line">    <span class="comment">// cur-(left, right)</span></span><br><span class="line">    <span class="comment">// left-(left, cur)</span></span><br><span class="line">    curNode.h = Math.max(curNode.l != <span class="keyword">null</span> ? curNode.l.h : <span class="number">0</span>, curNode.r != <span class="keyword">null</span> ? curNode.r.h : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    left.h = Math.max(left.l != <span class="keyword">null</span> ? left.l.h : <span class="number">0</span>, curNode.h) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AVL树的节点添加</p><p>肯定采用的是递归的添加方式;   </p><p>函数参数说明:   在以cur为头节点的子树上,   添加这个节点,   如果说cur为空节点,   则这个线的节点就应该添加到这个位置上,   所以应该将这个节点创建出来并返回给上一层的父节点进行接收;   添加完过后就要给出正确的高度,   但是这一步只是调整了高度,   而没有维持其平衡性,   所以使用maintain函数调整其平衡性;   maintain函数返回了一个值,   因为调整完平衡性之后这棵子树是有可能变头的,   所以要将新的头返回;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AVLNode&lt;K, V&gt; <span class="title">add</span><span class="params">(AVLNode&lt;K, V&gt; cur, K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AVLNode&lt;&gt;(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(cur.k) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur.l = add(cur.l, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur.r = add(cur.r, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    cur.h = Math.max(cur.l != <span class="keyword">null</span> ? cur.l.h : <span class="number">0</span>, cur.r != <span class="keyword">null</span> ? cur.r.h : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> maintain(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里的if和else的判断,   作用有两个,   一个是接收新的节点,   也就是下层创建好新的结点之后,   上层来接收一下;   另一个作用,   就是接收下层节点可能在接受了新的节点之后可能进行的换头工作所带来的新头;   </p><blockquote><p>在实现代码的时候需要考虑一个问题,   某一个子树在进行左旋右旋或者平衡性的调整过后,   是需要把这棵子树的新的头节点与上一层节点相连接的,   而这个工作只能交给上层节点来做,   所以这里要这么处理;   </p></blockquote></li><li><p>AVL树的节点删除</p><p>在以cur为头节点的子树上,   将key对应的节点删除;   </p><p>首先肯定是找到对应的节点X,   如果找到了,   则需要判断这个节点X的左右孩子,   没有孩子直接删,   有一个孩子则让这个孩子去代替它的位置,   如果有两个孩子,   则需要找到以这个节点X为头的子树的右孩子的最左节点,   让它去代替节点X,   让它的原始父节点向上开始做AVL树的调整;   </p><blockquote><p>不过在具体实现上,   左神的实现是先把要删除的节点X的右子树上要替换节点X的最左节点k删除(预先让一个指针指向它),   这一步已经完成了右子树的平衡性调整;   然后再拿节点k替换节点X;   这样操作,   最后就只需要从替换之后的节点X开始向上调整平衡性即可;   </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AVLNode&lt;K, V&gt; <span class="title">delete</span><span class="params">(AVLNode&lt;K, V&gt; cur, K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(cur.k) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur.l = delete(cur.l, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(cur.k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur.r = delete(cur.r, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.l == <span class="keyword">null</span> &amp;&amp; cur.r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.l != <span class="keyword">null</span> &amp;&amp; cur.r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = cur.l;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.l == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = cur.r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AVLNode&lt;K, V&gt; closerNode = cur.r;</span><br><span class="line">            <span class="keyword">while</span> (closerNode.l != <span class="keyword">null</span>) &#123;</span><br><span class="line">                closerNode = closerNode.l;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.r = delete(cur.r, closerNode.k);</span><br><span class="line">            closerNode.l = cur.l;</span><br><span class="line">            closerNode.r = cur.r;</span><br><span class="line">            cur = closerNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur.h = Math.max(cur.l != <span class="keyword">null</span> ? cur.l.h : <span class="number">0</span>, cur.r != <span class="keyword">null</span> ? cur.r.h : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maintain(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AVL树的平衡性调整</p><p>判断是否平衡,   如果不平衡,   则判断是左树高了还是右树高了;   确定子树之后,   判断破坏平衡类型,   然后进行对应的旋转即可;   </p><p>而特别注意那个等号,   是因为LL型和LR型共同出现时的解决方案是LL型的解决方案—右旋,   所以在两种类型同时出现的时候(即左左和左右的枝桠长度相同的时候),   采用右旋;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AVLNode&lt;K, V&gt; <span class="title">maintain</span><span class="params">(AVLNode&lt;K, V&gt; cur)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> leftHeight = cur.l != <span class="keyword">null</span> ? cur.l.h : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rightHeight = cur.r != <span class="keyword">null</span> ? cur.r.h : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (leftHeight &gt; rightHeight) &#123;</span><br><span class="line"><span class="keyword">int</span> leftLeftHeight = cur.l != <span class="keyword">null</span> &amp;&amp; cur.l.l != <span class="keyword">null</span> ? cur.l.l.h : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> leftRightHeight = cur.l != <span class="keyword">null</span> &amp;&amp; cur.l.r != <span class="keyword">null</span> ? cur.l.r.h : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (leftLeftHeight &gt;= leftRightHeight) &#123;</span><br><span class="line">cur = rightRotate(cur);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur.l = leftRotate(cur.l);</span><br><span class="line">cur = rightRotate(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> rightLeftHeight = cur.r != <span class="keyword">null</span> &amp;&amp; cur.r.l != <span class="keyword">null</span> ? cur.r.l.h : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rightRightHeight = cur.r != <span class="keyword">null</span> &amp;&amp; cur.r.r != <span class="keyword">null</span> ? cur.r.r.h : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (rightRightHeight &gt;= rightLeftHeight) &#123;</span><br><span class="line">cur = leftRotate(cur);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur.r = rightRotate(cur.r);</span><br><span class="line">cur = leftRotate(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有序表与其具体实现</p><p>有序表可以有很多种实现,   AVL树,   sb树,   跳表红黑树等等;   这些具体的实现只是为了调整有序表的平衡性,   没有调整平衡性功能的有序表—搜索二叉树所具有的功能,   AVL等具体的实现都会具有,   也就是说,   <strong><font color='red'>平衡性和搜索功能没有太大关系,   平衡性只是一个系统补丁,   用于修补搜索二叉树在某些情况之下的性能问题;</font></strong>   </p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有序表01&quot;&gt;&lt;a href=&quot;#有序表01&quot; class=&quot;headerlink&quot; title=&quot;有序表01&quot;&gt;&lt;/a&gt;有序表01&lt;/h1&gt;&lt;h2 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/21/tong-xin-yuan-li/xi-ti-02/"/>
    <id>http://example.com/2023/02/21/tong-xin-yuan-li/xi-ti-02/</id>
    <published>2023-02-21T15:08:08.583Z</published>
    <updated>2023-02-23T03:02:45.534Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ-ω-ρ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ-ω-ρ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ ω ρ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ ω ρ</h2><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h2><img src="D:/Program%20Files/Typora/img/image-20230221230838276.png" alt="image-20230221230838276" style="zoom:80%;" /><p>信息的周期为1ms,   载波的频率为2 * 10<sup>3</sup>Hz,   所以载波的周期为0.5ms,   信息的周期是载波的周期的两倍,   所以在画图的时候也要这个样子,   即一个周期之内,   载波要画两个周期;   </p><img src="D:/Program%20Files/Typora/img/image-20230221231120680.png" alt="image-20230221231120680" style="zoom: 67%;" /><img src="D:/Program%20Files/Typora/img/image-20230221231211902.png" alt="image-20230221231211902" style="zoom:80%;" /><blockquote><p>注意ASK的功率谱密度是有冲击的,   因为它的取值是0和1;   </p><p>而PSK的功率谱密度没有冲击,   因为它的取值是-1和1,   等概的情况下均值为0,   所以基带信号没有那个冲击;   </p></blockquote><p>(3) </p><img src="D:/Program%20Files/Typora/img/image-20230221231419306.png" alt="image-20230221231419306" style="zoom:80%;" /><blockquote><p>2ASK和2PSK的带宽是相同的,   都是基带信号的两倍;   </p></blockquote><h2 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h2><p>如果2FSK调制系统的符号速率为1200Baud,   数字信息为”1”和发”0”时的波形分别为s<sub>1</sub>(t)=cos(7200πt),   s<sub>2</sub>=cos(12000πt)<br>(1) 如果发送的数字信息为10011,   试画出2FSK信号的波形<br>(2) 如果发送数字信息是等概的,   试画出他的功率谱示意图<br>(3) 计算2FSK信号的近似带宽</p><p>注意</p><p>(1)</p><img src="D:/Program%20Files/Typora/img/image-20230221232020411.png" alt="image-20230221232020411"  /><blockquote><p>注意要对应上面那个关系;   </p></blockquote><p>(2) </p><p><img src="D:/Program%20Files/Typora/img/image-20230221232109657.png" alt="image-20230221232109657"></p><p>2FSK可以看作两个2ASK的合成,   所以它有4个波,   每个波都要有自己的冲击;   </p><p>(3) </p><img src="D:/Program%20Files/Typora/img/image-20230221232216239.png" alt="image-20230221232216239" style="zoom:80%;" /><blockquote><p>代公式即可;   B=|f<sub>2</sub>-f<sub>1</sub>|+2B;   </p></blockquote><h2 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h2><img src="D:/Program%20Files/Typora/img/image-20230222094908580.png" alt="image-20230222094908580" style="zoom:80%;" /><p>(1)</p><p>由于2PSK传递的是-1和1,   所以均值为0,   不过这好像没什么用…</p><img src="D:/Program%20Files/Typora/img/image-20230222095402190.png" alt="image-20230222095402190" style="zoom:80%;" /><p>因为是基带信号,   所以频谱利用率的公式右上写的是2;   用频谱利用率公式算出基带信号的带宽,   用R<sub>s</sub>和B<sub>N</sub>之间的关系算出B<sub>N</sub>,   然后画出基带信号的滚降波形即可;   </p><p>(2)</p><p>2PSK的信号就相当于把基带信号往两边搬移就行,   </p><img src="D:/Program%20Files/Typora/img/image-20230222095912956.png" alt="image-20230222095912956" style="zoom:80%;" /><p>(3) </p><img src="D:/Program%20Files/Typora/img/image-20230222095934886.png" alt="image-20230222095934886" style="zoom:80%;" /><p>其实因为画图需要带宽,   所以带宽应该提前算;   </p><h2 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h2><img src="D:/Program%20Files/Typora/img/image-20230222100038534.png" alt="image-20230222100038534" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222100020651.png" alt="image-20230222100020651" style="zoom:80%;" /><p>(1)</p><p>4进制符号PSK,   也就是这种东西能够表示4种波形,   所以需要两个比特;   在图中,   一个比特是A,   一个比特是B,   A和B经过各自的单双极性变换,   A’乘以cosω<sub>0</sub>t,   B’乘以-sinω<sub>0</sub>t,   然后两个相加得到一个表达式,   把A和B转化为A’和B’,   然后分别带到式子中去做正弦信号的三角函数式合并,   得到的相位就是A和B所对应的相位;   </p><img src="D:/Program%20Files/Typora/img/image-20230222101237978.png" alt="image-20230222101237978" style="zoom:80%;" /><p>(2)</p><p>求4PSK的频带利用率;   </p><blockquote><p>如果基带信号采用矩形波,   则其频带利用率为占空比D,   对应频带信号利用率为D/2;   </p><p>如果基带信号采用滚降波,   则其频带利用率为2/(1 + α),   对应频带利用率为1/(1+α);   </p></blockquote><p>由于采用的基带信号为不归零矩形波,   所以基带信号占空比为D=1,   </p><p>就可以推出对应的频带信号利用率R<sub>s</sub>/B=1/2,   B=2R<sub>s</sub>,   又因为是4PSK,   所以R<sub>b</sub>=R<sub>s</sub> log<sub>2</sub>M,   所以频带信号的信息频带利用率<br>$$<br>\frac{R_b}{B}=\frac{R_slog_24}{2R_s}=1bps/Hz<br>$$<br><img src="D:/Program%20Files/Typora/img/image-20230222103424384.png" alt="image-20230222103424384" style="zoom:80%;" /></p><h2 id="6-8"><a href="#6-8" class="headerlink" title="6.8"></a>6.8</h2><img src="D:/Program%20Files/Typora/img/image-20230222102416817.png" alt="image-20230222102416817" style="zoom:80%;" /><p>(1)<br>$$<br>\begin{align*}<br>&amp;上面这个函数需要两个正交基,   那么首先找到s_1(t)的正交基,   f’_1(t)=cos2\pi f_ct\\<br>&amp;然后再归一化,   f’_1(t)的能量为\frac{A^2}{2}T_b=\frac{T_b}{2}\\<br>&amp;所以f_1(t)=\frac{f’_1(t)}{\sqrt{E_b}}=\sqrt{\frac2{T_b}}cos2\pi f_ct<br>\end{align*}<br>$$<br>所以<img src="D:/Program%20Files/Typora/img/image-20230222142849268.png" alt="image-20230222142849268" style="zoom:80%;" /></p><p>然后就是他们的矢量图,   是一维的</p><img src="D:/Program%20Files/Typora/img/image-20230222143246351.png" alt="image-20230222143246351" style="zoom:80%;" /><p>(2)</p><p>欧氏距离就是两点的距离<img src="D:/Program%20Files/Typora/img/image-20230222143318699.png" alt="image-20230222143318699" style="zoom:80%;" />;   </p><p>(3)<br>$$<br>归一化相关系数ρ=\frac{s_1*s_2}{\sqrt{E_1}\sqrt{E_2}}=-1<br>$$<br><img src="D:/Program%20Files/Typora/img/image-20230222144003405.png" alt="image-20230222144003405" style="zoom:80%;" /></p><p>两个信号的能量都是E<sub>b</sub>,   平均比特能量就是两个能量加起来除以二;   </p><p>(4)</p><p>最佳接收机</p><img src="D:/Program%20Files/Typora/img/image-20230222144616376.png" alt="image-20230222144616376" style="zoom:80%;" /><p>由于||s<sub>1</sub>||=√E<sub>b</sub>,   所以收到的r<sub>1</sub>=√E<sub>b</sub>+n<sub>1</sub>,   所以r<sub>1</sub>~N(√E<sub>b</sub>,   N<sub>0</sub>/2),   那么它的似然函数就可以写出来了:   <img src="D:/Program%20Files/Typora/img/image-20230222144953716.png" alt="image-20230222144953716" style="zoom:80%;" /></p><blockquote><p>够成三维空间的要求,   互相之间积分为0,   自己之间积分为1;    </p><p>然后就是要记住典型信号的归一化标准正交基</p><img src="D:/Program%20Files/Typora/img/image-20230222105503848.png" alt="image-20230222105503848" style="zoom:80%;" /></blockquote><h2 id="6-10"><a href="#6-10" class="headerlink" title="6.10"></a>6.10</h2><img src="D:/Program%20Files/Typora/img/image-20230222145217539.png" alt="image-20230222145217539" style="zoom:80%;" /><p>(1)<br>$$<br>两个函数是正交的,   两个的能量都是\frac{T_b}{2}<br>$$<br>所以两个正交基就是</p><img src="D:/Program%20Files/Typora/img/image-20230222145622445.png" alt="image-20230222145622445" style="zoom: 67%;" /><p>星座图<img src="D:/Program%20Files/Typora/img/image-20230222145820502.png" alt="image-20230222145820502" style="zoom:80%;" />,   </p><img src="D:/Program%20Files/Typora/img/image-20230222150142135.png" alt="image-20230222150142135" style="zoom:80%;" /><p>(4)</p><img src="D:/Program%20Files/Typora/img/image-20230222150650369.png" alt="image-20230222150650369" style="zoom:80%;" /><p>(5)</p><img src="D:/Program%20Files/Typora/img/image-20230222150706865.png" alt="image-20230222150706865" style="zoom:80%;" /><blockquote><p>发s<sub>1</sub>但是接收到误码,   也就是说,   发s<sub>1</sub>,   但是它的信号与s<sub>2</sub>长得更像,   所以接收信号与s<sub>2</sub>的相关大于与s<sub>1</sub>的相关;   最后求n<sub>2</sub>-n<sub>1</sub>&gt;√E<sub>b</sub>,   因为这俩服从高斯分布,   所以他们相减的高斯分布可以算出来,   把他们相减的形式看成一个高斯变量,   相当于一个服从N(0,   N<sub>0</sub>)的高斯变量求Q函数的值,   所以就是后面那个结果;   </p><p>然后再用全概率公式进行加权;   </p></blockquote><h2 id="6-13"><a href="#6-13" class="headerlink" title="6.13"></a>6.13</h2><img src="D:/Program%20Files/Typora/img/image-20230222152048783.png" alt="image-20230222152048783" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222153612692.png" alt="image-20230222153612692" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222153637518.png" alt="image-20230222153637518" style="zoom:80%;" /><blockquote><p>首先进行施密特正交化,   化出标准正交基,   然后算出各个信号的坐标;   </p><p>因为是二维的,   所以匹配滤波器在抽样时刻的样值有两个,   因为发的是s<sub>1</sub>(t),   所以为(√2+n<sub>1</sub>,   n<sub>2</sub>);   </p><p>然后是第四问,   其实就是求(√2+n<sub>1</sub>,   n<sub>2</sub>)这两个的似然函数;   </p></blockquote><h2 id="6-14"><a href="#6-14" class="headerlink" title="6.14"></a>6.14</h2><img src="D:/Program%20Files/Typora/img/image-20230222160649435.png" alt="image-20230222160649435" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222161032494.png" alt="image-20230222161032494" style="zoom:80%;" /><blockquote><p>先通过Q函数算出E<sub>b</sub>,   E<sub>b</sub>R<sub>b</sub>就是功率,   而功率又等于那玩意儿,   就可以算出幅度了,   而算出的这是接收功率,   所以加上损耗就是传输功率;   </p></blockquote><h2 id="6-20"><a href="#6-20" class="headerlink" title="6.20"></a>6.20</h2><img src="D:/Program%20Files/Typora/img/image-20230222161422291.png" alt="image-20230222161422291" style="zoom:80%;" />$$\begin{align*}&P_b与信噪比之间存在对应关系P_b=Q(\sqrt{\frac{a^2}{x\sigma^2_n}}),   P_b算出来了,  信噪比就算出来了,\\\\<p>&amp;信噪比算出来了,幅度a就算出来了,   这是接收端的幅度,   拿发送端的幅度比上a\\</p><p>&amp;就得到在信道上的衰减,<br>\end{align*}<br>$$<br><img src="D:/Program%20Files/Typora/img/image-20230222164205193.png" alt="image-20230222164205193" style="zoom:80%;" /></p><blockquote><p>并且还要注意,   由于σ<sup>2</sup><sub>n</sub>=N<sub>0</sub>B<sub>BPF</sub>,   2FSK的σ<sup>2</sup><sub>n</sub>所对应的带通滤波器的带宽是一个峰的带宽,   所以它的带宽应该是2kHz,   而2ASK和2PSK的带宽都是4kHz;   </p><p>幅度的比值化成dB的时候要注意前面的系数不是10,   而是20;   </p></blockquote><h2 id="6-21"><a href="#6-21" class="headerlink" title="6.21"></a>6.21</h2><img src="D:/Program%20Files/Typora/img/image-20230222163525765.png" alt="image-20230222163525765" style="zoom:80%;" /><p>看到发送信号幅度A和信道衰减就可以猜测那是拿来与接收信号幅度进行比值的;   </p><p>通过A/a=60dB算出a,   然后通过R<sub>s</sub>算出带宽,   就可以算出噪声功率σ<sup>2</sup><sub>n</sub>,   全部带入误比特率公式中就可以算出误比特率;   </p><img src="D:/Program%20Files/Typora/img/image-20230222165323087.png" alt="image-20230222165323087" style="zoom:80%;" /><h2 id="6-22"><a href="#6-22" class="headerlink" title="6.22"></a>6.22</h2><img src="D:/Program%20Files/Typora/img/image-20230222165400234.png" alt="image-20230222165400234" style="zoom:80%;" /><p>这部分对应的公式就四个,   基带就是2/(1+α)和D,   频带就是1/(1+α)和D/2,   FSK比较特殊,   2/M;   </p><img src="D:/Program%20Files/Typora/img/image-20230222165645045.png" alt="image-20230222165645045" style="zoom:80%;" /><h2 id="6-24"><a href="#6-24" class="headerlink" title="6.24"></a>6.24</h2><img src="D:/Program%20Files/Typora/img/image-20230222182113503.png" alt="image-20230222182113503" style="zoom:80%;" /><p>(1)</p><p>d<sub>min</sub>就是两点之间的距离,   求得r,   </p><p>盲猜都猜得到E=r<sup>2</sup>,   算出E即可;   </p><p>(3)</p><p>注意格雷码的编写方式—在保证码距为1的前提下,   尾数按照0    1    1    0的方式循环编写,   首数按照00001111的方式循环编写;   </p><img src="D:/Program%20Files/Typora/img/image-20230222184538779.png" alt="image-20230222184538779" style="zoom:80%;" /><h2 id="6-29"><a href="#6-29" class="headerlink" title="6.29"></a>6.29</h2><p>设计一个数字通信系统,   如果信息速率为14400bit/s,   经过MQAM调制以2400Baud的符号速率在300~3300Hz的电话信道中进行传输<br>(1) 试确定进制数M,   载波频率f<sub>c</sub>,   滚降系数α<br>(2) 画出限带AWGN信道条件下的最佳频带传输系统框图<br>(3) 画出信道中所传QAM信号的功率谱密度示意图;   </p><p>(1) </p><img src="D:/Program%20Files/Typora/img/image-20230222190959705.png" alt="image-20230222190959705" style="zoom:80%;" /><blockquote><p>载波选在中间,   可用带宽直接减,   频带利用率直接拿那个公式算;   </p></blockquote><p>(2)</p><img src="D:/Program%20Files/Typora/img/image-20230222193038292.png" alt="image-20230222193038292" style="zoom:80%;" /><p>(3)</p><p>频谱图从哪里到哪里,   都是题干给定的,   而要算出滚降点频率,   可以先把频谱图搬移回基带,   然后通过α,   算出滚降点频率,   再移回频带的位置;   </p><h2 id="6-31"><a href="#6-31" class="headerlink" title="6.31"></a>6.31</h2><img src="D:/Program%20Files/Typora/img/image-20230222193425722.png" alt="image-20230222193425722" style="zoom:80%;" /><p>A律13折线就代表8bit,   抽样频率为8MHz,   可算得R<sub>b</sub>,   再通过频带利用率公式算出对应的量即可;   </p><p>QAM也是一样的;   </p><img src="D:/Program%20Files/Typora/img/image-20230222193859049.png" alt="image-20230222193859049" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222194402650.png" alt="image-20230222194402650" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222194433498.png" alt="image-20230222194433498" style="zoom:80%;" /><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>注意2ASK的空间维度为1,   QPSK的空间维度为2,   MFSK的空间维度为M,   MQAM的维度为2;   </p><p>求量化电平的时候不要忘记最后加上那一个区间的区间间隔一半!</p><p>注意误比特率一定是小于某个值,   所以E<sub>b</sub>/N<sub>0</sub>就大于某个值,   所以E<sub>b</sub>就大于某个值,   R<sub>b</sub>就小于某个值;   </p><p>二元PSK、DPSK及FSK三者的抗噪声性能从优到劣的排序为PSK优于DPSK优于FSK;   </p><p>可以采用非相干调制的有2ASK    2FSK;   </p><img src="D:/Program%20Files/Typora/img/image-20230222210538029.png" alt="image-20230222210538029" style="zoom:80%;" /><p>抗噪性能2PSK=4PSK &gt; 2ASK &gt; 4ASK=16QAM</p><img src="D:/Program%20Files/Typora/img/image-20230222210630298.png" alt="image-20230222210630298" style="zoom: 80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222213706753.png" alt="image-20230222213706753" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230223091551821.png" alt="image-20230223091551821" style="zoom:80%;" />$$注意如果幅度是A的话,   上式应该变为AT_sSa(\pi fT_s)$$<p>+++</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ-ω-ρ&quot;&gt;&lt;a href=&quot;#≈-≡-≠</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/21/gong-wu-yuan-kao-shi/shen-lun-da-ti-qia/"/>
    <id>http://example.com/2023/02/21/gong-wu-yuan-kao-shi/shen-lun-da-ti-qia/</id>
    <published>2023-02-21T08:22:31.080Z</published>
    <updated>2023-02-21T08:48:15.303Z</updated>
    
    <content type="html"><![CDATA[<p>村干部走访农户,   宣传倡导文明、健康、科学的生活、消费方式;   </p><p>动员有威望、有影响力的党员干部组织成立红白理事会,   制订办事标准;   </p><p>设置集中办事场所,   村民提出申请即可免费使用设备;   </p><p>减少村民办事费用;   </p><p>招揽返乡人才承包”喜庆堂”,   通过接待客人,   减免房租来平衡支出;   </p><p>办事记录制成照片贴于墙上;   </p><p>适应互联网+新业态;   转变思想方法,   用数据说话;   </p><p>提高多肉标准化要求;   减小产品区域差异;   统一规格与品相;   </p><p>提高花卉产业基础;   </p><p>引进专业人士对农户进行指导,   对农户进行多肉种植培训,   提高其在水土,   病虫防治灾害等方面的技术;   提升农户投资基础知识,   科学扩建多肉产业;   </p><p>提高大型或中型农户所占比例;   实施多肉企业化生产;   拓展多肉品种;   </p><p>政府出台相关政策,   增加对多肉的宣传力度;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;村干部走访农户,   宣传倡导文明、健康、科学的生活、消费方式;   &lt;/p&gt;
&lt;p&gt;动员有威望、有影响力的党员干部组织成立红白理事会,   制订办事标准;   &lt;/p&gt;
&lt;p&gt;设置集中办事场所,   村民提出申请即可免费使用设备;   &lt;/p&gt;
&lt;p&gt;减少村民办事费用; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/20/tong-xin-yuan-li/xi-ti-01/"/>
    <id>http://example.com/2023/02/20/tong-xin-yuan-li/xi-ti-01/</id>
    <published>2023-02-20T14:43:11.311Z</published>
    <updated>2023-02-21T15:18:02.282Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ</h2><p>通信原理以后有空再搞吧,   现在先把考试搞完~</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h2><img src="D:/Program%20Files/Typora/img/image-20230220224828213.png" alt="image-20230220224828213" style="zoom:80%;" /><p>低通<img src="D:/Program%20Files/Typora/img/image-20230220224853726.png" alt="image-20230220224853726" style="zoom:80%;" /></p><p>带通<img src="D:/Program%20Files/Typora/img/image-20230220224905589.png" alt="image-20230220224905589" style="zoom:80%;" /><br>$$<br>其中k=\frac{f_H}{B},   并且向下取整<br>$$<br>这是一个带通型信号,   但是不妨碍使用低通抽样定理去抽样;   </p><img src="D:/Program%20Files/Typora/img/image-20230220225338676.png" alt="image-20230220225338676" style="zoom:80%;" /><p>抽样在频谱上就是进行周期延拓,   所以就延拓呗;   </p><img src="D:/Program%20Files/Typora/img/image-20230220225449944.png" alt="image-20230220225449944" style="zoom:80%;" /><p>带通抽样也是一样的;   </p><h2 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h2><p>已知某信号m(t)的频谱为M(f),   将他通过传输函数为H<sub>1</sub>(f)的滤波器后再进行理想抽样,   其中,   M(f)和H<sub>1</sub>(f)如图,<br>(1)计算抽样频率<br>(2)若抽样频率f<sub>s</sub>=4f<sub>1</sub>,   画出抽样信号的频谱<br>(3)如何在接收端回复出信号m(t);   </p><p>(1)因为为低通信号,   带宽为f<sub>1</sub>,   所以抽样频率大于等于2f<sub>1</sub>;   </p><p>(2)抽样信号的频谱就是对基带信号进行周期延拓即可;   </p><p>(3)通过一个截止频率为f<sub>1</sub>的理想低通滤波器,   将抽样信号的高频分量滤掉,   再通过一个1/H<sub>1</sub>(f)的网络即可恢复;   </p><h2 id="4-10"><a href="#4-10" class="headerlink" title="4.10"></a>4.10</h2><img src="D:/Program%20Files/Typora/img/image-20230221194525355.png" alt="image-20230221194525355" style="zoom:80%;" /><p>(1) </p><img src="D:/Program%20Files/Typora/img/image-20230221191912811.png" alt="image-20230221191912811" style="zoom: 33%;" /><p>Δ=4096/2048=2mV,   I<sub>D</sub>=796/2 * Δ=398Δ;   </p><p>值大于0,   所以C<sub>1</sub>=1,   398Δ在段落6,   所以C<sub>2</sub>C<sub>3</sub>C<sub>4</sub>=101,   </p><p>C<sub>5</sub>C<sub>6</sub>C<sub>7</sub>C<sub>8</sub>=(398-256)/16=8=(1000)<sub>2</sub>;   </p><p>(2)量化电平I<sub>D</sub>=256+8 * 16 + 8=392Δ;   </p><p>量化误差e=398Δ-392Δ=6Δ=12mV;   </p><p>(3)把前面算出来的量化电平化为11位二进制码;   </p><h2 id="4-13"><a href="#4-13" class="headerlink" title="4.13"></a>4.13</h2><img src="D:/Program%20Files/Typora/img/image-20230220230211930.png" alt="image-20230220230211930" style="zoom:80%;" /><p>(1) 量化信噪比只与量化阶数有关</p><img src="D:/Program%20Files/Typora/img/image-20230220230402608.png" alt="image-20230220230402608" style="zoom:80%;" /><p>电平为-5~+5V,   量化间隔Δ=0.01V,   所以量化级数为10/0.01=1000;   所以量化信噪比为</p><img src="D:/Program%20Files/Typora/img/image-20230220231013082.png" alt="image-20230220231013082" style="zoom:80%;" /><p>(2) 首先应该画出那个表</p><img src="D:/Program%20Files/Typora/img/image-20230221191912811.png" alt="image-20230221191912811" style="zoom: 33%;" /><p>发现101位于段落6,   所以这一段的每个码都占16Δ,   并且这是双极性码,   所以应该<br>$$<br>\frac{16}{2*2048}=\frac{2^4}{2^{12}}=\frac1{2^8}=\frac1{256}<br>$$<br>量化电平256+14 * 16+8=488Δ;   </p><p>归一化值Δ=5/2048或者10/4096=0.00244V;   </p><p>故量化电平为</p><center>I<sub>D</sub>=1.19V</center><p>(3) Δ也算出来了,   拿电压除以Δ就得到了归一化Δ,   然后算他的编码,   通过阶数算出量化电平和量化误差;   </p><h2 id="4-18"><a href="#4-18" class="headerlink" title="4.18"></a>4.18</h2><img src="D:/Program%20Files/Typora/img/image-20230221201740333.png" alt="image-20230221201740333" style="zoom:80%;" /><p>(1) 低通采样定理,   14kHz;   </p><p>(2) 量化级数为8,   比特数/位数为log<sub>2</sub>8=3;   又因<br>$$<br>R_b=nf_sl<br>$$<br>所以R<sub>b</sub>=480kbit/s;   </p><blockquote><p>这里要注意,   量化级数和量化位数的关系! </p></blockquote><h2 id="4-19"><a href="#4-19" class="headerlink" title="4.19"></a>4.19</h2><img src="D:/Program%20Files/Typora/img/image-20230221202227290.png" alt="image-20230221202227290" style="zoom:80%;" /><p>(1)每路信号采用A律13折线进行编码,   意思就是使用8bit(8位)进行编码;   一个抽样周期就是一帧;   因为要复用10路,   并且有一个同步码,   所以每一帧要有11路时隙;   </p><img src="D:/Program%20Files/Typora/img/image-20230221202746838.png" alt="image-20230221202746838" style="zoom:80%;" /><p>因为帧长由抽样周期决定,   所以T<sub>s</sub>=1/f<sub>s</sub>=125us;   </p><p>路时隙T<sub>a</sub>=125us/11路;   位时隙T<sub>b</sub>=T<sub>a</sub>/8;   </p><p>(2) 11路,   每路8bit,   R<sub>b</sub>=88bit * 8000Hz=704000bit/s;   </p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h2><img src="D:/Program%20Files/Typora/img/image-20230221203452199.png" alt="image-20230221203452199" style="zoom: 80%;" /><h2 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h2><img src="D:/Program%20Files/Typora/img/image-20230221205755215.png" alt="image-20230221205755215" style="zoom:80%;" /><p>(1) 由于独立等概,   所以均值为0,   方差也可以算出来,   </p><img src="D:/Program%20Files/Typora/img/image-20230221210106241.png" alt="image-20230221210106241" style="zoom:80%;" /><blockquote><p>这里需要谨记|G<sub>T</sub>(f)|的式子;   </p><p>也需要记一记P<sub>s</sub>(f)</p></blockquote><p>由于T<sub>s</sub>没给,   所以就不代;   </p><img src="D:/Program%20Files/Typora/img/image-20230221210534162.png" alt="image-20230221210534162" style="zoom:80%;" /><p>(2) 一样的,   均值为0,   算出方差,   带入式子;   </p><p>(3) 因为第一过零点带宽等于符号周期的倒数等于符号速率<img src="D:/Program%20Files/Typora/img/image-20230221212049636.png" alt="image-20230221212049636" style="zoom:80%;" /></p><p>所以两个PAM信号的B都为10<sup>6</sup>Hz;   </p><p>(4) 由于R<sub>s</sub>=R<sub>b</sub>/log<sub>2</sub>M,   所以2PAM的带宽为6 * 10<sup>6</sup>Hz,   8PAM的带宽为2 * 10<sup>6</sup>Hz;   </p><blockquote><p>R<sub>s</sub>和R<sub>b</sub>这件的关系公式如果记不住的话,   可以想想T<sub>s</sub>和T<sub>b</sub>的关系,   传一个符号的时间肯定大于等于传一个比特的时间撒,   所以T<sub>s</sub>=T<sub>b</sub> * log<sub>2</sub>M;   信息速率R的公式就反过来就行了;   </p></blockquote><h2 id="5-9"><a href="#5-9" class="headerlink" title="5.9"></a>5.9</h2><img src="D:/Program%20Files/Typora/img/image-20230221213059005.png" alt="image-20230221213059005" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230221213110771.png" alt="image-20230221213110771" style="zoom:80%;" /><p><img src="D:/Program%20Files/Typora/img/image-20230221213041727.png" alt="image-20230221213041727"></p><p>(1) </p><img src="D:/Program%20Files/Typora/img/image-20230221213518583.png" alt="image-20230221213518583" style="zoom:80%;" /><p>(2) 对于匹配滤波器而言,   抽样时刻,   最大信号幅度</p><center>s<sub>0</sub>(t<sub>0</sub>)=kR(0)=kE</center><img src="D:/Program%20Files/Typora/img/image-20230221215436117.png" alt="image-20230221215436117" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230221215722242.png" alt="image-20230221215722242" style="zoom:80%;" /><blockquote><p>也就是说,   要先记住最大信号幅度的公式,   然后记住噪声的平均功率;   </p><p>先根据信号的波形计算信号的能量,   抽样时刻幅度值kE,   瞬时功率(幅度值平方),   然后计算噪声的平均功率,   最后计算输出信噪比;   </p></blockquote><p>然后就是问他服从什么分布,   高斯分布咯,   计算它的一维概率密度函数,   实际上就是求均值和方差,   带进去就可以了;   </p><p>(4) 先验等概,   求误比特率;   </p><img src="D:/Program%20Files/Typora/img/image-20230221220814782.png" alt="image-20230221220814782" style="zoom:80%;" /><blockquote><p>要熟记P<sub>b</sub> ! !</p></blockquote><h2 id="5-10"><a href="#5-10" class="headerlink" title="5.10"></a>5.10</h2><img src="D:/Program%20Files/Typora/img/image-20230221221109928.png" alt="image-20230221221109928" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230221221347330.png" alt="image-20230221221347330" style="zoom:80%;" /><p>平均比特能量,   查表,   Q函数为减函数,   算出即可;   </p><p>平均功率为E<sub>b</sub>/T<sub>b</sub>,   所以就是那个公式咯;   </p><h2 id="5-15"><a href="#5-15" class="headerlink" title="5.15"></a>5.15</h2><img src="D:/Program%20Files/Typora/img/image-20230221221816038.png" alt="image-20230221221816038" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230221222259297.png" alt="image-20230221222259297" style="zoom:80%;" /><blockquote><p>根据图获得滚降中心点频率B<sub>N</sub>,   而无码间干扰的最大速率为B<sub>N</sub>的两倍,   但这只是最大的,   还有不那么大的,   B<sub>N</sub>/k,   k为任意正整数都可以,   所以取1的时候有3000Baud,   取2的时候有1500Baud,   但是没有这个选项,   取3的时候1000Baud;   </p></blockquote><h2 id="5-18"><a href="#5-18" class="headerlink" title="5.18"></a>5.18</h2><img src="D:/Program%20Files/Typora/img/image-20230221223545626.png" alt="image-20230221223545626" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230221224405459.png" alt="image-20230221224405459" style="zoom:80%;" /><blockquote><p>一定谨记那个公式频带利用率的那个公式 ! ! !</p><p>然后就是传输速率R<sub>s</sub>=nlf<sub>s</sub>,   A律13折线,   所以这里的l指的是量化位数,   8;   </p></blockquote><h2 id="5-21"><a href="#5-21" class="headerlink" title="5.21"></a>5.21</h2><img src="D:/Program%20Files/Typora/img/image-20230221230224297.png" alt="image-20230221230224297" style="zoom:80%;" /><p>与上一题一样;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/19/tong-xin-yuan-li/tong-xin-yuan-li-di-6-zhang-01/"/>
    <id>http://example.com/2023/02/19/tong-xin-yuan-li/tong-xin-yuan-li-di-6-zhang-01/</id>
    <published>2023-02-19T01:31:16.350Z</published>
    <updated>2023-02-22T12:12:47.841Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ</h2><h1 id="通信原理第6章-01"><a href="#通信原理第6章-01" class="headerlink" title="通信原理第6章_01"></a>通信原理第6章_01</h1><h2 id="数字频带传输模型"><a href="#数字频带传输模型" class="headerlink" title="数字频带传输模型"></a>数字频带传输模型</h2><p>由于携带信息的信号的频率与在信道上传递信号的合适频率不相同,   甚至差别很大,   所以需要传输之前把要传输的信号调到一定的频率,   这在第三章对模拟信号就是这么干的,   而数字信号也一样;   </p><p>这一章的对象是数字基带信号去控制正弦型载波的某一个或者某几个参数,   得到的数字频带信号;   </p><p>用数字基带信号去控制载波的幅度,   得到的频带信号被称为幅移键控ASK<br>用数字基带信号去控制载波的频率,   得到的频带信号被称为频移键控FSK<br>用数字基带信号去控制载波的相位,   得到的频带信号被称为相移键控PSK<br>用数字基带信号去联合控制载波的幅度与相位,   得到的频带信号称幅度相位联合键控,   如PAM;   </p><p>对于数字频带调制的理解:   可以像第三章那样,   把数字信号的基带信号频域形式表示出来,   然后再进行频谱搬移;   也可以像第五章那样,   把0和1映射为不同的波形进行调制;   </p><p>M进制:   将k个二进制符号构造为一个M进制符号,   每一个M进制符号映射为M个波形的其中之一;   举例,   比如4个比特映射为一个十六进制数,   而十六进制数嘛,   就有十六种不同的情况,   那么这十六种不同的情况就对应着十六种不同的波形,   在传递的时候,   只需要发送那4个比特对应的十六进制数对应的波形即可;   而如果传递的符号为M进制的,   M通常为2的次幂,   所以M=2<sup>k</sup>,   而对应的</p><center>T<sub>s</sub>=kT<sub>b</sub></center><p>T<sub>b</sub>为传递一个比特需要的时间,   T<sub>s</sub>为传递一个符号所需要的时间,   一个M进制符号对应着k个比特,   所以为k倍的关系;   </p><p>接收机的作用就是接收0≤t≤T<sub>s</sub>间的信号,   判断这个信号到底是M个波形中的哪一个;   </p><h2 id="二进制数字信号正弦载波调制"><a href="#二进制数字信号正弦载波调制" class="headerlink" title="二进制数字信号正弦载波调制"></a>二进制数字信号正弦载波调制</h2><h3 id="调制信号的时域表示"><a href="#调制信号的时域表示" class="headerlink" title="调制信号的时域表示"></a>调制信号的时域表示</h3><ol><li><p>2ASK<br>$$<br>s_{2ASK}(t)=b(t)c(t)=[\sum^\infty_{n=-\infty}a_ng_T(t-nT_b)] * A_ccos2\pi f_ct<br>$$</p><p>其中a<sub>n</sub>为0或者1;   </p><p>调制之后的波形<br>$$<br>S_{2ASK}(t)=\left{ \begin{array}{rcl}<br>&amp;s_1(t)=A_cg_T(t)cos2\pi f_ct&amp;,   &amp;1\<br>&amp;0&amp;,   &amp;0\<br>\end{array}\right.<br>$$</p><img src="D:/Program%20Files/Typora/img/image-20230220203920737.png" alt="image-20230220203920737" style="zoom:80%;" /><p>2ASK使用载波的幅度来存储信号的信息;   </p><p>信号产生:   使用开关电路,   发1的时候就打开电路,   发0的时候就断开电路;   </p><img src="D:/Program%20Files/Typora/img/image-20230220205346718.png" alt="image-20230220205346718" style="zoom:80%;" /></li><li><p>2PSK</p><img src="D:/Program%20Files/Typora/img/image-20230220204142238.png" alt="image-20230220204142238" style="zoom:80%;" /><p>2PSK使用载波的0和π相位来存储信号的信息;   </p><p>2PSK的产生:   发1的时候照常,   发0的时候反转相位即可;   </p></li><li><p>2FSK</p><img src="D:/Program%20Files/Typora/img/image-20230220204654243.png" alt="image-20230220204654243" style="zoom:80%;" /><p>2FSK使用不同频率的载波来存储信号的信息;   </p><p>2FSK可以看作两列2ASK的叠加,   也就是两列2ASK分别取不同频率的载波,   一列存储0信号(求反之后乘载波),   一列存储1信号,   再把两列相加即可;   </p><p>2FSK的产生:   发1的时候接一种载波,   发0的时候接另一种载波;   或者直接使用VCO进行频偏;   </p></li></ol><h3 id="二进制数字调制信号的功率谱及带宽"><a href="#二进制数字调制信号的功率谱及带宽" class="headerlink" title="二进制数字调制信号的功率谱及带宽"></a>二进制数字调制信号的功率谱及带宽</h3><p>(1) 2ASK<br>        由于乘了一个正弦波,   所以在频谱上把基带信号向两边搬移,   并且分为了两部分,   所以2ASK的功率谱为<br>$$<br>P_{2ASK}(f)=\frac{A^2_c}{4}[P_b(f+f_c)+P_b(f-f_c)]<br>$$<br>P<sub>b</sub>(f)为基带信号的功率谱,   2ASK带宽为基带信号带宽的两倍;   </p><p>如果基带信号为单极性不归零信号,   码元间隔T<sub>b</sub>;   </p><img src="D:/Program%20Files/Typora/img/image-20230220211935258.png" alt="image-20230220211935258" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230220212020667.png" alt="image-20230220212020667" style="zoom:80%;" /><blockquote><p>因为带宽只算一半,   所以2ASK的带宽为基带信号的第一过零点带宽的两倍;   </p></blockquote><p>如果基带信号为滚降型信号,   则</p><img src="D:/Program%20Files/Typora/img/image-20230220212309874.png" alt="image-20230220212309874" style="zoom:80%;" /><p>(2) 2PSK<br>        与2ASK相似,   不过由于2PSK发的是-1和1,   是等概的,   所以在载波处没有冲击;   </p><img src="D:/Program%20Files/Typora/img/image-20230220212756901.png" alt="image-20230220212756901" style="zoom:80%;" /><p>(3) 2FSK<br>        由于2FSK可以看作是两列2ASK的和,   所以2FSK的频谱也可以看作是两列2ASK的叠加</p><img src="D:/Program%20Files/Typora/img/image-20230220213144090.png" alt="image-20230220213144090" style="zoom:80%;" /><h3 id="多进制数字调制信号的功率谱及带宽"><a href="#多进制数字调制信号的功率谱及带宽" class="headerlink" title="多进制数字调制信号的功率谱及带宽"></a>多进制数字调制信号的功率谱及带宽</h3><p>(1) MASK信号<br>        <img src="D:/Program%20Files/Typora/img/image-20230220214519859.png" alt="image-20230220214519859" style="zoom:80%;" /><br>        <img src="D:/Program%20Files/Typora/img/image-20230220214543891.png" alt="image-20230220214543891" style="zoom:80%;" /><br>        MASK的带宽为其基带信号的两倍,   但是这个基带信号为多进制信号;<br>$$<br>\begin{align*}<br>&amp;2ASK&amp;T_s=T_b&amp;&amp;B_{基}=\frac1{T_s}&amp;&amp;B_{2ASK}=2B_{基}=\frac2{T_s}=\frac2{T_b}\\<br>&amp;4ASK&amp;T_s=2T_b&amp;&amp;B_{基}=\frac1{T_s}&amp;&amp;B_{4ASK}=2B_{基}=\frac2{T_s}=\frac1{T_b}<br>\end{align*}<br>$$<br><img src="D:/Program%20Files/Typora/img/image-20230220215647861.png" alt="image-20230220215647861" style="zoom:80%;" /></p><p>(2) QPSK<br>        使用构成4个直角的相位可以从0相位开始,   也可以从45度相位开始;<br>        由于MPSK可以看作两列正交的多电平MASK叠加,   所以在相同的基带信号下,   其带宽和频带利用率与MASK的都是相同的;   </p><p>相关的习题只需要记住两个公式<br>$$<br>\begin{align*}<br>&amp;基带<br>\frac{R_s}B=\left{ \begin{array}{rcl}<br>&amp;D,   &amp;矩形波\<br>&amp;\frac2{1+\alpha},   &amp;滚降\<br>\end{array}\right.<br>\\<br>&amp;频带<br>\frac{R_s}B=\left{ \begin{array}{rcl}<br>&amp;\frac D2,   &amp;矩形波\<br>&amp;\frac1{1+\alpha},   &amp;滚降\<br>\end{array}\right.<br>\\<br>&amp;\frac{R_b}B=\frac{R_s}Blog_2M<br>\end{align*}<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/18/sui-bi/wu-bian-de-ling-gan-01/"/>
    <id>http://example.com/2023/02/18/sui-bi/wu-bian-de-ling-gan-01/</id>
    <published>2023-02-18T13:05:39.470Z</published>
    <updated>2023-02-18T13:36:58.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动力之反向思考"><a href="#动力之反向思考" class="headerlink" title="动力之反向思考"></a>动力之反向思考</h1><p>一直以来我都在思考如何减小诱惑,   如何提高接触诱惑的门槛,   以让自己能够持续努力,   但是今天突然想到,   如果对努力的门槛进行修改,   也可以影响坚持;   </p><p>比如突然想到,   如果将学习用品放置在很远的地方,   实际上相当于提高了学习的门槛,   比如人在楼上,   但是要下楼去才能学习;   而降低学习的门槛,   越想越合理,   联系宁老师的进步本和随时学习;   </p><p>不过我也有专门的降低学习门槛的方法,   2023/02/18目前为止还是挺有用的,   把”第一个最简单的任务设为翻开书本”与奖励相结合,   也就是完成这个根本无需任何成本的任务就可以领取奖励,   随后的奖励随任务难度的增加而增加;   </p><p>“无消耗的简单任务与奖励挂钩”这一点虽小,   但是很重要;   </p><p>这种方式来源于赛尔号,   登陆游戏就可以领取每日任务的奖励,   从而促使玩家完成每日任务,   而每日任务的完成度与游戏时长挂钩;   赛尔号的策划们属实是把人性的弱点拿捏了,   不过能为我所用,   就是好事;   </p><h1 id="奇怪的南山"><a href="#奇怪的南山" class="headerlink" title="奇怪的南山"></a>奇怪的南山</h1><p>大四下回到邮电大学之后,   本人的嗓音条件变好了,   而且没有太多可追溯的原因;   </p><p>一开始我也没有太注意,   直到想到大四上一到南山上,   嗓音条件也莫名其妙地变好了,   当时归功于暑假的咽音练习,   不过之后条件又变差了;   </p><p>不知道是与海拔相关还是与海拔的变化相关,   还是说南山上空气比较好? 不过大四上结束之后回到家里,   突然咽音就轻松上C5了,   然后又差了回去,   当时归因于新冠;   </p><p>总不能是吃了几块牛肉干的原因吧🤣</p><p>真是奇怪~ 不过嗓音条件变好就是好事,   起码我很高兴;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动力之反向思考&quot;&gt;&lt;a href=&quot;#动力之反向思考&quot; class=&quot;headerlink&quot; title=&quot;动力之反向思考&quot;&gt;&lt;/a&gt;动力之反向思考&lt;/h1&gt;&lt;p&gt;一直以来我都在思考如何减小诱惑,   如何提高接触诱惑的门槛,   以让自己能够持续努力,   但是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/18/bi-ye-lun-wen/deng-yu-tong-di-si-zhou-zhou-bao/"/>
    <id>http://example.com/2023/02/18/bi-ye-lun-wen/deng-yu-tong-di-si-zhou-zhou-bao/</id>
    <published>2023-02-18T02:09:59.269Z</published>
    <updated>2023-02-18T06:11:03.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四次周报"><a href="#第四次周报" class="headerlink" title="第四次周报"></a>第四次周报</h1><ol><li><p>学习AdaBoost分类方法</p><p>多个弱分类器通过加权的方式形成一个强分类器;   试着用数学方式表示AdaBoost,   类似这种</p><img src="D:/Program%20Files/Typora/img/image-20230218135223562.png" alt="image-20230218135223562" style="zoom: 80%;" /></li><li><p>学习PCA算法</p><p>一个降维的方法,   用于特征脸算法,   线性代数味道较重;   同时理解了降维的概念,   PCA应是一种线性降维的算法;   </p></li><li><p>学习特征脸算法</p><p>核心就是PCA,   这个无需多谈;   </p></li><li><p>分析OpenCV中对EigenFace算法的实现</p><img src="D:/Program%20Files/Typora/img/image-20230218135514382.png" alt="image-20230218135514382" style="zoom:80%;" /><p>虽然我不会c++,   但是源码分析并不是太吃语言特性,   而且还有api嘛;   </p><p>除开一大段判别代码后,   EigenFace的训练方法的核心代码还是在于PCA,   不过在投影到PCA子空间的时候利用的是LDA;   </p><p>所以要搞懂EigenFace,   还需要看看PCA和LDA的实现;   </p><img src="D:/Program%20Files/Typora/img/image-20230218140229274.png" alt="image-20230218140229274" style="zoom:80%;" /><p>在预测函数中,   使用余弦距离公式算出距离之后,   其判断是在收集器中进行的,   所以还需要研究一下收集器的实现,   其实都可以猜到了eigen_face.cpp的构造函数(不知道是不是这么叫)中的阈值threshold是在收集器中使用的;   </p></li><li><p>准备公考中,   还是没太多时间做毕设🤷‍♂️;   </p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四次周报&quot;&gt;&lt;a href=&quot;#第四次周报&quot; class=&quot;headerlink&quot; title=&quot;第四次周报&quot;&gt;&lt;/a&gt;第四次周报&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;学习AdaBoost分类方法&lt;/p&gt;
&lt;p&gt;多个弱分类器通过加权的方式形成一个强分类器;   试着</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/17/bi-ye-lun-wen/f012-adaboost-deng/"/>
    <id>http://example.com/2023/02/17/bi-ye-lun-wen/f012-adaboost-deng/</id>
    <published>2023-02-17T13:42:11.227Z</published>
    <updated>2023-02-28T13:16:58.415Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ</h2><h1 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h1><p>算法思想:   为每一个样本数据分配初始值,   在每一步迭代过程中,   通过新加入的基本分类器的分类错误率来逐步调整权值,   当达到预先指定的迭代次数或者预测错误概率足够小的时候,   便可以将迭代过程中的基本分类器进行组合,   得到一个强分类器;<br>$$<br>\begin{align*}<br>&amp;算法输入:   \\<br>&amp;训练集(x_1,   y_2),   …(x_N,   y_N),   x_i为训练样本,   y_i为训练标签,   取值为{1,   -1},    \\<br>&amp;i=1,   2,   …,   N,  \\<br>&amp;弱分类器h_m,   m=1,   2,   …,   M\\</p><p>&amp;算法输出:   强分类器H\\\<br>&amp;算法流程:   \\<br>&amp;(1)初始化N个训练样本的权值分布;   \<br>&amp;P_0={p_{0_1},   p_{0_2},   …,   p_{0_N}}={\frac1N,   \frac1N,   …,   \frac1N}\\</p><p>&amp;(2) 进行K次迭代,   选取按照当前权值,   分类错误率最低的弱分类器h作为第k个基本分类器H_k,   \<br>&amp;并计算H_k的分类错误率e_k:   \<br>&amp;e_k=\sum^N_{i=1}p_{k-1}I(H_k(x_i)≠y_i),   \\<br>&amp;I(H_k(x_i)≠y_i)=\left{ \begin{array}{rcl}<br>&amp;1&amp;,   &amp;H_k(x_i)≠y_i\<br>&amp;0&amp;,   &amp;H_k(x_i)=y_i\<br>\end{array}\right.,   \\</p><p>&amp;利用e_k计算当前弱分类器H_k在最终强分类器中的权重\beta_k\<br>&amp;\beta_k=\frac12ln(\frac{1-e_k}{e_k})\\<br>&amp;更新训练样本的权值分布P_k(式子太大不给了)\\\</p><p>&amp;(3)按照各个 弱分类器的权重组合弱分类器,   得到强分类器\<br>&amp;H=sign(\sum^K_{i=1}\beta_iH_i)<br>\end{align*}<br>$$</p><blockquote><p>那个含不等于的式子的意思是,   如果把x<sub>i</sub>传入分类器得到的结果不为y<sub>i</sub>,   即分类错误,   则整体式子为1,   如果分类正确则输出0;   </p><p>e<sub>k</sub>那个式子就代表如果分类错误,   则统计,   没错则不统计,   实际上就是在统计分类错误率;   </p><p>对于最后的那个式子,   符号函数对于&gt;0的自变量取1,   &lt;0的自变量取-1;   也就是说,   把一个数据传进每一个弱分类器中,   判断结果乘以对应的权重,   各个结果之和若大于0,   则分到一类,   若小于零,   则分到另一类;   </p></blockquote><h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h1><p>降维的概念:   描述一个三维空间,   需要使用三个量,   用着三个量描述某个物体在空间中的位置,   而对于高维空间,   虽然三微生物无法想象,   但是可以同样使用不断增加维度的方式对其进行描述;   </p><p>在机器学习与数据挖掘等领域中,   数据模型算法的复杂度常常与数据维度挂钩;   而在图像处理方面的数据维度,   我认为可以简单理解为”特征”,   比如人脸图像,   要想描述一张人脸,   可能需要对人脸的五官进行描述,   比如眼睛的长度,   鼻孔的大小,   嘴唇的宽度等等;   每个特征可以用一个数值来代替,   这些数值组合在一起构成一个特征向量,   来描述某张人脸;   当想要检测这张人脸是否为彭于晏时,   只需比对这些特征即可;   </p><p>想要对图像描述的更精细,   就需要更多的特征,   而由于算法复杂度与数据维度挂钩,   所以应该采用某种方法将大量的特征映射为少量的特征,   也就是降维,   在数学上为从”多分量向量”映射为”少分量向量”的过程;   </p><p>在降维过程中,   使用者需要的特征信息被保留,   而丢弃掉那些对使用者目的无关的信息;   </p><blockquote><p>而PCA的步骤:   </p><p>对每一个数据集的每一维数据进行相对于均值的归一化,   得到归一化矩阵,   然后求其协方差矩阵<strong>C</strong>,   获得<strong>C</strong>的特征值与特征向量,   选取最大的k个特征值对应的特征向量,   组成特征向量矩阵<strong>P</strong>,   <strong>P</strong>就是降维之后的矩阵;   </p></blockquote><h1 id="特征脸法"><a href="#特征脸法" class="headerlink" title="特征脸法"></a>特征脸法</h1><p>步骤</p><p>训练:   </p><ol><li><p>对图片进行预处理</p><p>灰度化,   统一尺寸,   光照归一化;   </p></li><li><p>将图片转化为一个向量</p><p>将图片矩阵的每一行连在一起,   并转化为列向量;   </p></li><li><p>零均值化</p><p>对每一个维度求平均,   平均值组合到一起形成平均脸向量,   每个人脸向量减去该平均脸向量,   从而完成零均值化处理;   </p></li><li><p>PCA</p><p>算出归一化矩阵的协方差矩阵的特征值与特征向量,   特征向量的维度和原始图像的维度一致,   故这些特征向量就是特征脸;   </p><blockquote><p>设经过零均值化的矩阵为<strong>X</strong>,   <strong>X</strong>为m行n列,   m为每一张图片的维度数,   n为训练的图片数,   由于图片数远远小于维度数,   所以可以把原本为m行m列的协方差矩阵<strong>C</strong></p><center>C = X X<sup>T</sup></center><p>变为<strong>C’</strong></p><center>C'= X<sup>T</sup>X</center><p>这样,   协方差矩阵的规模就变为了n行n列,   从而减少运算量;   </p></blockquote><p>对于所获得的特征脸向量,   每一张图片都可以是这些特征脸向量的线性组合,   从而每一张图片都可以用一个向量**θ<sup>T</sup>**表示</p><center>θ<sup>T</sup> = [θ<sub>1</sub>,   θ<sub>2</sub>,...,   θ<sub>n</sub>]</center></li><li><p>对比</p><p>通过特征脸向量将输入图片向量化,   得到一个特征向量,   将该特征向量与已有的特征向量通过距离度量的方法进行对比,   从而判断是否为同一个人;   </p></li></ol><p>EigenFace代码实现(opencv_contrib-3.4\modules\face\src\eigen_faces.cpp)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;precomp.hpp&quot;</span> <span class="comment">// 包含预编译头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/face.hpp&gt;</span> <span class="comment">// 包含OpenCV的人脸识别头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;face_utils.hpp&quot;</span> <span class="comment">// 包含人脸识别的工具函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span> <span class="comment">// 包含set容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span> <span class="comment">// 包含数值限制头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> <span class="comment">// 包含输入输出流头文件</span></span></span><br><span class="line"><span class="keyword">namespace</span> cv <span class="comment">// 定义命名空间cv</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> face <span class="comment">// 定义命名空间face</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Turk, M., and Pentland, A. &quot;Eigenfaces for recognition.&quot;. Journal of</span></span><br><span class="line"><span class="comment">// Cognitive Neuroscience 3 (1991), 71–86.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eigenfaces</span> :</span> <span class="keyword">public</span> EigenFaceRecognizer <span class="comment">// 定义Eigenfaces类，继承自EigenFaceRecognizer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initializes an empty Eigenfaces model.</span></span><br><span class="line">    <span class="built_in">Eigenfaces</span>(<span class="keyword">int</span> num_components = <span class="number">0</span>, <span class="keyword">double</span> threshold = DBL_MAX) <span class="comment">// 构造函数，初始化空的Eigenfaces模型，参数num_components表示特征数量，threshold表示阈值</span></span><br><span class="line">        <span class="comment">//: BasicFaceRecognizerImpl(num_components, threshold)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _num_components = num_components; <span class="comment">// 将参数num_components赋值给_num_components</span></span><br><span class="line">        _threshold = threshold; <span class="comment">// 将参数threshold赋值给_threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Computes an Eigenfaces model with images in src and corresponding labels</span></span><br><span class="line">    <span class="comment">// in labels.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">train</span><span class="params">(InputArrayOfArrays src, InputArray labels)</span> CV_OVERRIDE</span>; <span class="comment">// 训练函数，参数src表示输入图像，labels表示标签</span></span><br><span class="line">    <span class="comment">// Send all predict results to caller side for custom result handling</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">predict</span><span class="params">(InputArray src, Ptr&lt;PredictCollector&gt; collector)</span> <span class="keyword">const</span> CV_OVERRIDE</span>; <span class="comment">// 预测函数，参数src表示输入图像，collector表示收集器</span></span><br><span class="line">    <span class="function">String <span class="title">getDefaultName</span><span class="params">()</span> <span class="keyword">const</span> CV_OVERRIDE <span class="comment">// 获取默认名称</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;opencv_eigenfaces&quot;</span>; <span class="comment">// 返回opencv_eigenfaces</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Eigenfaces</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eigenfaces::train</span><span class="params">(InputArrayOfArrays _src, InputArray _local_labels)</span> </span>&#123; <span class="comment">// 训练函数</span></span><br><span class="line">    <span class="keyword">if</span>(_src.<span class="built_in">total</span>() == <span class="number">0</span>) &#123; <span class="comment">// 如果输入图像为空</span></span><br><span class="line">        String error_message = format(<span class="string">&quot;Empty training data was given. You&#x27;ll need more than one sample to learn a model.&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="built_in">CV_Error</span>(Error::StsBadArg, error_message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(_local_labels.<span class="built_in">getMat</span>().<span class="built_in">type</span>() != CV_32SC1) &#123; <span class="comment">// 如果标签类型不是CV_32SC1</span></span><br><span class="line">        String error_message = format(<span class="string">&quot;Labels must be given as integer (CV_32SC1). Expected %!d(MISSING), but was %!d(MISSING).&quot;</span>, CV_32SC1, _local_labels.<span class="built_in">type</span>()); <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="built_in">CV_Error</span>(Error::StsBadArg, error_message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// make sure data has correct size</span></span><br><span class="line">    <span class="keyword">if</span>(_src.<span class="built_in">total</span>() &gt; <span class="number">1</span>) &#123; <span class="comment">// 如果输入图像数量大于1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(_src.<span class="built_in">total</span>()); i++) &#123; <span class="comment">// 遍历每一张图像</span></span><br><span class="line">            <span class="keyword">if</span>(_src.<span class="built_in">getMat</span>(i<span class="number">-1</span>).<span class="built_in">total</span>() != _src.<span class="built_in">getMat</span>(i).<span class="built_in">total</span>()) &#123; <span class="comment">// 如果图像大小不一致</span></span><br><span class="line">                String error_message = format(<span class="string">&quot;In the Eigenfaces method all input samples (training images) must be of equal size! Expected %!d(MISSING) pixels, but was %!d(MISSING) pixels.&quot;</span>, _src.<span class="built_in">getMat</span>(i<span class="number">-1</span>).<span class="built_in">total</span>(), _src.<span class="built_in">getMat</span>(i).<span class="built_in">total</span>()); <span class="comment">// 抛出异常</span></span><br><span class="line">                <span class="built_in">CV_Error</span>(Error::StsUnsupportedFormat, error_message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get labels</span></span><br><span class="line">    Mat labels = _local_labels.<span class="built_in">getMat</span>(); <span class="comment">// 获取标签</span></span><br><span class="line">    <span class="comment">// observations in row</span></span><br><span class="line">    Mat data = <span class="built_in">asRowMatrix</span>(_src, CV_64FC1); <span class="comment">// 将输入图像转换为行矩阵</span></span><br><span class="line">    <span class="comment">// number of samples</span></span><br><span class="line">   <span class="keyword">int</span> n = data.rows; <span class="comment">// 获取样本数量</span></span><br><span class="line">    <span class="comment">// assert there are as much samples as labels</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(labels.<span class="built_in">total</span>()) != n) &#123; <span class="comment">// 如果样本数量和标签数量不一致</span></span><br><span class="line">        String error_message = format(<span class="string">&quot;The number of samples (src) must equal the number of labels (labels)! len(src)=%!d(MISSING), len(labels)=%!d(MISSING).&quot;</span>, n, labels.<span class="built_in">total</span>()); <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="built_in">CV_Error</span>(Error::StsBadArg, error_message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear existing model data</span></span><br><span class="line">    _labels.<span class="built_in">release</span>(); <span class="comment">// 释放_labels</span></span><br><span class="line">    _projections.<span class="built_in">clear</span>(); <span class="comment">// 清空_projections</span></span><br><span class="line">    <span class="comment">// clip number of components to be valid</span></span><br><span class="line">    <span class="keyword">if</span>((_num_components &lt;= <span class="number">0</span>) || (_num_components &gt; n)) <span class="comment">// 如果特征数量不合法</span></span><br><span class="line">        _num_components = n; <span class="comment">// 将特征数量设置为样本数量</span></span><br><span class="line">    <span class="comment">// perform the PCA</span></span><br><span class="line">    <span class="comment">// 输入数据为行向量的形式</span></span><br><span class="line">    <span class="function">PCA <span class="title">pca</span><span class="params">(data, Mat(), PCA::DATA_AS_ROW, _num_components)</span></span>; <span class="comment">// 调用PCA算法</span></span><br><span class="line">    <span class="comment">// copy the PCA results</span></span><br><span class="line">    _mean = pca.mean.<span class="built_in">reshape</span>(<span class="number">1</span>,<span class="number">1</span>); <span class="comment">// 将PCA的均值赋值给_mean</span></span><br><span class="line">    _eigenvalues = pca.eigenvalues.<span class="built_in">clone</span>(); <span class="comment">// 将PCA的特征值赋值给_eigenvalues</span></span><br><span class="line">    <span class="built_in">transpose</span>(pca.eigenvectors, _eigenvectors); <span class="comment">// 将PCA的特征向量赋值给_eigenvectors</span></span><br><span class="line">    <span class="comment">// store labels for prediction</span></span><br><span class="line">    _labels = labels.<span class="built_in">clone</span>(); <span class="comment">// 将标签赋值给_labels</span></span><br><span class="line">    <span class="comment">// save projections</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sampleIdx = <span class="number">0</span>; sampleIdx &lt; data.rows; sampleIdx++) &#123; <span class="comment">// 遍历每一个样本</span></span><br><span class="line">        Mat p = LDA::<span class="built_in">subspaceProject</span>(_eigenvectors, _mean, data.<span class="built_in">row</span>(sampleIdx)); <span class="comment">// 计算投影</span></span><br><span class="line">        _projections.<span class="built_in">push_back</span>(p); <span class="comment">// 将投影结果保存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预测函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eigenfaces::predict</span><span class="params">(InputArray _src, Ptr &lt;PredictCollector&gt; collector)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从输入数组中获取数据</span></span><br><span class="line">    Mat src = _src.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="comment">// 确保用户传入的数据正确</span></span><br><span class="line">    <span class="keyword">if</span> (_projections.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        String error_message = <span class="string">&quot;This Eigenfaces model is not computed yet. Did you call Eigenfaces::train?&quot;</span>; </span><br><span class="line">        <span class="built_in">CV_Error</span>(Error::StsError, error_message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_eigenvectors.rows != <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(src.<span class="built_in">total</span>())) &#123;</span><br><span class="line">        <span class="comment">// 检查数据对齐</span></span><br><span class="line">        String error_message = format(</span><br><span class="line">                <span class="string">&quot;Wrong input image size. Reason: Training and Test images must be of equal size! Expected an image with %!d(MISSING) elements, but got %!d(MISSING).&quot;</span>,</span><br><span class="line">                _eigenvectors.rows, src.<span class="built_in">total</span>());</span><br><span class="line">        <span class="built_in">CV_Error</span>(Error::StsBadArg, error_message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据投影到PCA子空间</span></span><br><span class="line">    Mat q = LDA::<span class="built_in">subspaceProject</span>(_eigenvectors, _mean, src.<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    collector-&gt;<span class="built_in">init</span>(_projections.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 遍历投影数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> sampleIdx = <span class="number">0</span>; sampleIdx &lt; _projections.<span class="built_in">size</span>(); sampleIdx++) &#123;</span><br><span class="line">        <span class="comment">// 计算投影数据之间的距离</span></span><br><span class="line">        <span class="keyword">double</span> dist = <span class="built_in">norm</span>(_projections[sampleIdx], q, NORM_L2);</span><br><span class="line">        <span class="comment">// 获取标签</span></span><br><span class="line">        <span class="keyword">int</span> label = _labels.at&lt;<span class="keyword">int</span>&gt;((<span class="keyword">int</span>) sampleIdx);</span><br><span class="line">        <span class="comment">// 如果找到了满足条件的, 则终止循环</span></span><br><span class="line">        <span class="keyword">if</span> (!collector-&gt;<span class="built_in">collect</span>(label, dist))<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>可以发现,   除开一大段判别代码后,   EigenFace的训练方法的核心代码还是在于PCA,   不过PCA传回了三个值:   均值,   特征值,   特征向量;   训练方法只使用了特征向量这个值;   利用LDA计算投影,   并将其保存在_projections中,   以供后面的预测方法使用;   </p><p>EigenFace的预测方法:   用LDA将数据映射到PCA子空间,   然后挨个计算数据与投影之间的距离,   并汇总到收集器中进行判断,   而构造函数的中的阈值threshold应该是用于最后这里,   最后的代码的意思应该是如果成功找到了一个满足条件的,   则终止循环;   </p><p>所以如果想彻底还要再研究一下OpenCV对PCA和LDA的实现,   以及对收集器的实现;   </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/16/tong-xin-yuan-li/tong-xin-yuan-li-di-5-zhang-03/"/>
    <id>http://example.com/2023/02/16/tong-xin-yuan-li/tong-xin-yuan-li-di-5-zhang-03/</id>
    <published>2023-02-16T14:10:25.668Z</published>
    <updated>2023-02-22T13:35:30.142Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ</h2><p>[TOC]</p><h1 id="数字基带传输-03"><a href="#数字基带传输-03" class="headerlink" title="数字基带传输_03"></a>数字基带传输_03</h1><h2 id="限带信道中PAM信号无码间干扰基带传输"><a href="#限带信道中PAM信号无码间干扰基带传输" class="headerlink" title="限带信道中PAM信号无码间干扰基带传输"></a>限带信道中PAM信号无码间干扰基带传输</h2><h3 id="无码间干扰之传输实例"><a href="#无码间干扰之传输实例" class="headerlink" title="无码间干扰之传输实例"></a>无码间干扰之传输实例</h3><p>由于频带是有限的,   所以在信号传输的时候,   每个码元都会被限制在一定的频带之中,   而频带受限的话,   对应的时域就会展宽,   或者说在时域信号是无限的,   一个信号在有效持续时间内延展到其他的码元中去,   对其他码元造成影响,   被称为码间干扰;   </p><p>为了消除码间串扰,   需要在当前周期中信号的采样时刻处让其他的信号过零点即可,   也就是说在采样处,   其他信号的幅度值为0,   而需要采样的幅度值不为0即可;   也就是</p><p>$$<br>x(kT_s)=\left{ \begin{array}{rcl}<br>&amp;1(或非零常数)&amp;,   &amp;k=0时\<br>&amp;0&amp;,   &amp;k为其他常数\<br>\end{array}\right.<br>$$<br>对信号的频域图进行切割,   若切割并进行频谱搬移后的频谱可以成为一条平着的直线,   则可以进行无码间干扰传输,   而在频域上切割,   其实就是把频谱图的横坐标轴划分为一个一个的T<sub>s</sub>块,   如下图;   这种切割方式对信号的形状有所需求,   也就是把切割后的其他部分搬到基周期上来要能变成一条直线,   其次就是约束了T<sub>s</sub>,   它的倒数也就是码元速率R<sub>s</sub>,   所以无码间干扰基带传输是被限制了码率的;   </p><img src="D:/Program%20Files/Typora/img/image-20230217091038476.png" alt="image-20230217091038476" style="zoom:80%;" /><p>设切割的点为B<sub>N</sub>,   则无码间串扰的传输速率为R<sub>s</sub>=2B<sub>N</sub>;<br>$$<br>因为B_N=\frac1{2T_s}=\frac{R_s}2<br>$$</p><blockquote><p>总结</p><p>如果数字基带传输系统的传输函数在f=1/2T<sub>s</sub>处出现互补特性,   则无码间干扰的最大符号速率为1/T<sub>s</sub>,   称这种互补特性为滚降特性,   互补特性的中心频率点为滚降点,   若滚降点频率为B<sub>N</sub>,   则无码间干扰的最大符号速率R<sub>s</sub>=2B<sub>N</sub>,   在B<sub>N</sub>处可以叠加,   在B<sub>N</sub>/k处都可以进行互补叠加特性;   </p><p>在B<sub>N</sub>/k处都可以叠加是因为B<sub>N</sub>对应着R<sub>s_max</sub>,   R<sub>s_max</sub>对应着T<sub>s_min</sub>,   也就是时域上的最小抽样值,   这个抽样值和频域的零点是对应的,   而抽样值也可以选择每个两个零点抽样一次,   也可以选择每个三个零点抽样一次,   只不过这样T<sub>s</sub>增加,   R<sub>s</sub>就减小了,   但这样做是可以的;   </p><p>换句话说,   当T<sub>s</sub>=kT<sub>s_min</sub>,   则R<sub>s</sub>= 1/k R<sub>s_max</sub>,   则B’<sub>N</sub>= 1/k B<sub>N_max</sub>;   </p></blockquote><p>滚降点如果往内收缩,   最多收缩为理想低通的模样</p><img src="D:/Program%20Files/Typora/img/image-20230217093959578.png" alt="image-20230217093959578" style="zoom:80%;" /><p>此时的滚降点和带宽位于同一频率处,   由于得到了码元速率的单位Baud与滚降点频率的单位Hz之间的关系,   则在等效低通的时候,   由于B=B<sub>N</sub>,   则基带系统的频带利用率理论最大值<br>$$<br>η_{max}=\frac{R_s}{B}=2Baud/Hz<br>$$<br>奈奎斯特采样定律只能限制码元速率,   而不能限制信息速率,   因为R<sub>b</sub>=R<sub>s</sub>log<sub>2</sub>M,   信息速率可以获得进制数的增加带来的增益</p><img src="D:/Program%20Files/Typora/img/image-20230217095121444.png" alt="image-20230217095121444" style="zoom:80%;" /><h3 id="滚降特性"><a href="#滚降特性" class="headerlink" title="滚降特性"></a>滚降特性</h3><img src="D:/Program%20Files/Typora/img/image-20230217100641866.png" alt="image-20230217100641866" style="zoom:80%;" /><p>设滚降系数为<br>$$<br>\alpha=\frac{B-B_N}{B_N}<br>$$</p><p>由于R<sub>s_max</sub>=2B<sub>N</sub>,   所以最大频带利用率为<br>$$<br>\frac{R_s}{B}=\frac{2}{1+\alpha}<br>$$<br>α一般是在(0,   1)之间的,   所以最大频带利用率在(1,   2)之间;   </p><blockquote><p>对不同的α传输函数的比较</p><img src="D:/Program%20Files/Typora/img/image-20230217102512062.png" alt="image-20230217102512062" style="zoom:80%;" /><p>这个过程B<sub>N</sub>始终不变,   故R<sub>s</sub>始终不变;   </p><p>α=0时,   为理想低通,   呈矩形,   也就是最陡峭的时候,   带宽最小;   </p><p>α慢慢增大时,   陡峭程度开始减小,   α=1时,   陡峭程度变为最小,    带宽最大;   </p><p>在时域谱上看,   α=1时,   尾部衰减最快,   α=0时,   尾部衰减最慢;   </p><img src="D:/Program%20Files/Typora/img/image-20230217103046007.png" alt="image-20230217103046007" style="zoom:80%;" /><p>尾部衰减地越快,   定时容限就会越大,   对定时精度的要求就可以越小;   </p></blockquote><img src="D:/Program%20Files/Typora/img/image-20230217103326530.png" alt="image-20230217103326530" style="zoom:80%;" /><p>找到滚降的中心点即可,   1000,   500,   1000,   1500;   </p><p>对于矩形波,   其码元频带利用率就等于占空比<br>第一过零点带宽为1/τ,   码元速率为1/T<sub>s</sub>,   </p><img src="D:/Program%20Files/Typora/img/image-20230217104238121.png" alt="image-20230217104238121" style="zoom:80%;" /><p>对于滚降型波形</p><img src="D:/Program%20Files/Typora/img/image-20230217104818633.png" alt="image-20230217104818633" style="zoom:80%;" /><h3 id="最佳基带传输系统"><a href="#最佳基带传输系统" class="headerlink" title="最佳基带传输系统"></a>最佳基带传输系统</h3><p>指既可以消除码间干扰,   又可以使抗噪声性能最理想(误码率最小)的数字基带系统;   </p><p>基带系统传输总特性为<br>$$<br>X(f)=G_T(f)    C(f)G_R(f)<br>$$<br>把中间的信道看成一个滤波器,   但是先不考虑,   也就是假设信道为理想信道;   </p><p>由于要求无码间干扰,   所以该系统滤波器需要据有升余弦滚降特性<br>$$<br>X(f)=|X_{rc}(f)|e^{-j2\pi ft_d}<br>$$<br>后面跟了一个t<sub>d</sub>的时延是为了工程上的需要;   </p><p>由于要使系统的抗噪性能最佳,   所以接受滤波器需要为匹配滤波器,    而匹配滤波器的频域特性为—接收滤波器为发送滤波器的共轭乘一个延迟<br>$$<br>G_R(f)=G_T^*(f)e^{-j2\pi ft_0}<br>$$<br>式子代入上式,   </p><img src="D:/Program%20Files/Typora/img/image-20230217110730693.png" alt="image-20230217110730693" style="zoom:80%;" /><p>为了获得最佳基带传输系统，可使发送滤波器和接收滤波器的幅频特性分别等于升余弦的平方根频谱;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/12/tong-xin-yuan-li/tong-xin-yuan-li-di-5-zhang-02/"/>
    <id>http://example.com/2023/02/12/tong-xin-yuan-li/tong-xin-yuan-li-di-5-zhang-02/</id>
    <published>2023-02-12T12:25:11.770Z</published>
    <updated>2023-02-16T14:00:38.080Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ</h2><h1 id="数字基带传输-02"><a href="#数字基带传输-02" class="headerlink" title="数字基带传输_02"></a>数字基带传输_02</h1><h2 id="匹配滤波器"><a href="#匹配滤波器" class="headerlink" title="匹配滤波器"></a>匹配滤波器</h2><p>由于抽样器都是取波形中的其中一个脉冲进行01判断的,   所以可能会出错,   但是一个周期中的能量其实是极具说服力的,   是稳定表现该周期内传递的信息的,   所以在抽样之前建议对这个周期的能量进行某种变换,   也就是对这个周期的能量进行通盘考虑,   形成一个数,   判断这个数,   给出判别值;   </p><p>以此即可给出匹配滤波器的定义:   在接收机内采用一种线性滤波器,   当信号和加性噪声通过它时,   滤波器在某一个特定时刻进行抽样,   保证在抽样时刻的**<font color='red'>输出信噪比最大</font>**(也就是信号瞬时功率与噪声平均功率之比最大),   这种滤波器被称为匹配滤波器;   而输出信噪比就是上面说的对一个周期内的能量的衡量;   </p><p>匹配滤波器的时频表示:<br>$$<br>\begin{align*}<br>&amp;频域:   H(f)=KS^*(f)e^{-j2\pi ft_0}\\<br>&amp;时域:   h(t)=Ks(t_0-t)<br>\end{align*}<br>$$<br>也就是将输入信号沿y轴翻转,   然后向右平移t<sub>0</sub> ;   </p><p>t<sub>0</sub>为抽样时刻,   为保证滤波器物理可实现,   需要使t<sub>0</sub>-t&lt;0,   即t&gt;t<sub>0</sub>时,   s(t<sub>0</sub>-t)=0;   而为了让时延尽可能地小,   需要让t<sub>0</sub>尽可能地小,   则t<sub>0</sub>一般取信号消失地时刻;   </p><center>h(t)=Ks(T-t)</center><p>t<sub>0</sub>可以取更大,   但是最好是T时刻;<br>$$<br>\begin{align*}<br>&amp;输入信号:   s(t)\\<br>&amp;匹配滤波器:   h(t)=Ks(t_0-t)\\<br>&amp;输出信号:   s_o(t)= \int ^{\infty}_{-\infty}s(t-\tau)h(\tau)d\tau=KR(t-t_0)\\<br>&amp;采样时刻最大值:   s_o(t_0)=KR(0)=KE<br>\end{align*}<br>$$<br>也就是说匹配滤波器是一个相关器;   </p><img src="D:/Program%20Files/Typora/img/image-20230211221937480.png" alt="image-20230211221937480" style="zoom: 67%;" /><p>对于最大信噪比的结论,   匹配滤波器的最大信噪比与输入信号的波形无关,   持续时间无关,   只与信号的能量有关,   满足于上面说的”匹配滤波器通过能量进行信号的判决”;   </p><p>对于采样时刻信号+噪声的概率分布,   噪声的均值为0,   所以均值为信号的均值KE,   该信号没有直流功率,   只有交流功率,   所以信号的平均功率就是交流功率就是方差,   K<sup>2</sup>N<sub>0</sub>E/2;   </p><p>由于对应的题目一定会要求计算E的,   所以复习一下E的求法:   对信号求平方,   然后积分,   就可以的到能量;   </p><img src="D:/Program%20Files/Typora/img/image-20230212202349026.png" alt="image-20230212202349026" style="zoom:80%;" /><p>h(t)为匹配滤波器的冲激响应,   所以h(t)为原信号的对称翻转右移形式;   可先求出他们的自相关    s<sub>o</sub>(t)=s(t) * h(t)=R(t-t<sub>0</sub>),   然后再根据需要的t<sub>0</sub>进行调整;   输出的最大值出现在t<sub>0</sub>时刻</p><center>s<sub>o</sub>(t<sub>0</sub>)=R(0)=A<sup>2</sup>T</center><p>抽样时刻的概率密度函数需要求得均值和方差,   均值就是能量E,   方差依赖于E,   默认K=1;<br>$$<br>\begin{align*}<br>&amp;f(y)=\frac1{\sqrt{2\pi }\sigma_n}exp[-\frac{(y-a)^2}{2\sigma^2_n}]\\<br>&amp;a=A^2T\\<br>&amp;\sigma^2=\frac{K^2EN_0}2=\frac{N_0A^2T}{2}<br>\end{align*}<br>$$</p><blockquote><p>对老师课间给的题目的解析</p><p>题目:   AMI系统中，信息符号0、1等概分布，码元速率为10Baud。采用双极性归零码，波形为矩形波，占空比为0.5,   该系统的第一过零点带宽为多少?</p><p>码元速率为10Baud,   也就是每秒钟发送10个码元,   码元周期(也就是一个码的长度)为0.1s,   占空比对应着归零码,   也就是发送一个码元的那个波仅需要持续0.05s,   那么1/0.05=20hz就可以了,   吗?</p><p>不,   那是对于PAM信号而言的,   对于AMI码,   第一过零点带宽恒等于1/T<sub>s</sub>,   所以应该是1/0.1=10hz;   </p></blockquote><h2 id="AWGN信道条件下的2PAM数字基带系统的抗噪性能"><a href="#AWGN信道条件下的2PAM数字基带系统的抗噪性能" class="headerlink" title="AWGN信道条件下的2PAM数字基带系统的抗噪性能"></a>AWGN信道条件下的2PAM数字基带系统的抗噪性能</h2><p>对于高斯变量,   </p><img src="D:/Program%20Files/Typora/img/image-20230212213212567.png" alt="image-20230212213212567" style="zoom: 50%;" />$$\begin{align*}&U~N(a,   \sigma^2)\\\\&P(U>x)=Q(\frac d\sigma)=Q(\frac{x-a}\sigma)\\\\&P(U>x)=\frac12erfc(\frac{x-a}{\sqrt2\sigma})\end{align*}$$<h3 id="2PAM数基系统的抗噪模型"><a href="#2PAM数基系统的抗噪模型" class="headerlink" title="2PAM数基系统的抗噪模型"></a>2PAM数基系统的抗噪模型</h3><img src="D:/Program%20Files/Typora/img/image-20230212213436196.png" alt="image-20230212213436196" style="zoom:80%;" /><p>接收滤波器输出的信号y(t)是一个信号+噪声的高斯分布的波,   要从这个波中分出哪些是0哪些是1,<br>$$<br>s_i(t)=\left{ \begin{array}{rcl}<br>s_1(t),   &amp;b_k=1\<br>s_2(t),   &amp;b_k=0\<br>\end{array}\right.<br>$$<br>接收端出现两种错误:   </p><p>当发送s<sub>1</sub>(t)时,   噪声在抽样时刻呈现一个较大的负值,   使得接收端将它错判为s<sub>2</sub>(t),   其条件概率为P(e|s<sub>1</sub>);   </p><p>当发送s<sub>2</sub>(t)时,   噪声在抽样时刻呈现一个较大的负值,   使得接收端将它错判为s<sub>1</sub>(t),   其条件概率为P(e|s<sub>2</sub>);   </p><p>总误符号率为P<sub>b</sub>=P(s<sub>1</sub>)P(e|s<sub>1</sub>)+P(s<sub>2</sub>)P(e|s<sub>2</sub>)</p><p>接收端接收到信号,   需要对这个信号进行抽样,   而由于前面说过,   滤波器滤过的信号是一个信号值+噪声的高斯波,   所以抽样值如下:<br>$$<br>y(kT_b)=\left{ \begin{array}{rcl}<br>a+n_o(kT_b),   &amp;发s_1(t)时\<br>-a+n_o(kT_b),   &amp;发s_2(t)时\<br>\end{array}\right.<br>$$<br>所以抽样时刻的概率密度曲线如下图</p><img src="D:/Program%20Files/Typora/img/image-20230212215639347.png" alt="image-20230212215639347" style="zoom:80%;" /><p>由于目的是求得判决门限的取值,   误码率最小的判决门限的取法就是最佳取法,   所以根据这个图,   算出误码率;<br>$$<br>比如P(e|s_2)就是上图浅灰色那块区域的面积,   也等于Q(\frac{V_d-(-a)}{\sigma^2_n})=Q(\frac{V_d+a}{\sigma^2_n})<br>$$<br>然后就一顿算~~    就得到一个结论<br>$$<br>\begin{align*}<br>&amp;最佳判决门限V_d^<em>与初始的先验概率是相关的,\\<br>&amp;如果P(s_1)=P(s_2),则V_d^</em>=0;   \\<br>&amp;此时,   基带传输系统的总误比特率P_b为\\<br>&amp;P_b=Q(\frac a{\sigma_n})=Q(\sqrt{\frac {a^2}{\sigma_n^2}})=\frac12erfc(\sqrt\frac{a^2}{\sigma^2_n})<br>\end{align*}<br>$$<br>把误比特率写成第二个式子的形式,   是因为该式子可以看成信噪比,   即基带传输系统的误码率与抽样时刻的信噪比r直接相关,   其中r为<br>$$<br>r=\frac{a^2}{\sigma^2_n}<br>$$</p><p>以上为双极性,   而对于单极性,   等概时V<sub>d</sub>=a/2,   其误码率为<br>$$<br>P_b=Q(\sqrt{\frac {a^2}{4\sigma_n^2}})=\frac12erfc(\sqrt\frac{a^2}{8\sigma^2_n})<br>$$</p><blockquote><p>相同信噪比,   双极性的误码率更低;   </p><p>相同信噪比,   即r=a<sup>2</sup>/σ<sub>n</sub><sup>2</sup>相同,   因Q函数中单极性的分母大,   则分式整体小,   因Q函数为减函数,   故单极性的误码率较大,   双极性的误码率较小;   </p><p>但是在相同信噪比的前提下,   由于单极性和双极性的发送信号之平均功率不同,   所以这种对比是不公平的,   需要将单极性发1时的幅度值变为√2,   才公平;   </p></blockquote><h3 id="匹滤的最佳接收的误比特率"><a href="#匹滤的最佳接收的误比特率" class="headerlink" title="匹滤的最佳接收的误比特率"></a>匹滤的最佳接收的误比特率</h3><p>在使用匹配滤波器的前提下,   最小误码率的接受准则就映射为了最大信噪比的接受准则;   换句话说,   想要最小误码率,   就需要最大信噪比,   而如何获取最大信噪比呢? 就是使用匹配滤波器;   </p><p>双极性2PAM误比特率:   </p><p>前面提到通过匹配滤波器后,   得到的那个值a就是KE,<br>$$<br>s_o(kT_s)=\left{ \begin{array}{rcl}<br>&amp;KE,   &amp;发s_1(t)时\<br>&amp;-KE,   &amp;发s_2(t)时\<br>\end{array}\right.<br>$$<br>由于这是2PAM系统,   所以E<sub>b</sub>=E,   所有东西一伙带入,   得到双极性误码率<br>$$<br>P_b=Q(\sqrt{\frac{2E_b}{N_0}})=\frac12erfc(\sqrt\frac{E_b}{N_0})<br>$$</p><p>对于单极性,   抽样时刻<br>$$<br>s_o(kT_s)=\left{ \begin{array}{rcl}<br>&amp;KE_1,   &amp;发s_1(t)时\<br>&amp;0,   &amp;发s_2(t)时\<br>\end{array}\right.<br>$$<br>每bit能量E<sub>b</sub>=1/2E<sub>1</sub>误比特率为<br>$$<br>P_b=Q(\sqrt\frac{E_b}{N_0})=\frac12erfc(\sqrt\frac{E_b}{2N_0})<br>$$</p><p>该结论有较高的抽象性,   该结论表明,   两个信号只要能量相同,   在AWGN信道中,   当其他条件相同时,   这两个信号的抗噪性能是相同的,   不管这两个信号长什么样子;   </p><img src="D:/Program%20Files/Typora/img/image-20230216220030856.png" alt="image-20230216220030856" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/10/bi-ye-lun-wen/deng-yu-tong-di-san-ci-zhou-bao/"/>
    <id>http://example.com/2023/02/10/bi-ye-lun-wen/deng-yu-tong-di-san-ci-zhou-bao/</id>
    <published>2023-02-10T13:57:53.091Z</published>
    <updated>2023-02-10T14:51:08.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三次周报"><a href="#第三次周报" class="headerlink" title="第三次周报"></a>第三次周报</h1><ol><li><p>增加虹软人脸识别引擎于系统之中</p><p>使用配置文件的方式,   达到轻松修改识别算法的目的;   </p><img src="D:/Program%20Files/Typora/img/image-20230210215947385.png" alt="image-20230210215947385" style="zoom:80%;" /></li><li><p>初步测试</p><p>(1) 统计 “检测到人脸特征” 但是 “识别算法未识别出该人脸是谁” 的帧数;   </p><p>Eigen算法还是不能用;   </p><p>Fisher算法非常不够稳定,   有时候是3~6帧,   有时候是30多帧;   </p><p>LBPH算法足够稳定,   在0~2帧左右;   </p><p>虹软识别引擎足够稳定,   在0~1帧左右;   </p><p>(2) 统计侧脸识别率;   </p><p>基础算法都不行,   只有虹软引擎可以,   并且稳定在0~1帧;   </p><p>(3) 录入时和检测时的光照不同( 3.5瓦台灯全功率照明和关闭),   统计未识别帧数;  </p><p>LBPH算法在该种情况下不能够识别,   只有当照明度类似时才可以;   </p><p>虹软引擎可以识别,   且稳定在0帧;   </p><p>(4) 后面还有脸部阻隔物(如眼镜)测试,   歪脸测试,   虹软引擎都能完美驾驭,   而基础算法均不可以;   </p></li><li><p>待完成任务</p><p>​        该系统使用的OpenCV的jar包是带有扩展包的4.1.0,   它提供基于深度学习的人脸识别算法,   以后试试把它纳入到系统中来;   (之所以现在没有实现它,   是因为OpenCV把那些基础算法都扔到了扩展包中,   而在高版本的jar包中所实现的基于深度学习的人脸算法对应的类FaceRecognizerSF并没有继承于扩展包中所有人脸算法的实现子类的父类—FaceRecognizer,   自然不能像切换基础人脸算法类那样去更改实现子类;   FaceRecognizerSF有一套自己的书写标准,   所以还需要时间去琢磨)</p><p>​        像数据库那种东西就先不弄了;   </p></li><li><p>总结</p><p>这周着实没干嘛,   一直在准备省考😭,   还有开学考试😭😭;   </p><blockquote><p>向老师提问:   我现在有点不明白老师所说的多多挖掘算法到底是啷个意思,   指的是不同算法的测试吗? 还是要纳入更多的可选择人脸算法到系统中? 还是深入算法原理和实现? 还有对于不同算法的测试方法,   老师有没有啥子建议,   还望老师不吝赐教;   </p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三次周报&quot;&gt;&lt;a href=&quot;#第三次周报&quot; class=&quot;headerlink&quot; title=&quot;第三次周报&quot;&gt;&lt;/a&gt;第三次周报&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加虹软人脸识别引擎于系统之中&lt;/p&gt;
&lt;p&gt;使用配置文件的方式,   达到轻松修改识别算法的目的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/10/gong-wu-yuan-kao-shi/shen-lun-005/"/>
    <id>http://example.com/2023/02/10/gong-wu-yuan-kao-shi/shen-lun-005/</id>
    <published>2023-02-10T08:21:38.199Z</published>
    <updated>2023-02-10T09:09:15.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="评价类"><a href="#评价类" class="headerlink" title="评价类"></a>评价类</h2><p>评论类公文的识别—评论类公文的目的是对某些现象或观点进行评价;   </p><p>时评,   评论文;   </p><p>表态+相关要素+对策;   </p><blockquote><p>评论类文章的介绍必须写 !</p></blockquote><img src="D:/Program%20Files/Typora/img/image-20230210162543151.png" alt="image-20230210162543151" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230210161837931.png" alt="image-20230210161837931" style="zoom:80%;" /><blockquote><p>复习</p><p>对答案时,   看有没有漏掉的点,   有没有规范词,   有没有表述可以简略,   重新梳理逻辑,   将给自己听,   最后重新蒙着答案将这道题做一遍,   再对答案查看剩余毛病;   </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;评价类&quot;&gt;&lt;a href=&quot;#评价类&quot; class=&quot;headerlink&quot; title=&quot;评价类&quot;&gt;&lt;/a&gt;评价类&lt;/h2&gt;&lt;p&gt;评论类公文的识别—评论类公文的目的是对某些现象或观点进行评价;   &lt;/p&gt;
&lt;p&gt;时评,   评论文;   &lt;/p&gt;
&lt;p&gt;表态+</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/09/gong-wu-yuan-kao-shi/shen-lun-003/"/>
    <id>http://example.com/2023/02/09/gong-wu-yuan-kao-shi/shen-lun-003/</id>
    <published>2023-02-09T12:15:05.732Z</published>
    <updated>2023-02-10T08:53:53.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公文题"><a href="#公文题" class="headerlink" title="公文题"></a>公文题</h1><p>写一份指导意见,   或者讲话稿;   </p><p>语言分—结尾号召一句就可以了;   </p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="具体格式"><a href="#具体格式" class="headerlink" title="具体格式"></a>具体格式</h3><ol><li><p>标题</p><p>发文机关+”关于”+事由+”的”+文种;   如果是非正式的,   不加发文机关;   </p><p>书写格式—标题要居中书写,   不带书名号;   尽量一行之内写下;   </p></li><li><p>称谓或主送机关</p><p>(1) 称谓(对象为人物)</p><p>尊敬的与会嘉宾,   广大的家长朋友们;   </p><p>(2) 主送机关(对象为单位)</p><p>各社区,   各街道办;   </p><p>(3) 书写格式</p><p>顶格书写;   </p></li><li><p>落款</p><p>(1) 单位(个人)</p><p>某企业工会(写在时间上一行);   </p><p>(2) 时间</p><p>xxxx年xx月xx日;   </p><p>(3) 书写格式</p><p>落款位于文章右下方,   日期右空四个格子(空几个都行),   发文者以日期为准上方居中;   </p></li></ol><blockquote><p>公文格式:   原则—标题一定写,   如果题干给了落款称呼,   那就写上;   </p><p>例外:   </p><p>特殊文种<br>        讲话稿,   发言稿—只写标题称呼<br>        工作方案,   调查报告—只写标题,   关于<br>        新闻稿,   评论类公文—只写标题</p><p>特殊要求<br>        提纲/内容要点/不必注意格式;   有这样的字样的不必写格式,   如果有空间则写标题;   </p></blockquote><h2 id="方案类"><a href="#方案类" class="headerlink" title="方案类"></a>方案类</h2><p>识别—为某个或某些对象能够更好地完成工作或任务而进行的规划,   一般侧重对策,   建议和具体做法;   </p><p>与主题相关的对策写在核心的部分,   其他要素写在开头;   </p><p>开头—交代缘由(背景,   根据,   目的,   意义,   问题)<br>主体—具体的解决问题的对策<br>结尾—看情况写</p><blockquote><p>如果题干中出现格式规范等词,   就说明是公文题;   </p></blockquote><h2 id="总结类"><a href="#总结类" class="headerlink" title="总结类"></a>总结类</h2><img src="D:/Program%20Files/Typora/img/image-20230209215305546.png" alt="image-20230209215305546" style="zoom:80%;" /><p>“编者按”可以不写标题</p><h1 id="规范词积累"><a href="#规范词积累" class="headerlink" title="规范词积累"></a>规范词积累</h1><p>多种身份的人——各界人士、各行各业人员</p><p>有用、有价值的事物——资源 </p><p>固定的方式方法——模式 </p><p>确定线上线下老师——双师教学</p><img src="D:/Program%20Files/Typora/img/image-20230210161732390.png" alt="image-20230210161732390" style="zoom:80%;" /><p>走访群众、了解群众情况——深入基层、基层走访</p><p>确保地区无违法、犯罪问题——治安、安全</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;公文题&quot;&gt;&lt;a href=&quot;#公文题&quot; class=&quot;headerlink&quot; title=&quot;公文题&quot;&gt;&lt;/a&gt;公文题&lt;/h1&gt;&lt;p&gt;写一份指导意见,   或者讲话稿;   &lt;/p&gt;
&lt;p&gt;语言分—结尾号召一句就可以了;   &lt;/p&gt;
&lt;h2 id=&quot;格式&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
</feed>
