<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aegis</title>
  
  <subtitle>Aegis Curiser</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-26T07:30:33.831Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Deng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PCA</title>
    <link href="http://example.com/2023/04/26/bi-ye-lun-wen/f013-pca/"/>
    <id>http://example.com/2023/04/26/bi-ye-lun-wen/f013-pca/</id>
    <published>2023-04-26T07:30:17.000Z</published>
    <updated>2023-04-26T07:30:33.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h1><h2 id="PCA解析1"><a href="#PCA解析1" class="headerlink" title="PCA解析1"></a>PCA解析1</h2><p>有许多只小白鼠,   每只小白鼠的DNA中都有各种各样的基因,   视频中给出了这些小白鼠的两种基因;   这里可以做一个抽象,   如何表示这些小白鼠? 可以用颜色啊,   瞳孔大小啊,   爪子的大小等等来描述一只小白鼠,   这些东西就是小白鼠的特征,   每一只小白鼠的这些特征都是不一样的,   而小白鼠的每一个特征都可以与一个数值挂钩;   因此,   当拿到一只小白鼠的时候,   只需要测量这只小白鼠的上述特征,   然后与提前测好的数据进行对比,   就可以判断它是哪一只了;   </p><p>而视频中,   相当于使用”基因1”和”基因2”这两个特征来描述一只小白鼠;   </p><p>然后跟着视频走,   如果只用”基因1”来描述小白鼠的话,   那么这些小白鼠就可以被画到一条横轴上;   </p><img src="D:/Program%20Files/Typora/img/image-20230228221429091.png" alt="image-20230228221429091" style="zoom:80%;" /><p>如果用两个基因来描述小白鼠的话,   那么这些小白鼠就可以被画到一个二维坐标系当中;   </p><img src="D:/Program%20Files/Typora/img/image-20230228221743565.png" alt="image-20230228221743565" style="zoom:80%;" /><p>三个基因同理;   而因为人类是三微生物,   无法想象四维空间,   所以四维及其更高维度无法被人类画出;   而PCA可以对高维度的数据进行处理,   并将其降到低维度,   而且也能够告诉我们哪些基因(或者说维度)更有价值;   </p><blockquote><p>换句话说,   PCA能够对高维度的数据进行排序,   然后告诉我们,   有些维度的数据是很重要的,   有些不是很重要,   所以它们可以忽略;   换到基因这个例子中来,   PCA会告诉我们,   哪些基因是很重要的,   哪些基因不是很重要(或者说可省略);   而我们知道了哪些维度的数据可以省略之后,   就省略他们就好了,   这就达到了降维的效果;   </p></blockquote><p>然后跟着视频走;   算出两个基因各自的平均值,   就可以找到这些数据在二维空间中的中心点,   然后把坐标轴移动到中心点的位置,   这样就可以用一条线将这些数据拟合到一起;   </p><img src="D:/Program%20Files/Typora/img/image-20230228223930528.png" alt="image-20230228223930528" style="zoom:80%;" /><p>那怎么才能找到这个所谓的拟合度最好的线呢? 首先我们任意画出一条过圆点的直线,   然后将这些数据映射到这条线上,   也就是说二维空间中的每一个数据点都对应于拟合线上的一个点,   而这些点到原点的距离是重要的衡量拟合度的指标;   在PCA中,   这些距离越长,   拟合度越好;   </p><blockquote><p>视频使用勾股定理来描述投影点到原点的距离可谓是及其详细了,   这里就不再谈了;   只需要记住一点,   拟合线到数据点的垂直距离越小,   数据点对应的映射点到原点的距离就越大;   所以PCA寻找最佳拟合度的方式就是—最大化映射点到原点的距离的平方和;   </p><p>然后小总结一下PCA最佳拟合线的步骤:   </p><ol><li>求得数据在各个维度上的均值,   找到其中心点,   将坐标轴移动到中心点,   使中心点变为坐标轴的原点</li><li>画一条通过原点的直线,   将数据点投影到这条直线上,   然后求得所有投影点到原点的距离的平方和,   最后求得这个平方和的最大值,   即找到最佳拟合线;   </li></ol></blockquote><p>大费周章找到的这一条最佳拟合线就是PCA的主成分1;   有主成分1,   肯定就有主成分2和主成分3;   </p><p>这一条最佳拟合线可以表示一些讯息,   比如视频中谈到的,   因为这一条线是往x轴倾斜的,   所以”基因1”的重要程度大于”基因2”;   还有,   像视频中说的那样,   为得到1份PC1,   需要4份的”基因1”和1份的”基因2”,   但是这样说其实并不严谨,   应该说4份”基因1”和1份”基因2”可以组成4.12份PC1;   </p><img src="D:/Program%20Files/Typora/img/image-20230228230342429.png" alt="image-20230228230342429" style="zoom:80%;" /><p>所以为了知道1份PC1的组成,   我们需要对上述份数进行归一化;   最终得到的结果为0.97份”基因1”和0.242份”基因2”可以组成1份PC1;   </p><p>这样就得到了PC1的单位向量啦! 设PC1的单位向量为<strong>e</strong>,   则<strong>e</strong>=[0.97Gene1,   0.242Gene2];   这玩意儿就是PC1的特征向量 !!</p><p>而每个基因前面的系数就被称为载荷得分,   直观理解就是贡献度啦,   再直观理解就是重要程度啦;   </p><p>而前面提到的寻找最佳拟合度所使用的投影点的距离平方和就是PC1的特征值 ! (这些个距离平方和除以数据点的数量,   得到的就是方差,   也就是描述数据相对于中心点的离散程度的一个量)</p><p>然后求得PC1的垂直线,   就得到了PC2;   而对于PC2,   “基因2”的影响程度是”基因1”的4倍;   同样可以求得PC2的特征向量啦,   特征值啦,   载荷得分啦;   </p><p>在得到PC1和PC2的方差之后,   就可以进行主成分的贡献度的比较;   在这个例子中,   PC1的贡献度大于PC2;   </p><img src="D:/Program%20Files/Typora/img/image-20230228232407102.png" alt="image-20230228232407102" style="zoom:80%;" /><p>然后我们就可以对上述过程进行抽象啦!!!</p><p>一个m * n规模的矩阵(m行n列)可以这么表示:   </p><p>$$<br>M=\left[ \begin{array}{cc|r}<br>X_1\<br>X_2\<br>…\<br>X_m<br>\end{array} \right]<br>$$<br>其中每一个X<sub>i</sub>,   都是一个n列的向量:<br>$$<br>X_i=[a_1,   a_2,   a_3…,   a_n]<br>$$<br>也就是说,   X<sub>i</sub>就是样本,   a<sub>i</sub>就是特征;   </p><p>竖着求得每一个特征的平均值,   得到一个平均向量<br>$$<br>\overline{X}=[\overline{a_1},   \overline{a_2},   …,   \overline{a_n}]<br>$$<br>每一个样本减去这一个平均向量(相当于上面将中点移动到坐标轴原点),   得到一个新的矩阵<strong>M’</strong>:<br>$$<br>M’=\left[ \begin{array}{cc|r}<br>X_1’\<br>X_2’\<br>…\<br>X_m’<br>\end{array} \right]<br>$$<br>然后就是求主成分;   </p><p>将每个X<sub>i</sub>‘投影到PCA子空间中;   </p><blockquote><p>这里要注意,   刚才在二维空间中,   是将数据点投影到一条直线上,   也就是说二维空间的两个维度对应直线的一个维度,   所以这个PCA子空间的维度比变量的维度小1;   </p></blockquote><p>求得每个X<sub>i</sub>‘在PCA子空间中的投影点到原点的距离,   将这些距离平方并相加,   找到其最大值,   除以样本量,   即得到该主成分的特征值;   将这一主成分用向量形式表示出来,   然后归一化,   即得到特征向量;   </p><p>像这样找出所有的主成分,   将他们按照方差从大到小进行排列,   取前几个,   即可得到降维后的矩阵,   对上述所说的矩阵进行降维的话,   得到的矩阵就是一个m * r规模的矩阵,   其中r &lt; n;   </p><h2 id="PCA解析2"><a href="#PCA解析2" class="headerlink" title="PCA解析2"></a>PCA解析2</h2><p>一组n个变量，这个n可能非常大，可能随随便便就上万，甚至十万百万。想要直接比较两个或多个数据，显然就十分困难。而经过主成分分析，这样一组包含n个变量的数据经过转换变成了一组包含r个变量的数据，其中r&lt;n，这样的过程即是降维，得到即是r个主成分。这r个主成分会依据方差的大小进行排序，称作主成分（PC）1、主成分2、……主成分r。而每个主成分的方差在这一组变量中的总方差中所占的比例，即是主成分的贡献度。通常来说，我们仅考察贡献度前2或者前3的主成分，经过可视化后，即得到了二维或三维PCA散点图。</p><p>主成分分析法将变量之间根据相关性进行分解、合并和降维，类似于从n维空间到r维空间的投影。</p><p>在分析过程中，PCA可以让我们非常直观地看出各个样本之间的相似性。例如在一张PCA散点图中，数个样本的点聚在一起，那么就说明这几个样本之间的相似性非常高；反之，如果几个样本的点非常分散，则说明这几个样本之间的相似性比较低。例如下图，几个组的样本对应的散点在组内呈现相互聚集的情况，说明组内的重复性比较好，样本数据非常相似，而组间则有较好的区分度。有的时候为了说明组内样本的相似程度，还会用一个椭圆将同一组的样本对应的散点全部囊括起来。</p><img src="D:/Program%20Files/Typora/img/image-20230227232415689.png" alt="image-20230227232415689" style="zoom: 50%;" /><h2 id="OpenCV中的PCA案例"><a href="#OpenCV中的PCA案例" class="headerlink" title="OpenCV中的PCA案例"></a>OpenCV中的PCA案例</h2><p>下面是OpenCV提供的一个pca的使用例子,   是对图像的轮廓使用的PCA,   而其核心就是getOrientation函数,   传入找到的轮廓点集合和图像,   getOrientation函数能够找到轮廓的方向,   并在图像中将其画出;   </p><p>PCA算法可以算出其均值,   特征向量和特征值;   在这个例子中,   由于传入getOrientation函数的集合为点集,   转换为矩阵之后的规模,   行数为点集的大小,   列数为2,   也就是横纵坐标;   把这玩意传入PCA中后,   获取该矩阵的均值,   特征值和特征向量,   由于矩阵的规模为(sz,   2),   所以特征值和特征向量只各有两个;   然后该函数通过一系列我看不懂的运算,   使用drawAxis函数将图像的轮廓的方向在图像上画出;   </p><p>所以这个例子展示了OpenCV提供的PCA接口应该如何使用,   也展示PCA的用途—降维;   在该例子中,   PCA将传入的规模为(sz,   2)的矩阵降至…额,   总共有两个特征向量,   每个特征向量的只有两个分量,   所以降至(2,   2)的规模,   所以这样看的话,   似乎前面说错了,   PCA算出的特征向量按照行向量来表示的话,   还是有sz个,   但是只取到了前两个,   根据前文的描述,   行向量是通过方差的大小来排列的,   也就是说,   前两个向量的所提供的贡献度是最大的;   </p><p>尽管如此,   PCA的具体实现还是要深入pca.cpp才能一探究竟;   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file introduction_to_pca.cpp</span></span><br><span class="line"><span class="comment"> * @brief This program demonstrates how to use OpenCV PCA to extract the orientation of an object</span></span><br><span class="line"><span class="comment"> * @author OpenCV team</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/core.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function declarations</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawAxis</span><span class="params">(Mat&amp;, Point, Point, Scalar, <span class="keyword">const</span> <span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getOrientation</span><span class="params">(<span class="keyword">const</span> vector&lt;Point&gt; &amp;, Mat&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function drawAxis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawAxis</span><span class="params">(Mat&amp; img, Point p, Point q, Scalar colour, <span class="keyword">const</span> <span class="keyword">float</span> scale = <span class="number">0.2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//! [visualization1]</span></span><br><span class="line">    <span class="keyword">double</span> angle = <span class="built_in">atan2</span>( (<span class="keyword">double</span>) p.y - q.y, (<span class="keyword">double</span>) p.x - q.x ); <span class="comment">// angle in radians</span></span><br><span class="line">    <span class="keyword">double</span> hypotenuse = <span class="built_in">sqrt</span>( (<span class="keyword">double</span>) (p.y - q.y) * (p.y - q.y) + (p.x - q.x) * (p.x - q.x));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here we lengthen the arrow by a factor of scale</span></span><br><span class="line">    q.x = (<span class="keyword">int</span>) (p.x - scale * hypotenuse * <span class="built_in">cos</span>(angle));</span><br><span class="line">    q.y = (<span class="keyword">int</span>) (p.y - scale * hypotenuse * <span class="built_in">sin</span>(angle));</span><br><span class="line">    <span class="built_in">line</span>(img, p, q, colour, <span class="number">1</span>, LINE_AA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the arrow hooks</span></span><br><span class="line">    p.x = (<span class="keyword">int</span>) (q.x + <span class="number">9</span> * <span class="built_in">cos</span>(angle + CV_PI / <span class="number">4</span>));</span><br><span class="line">    p.y = (<span class="keyword">int</span>) (q.y + <span class="number">9</span> * <span class="built_in">sin</span>(angle + CV_PI / <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">line</span>(img, p, q, colour, <span class="number">1</span>, LINE_AA);</span><br><span class="line"></span><br><span class="line">    p.x = (<span class="keyword">int</span>) (q.x + <span class="number">9</span> * <span class="built_in">cos</span>(angle - CV_PI / <span class="number">4</span>));</span><br><span class="line">    p.y = (<span class="keyword">int</span>) (q.y + <span class="number">9</span> * <span class="built_in">sin</span>(angle - CV_PI / <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">line</span>(img, p, q, colour, <span class="number">1</span>, LINE_AA);</span><br><span class="line">    <span class="comment">//! [visualization1]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function getOrientation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getOrientation</span><span class="params">(<span class="keyword">const</span> vector&lt;Point&gt; &amp;pts, Mat &amp;img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//! [pca]</span></span><br><span class="line">    <span class="comment">//Construct a buffer used by the pca analysis</span></span><br><span class="line">    <span class="comment">// 生成用于pca分析的矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵大小为轮廓集合的大小</span></span><br><span class="line">    <span class="keyword">int</span> sz = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pts.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成矩阵, 行数为sz, 列数为2</span></span><br><span class="line">    Mat data_pts = <span class="built_in">Mat</span>(sz, <span class="number">2</span>, CV_64F);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置data_pts的具体的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data_pts.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data_pts.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">0</span>) = pts[i].x;</span><br><span class="line">        data_pts.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">1</span>) = pts[i].y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Perform PCA analysis</span></span><br><span class="line">    <span class="comment">// 进行PCA分析, 输出为行矩阵</span></span><br><span class="line">    <span class="comment">// 此项的第二个参数用于协方差矩阵相应值的获取</span></span><br><span class="line">    <span class="function">PCA <span class="title">pca_analysis</span><span class="params">(data_pts, Mat(), PCA::DATA_AS_ROW)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Store the center of the object</span></span><br><span class="line">    <span class="comment">// 存储对象的中心</span></span><br><span class="line">    <span class="comment">// 该点为使用PCA算法算出的平均值的坐标</span></span><br><span class="line">    Point cntr = <span class="built_in">Point</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pca_analysis.mean.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)),</span><br><span class="line">                      <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pca_analysis.mean.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Store the eigenvalues and eigenvectors</span></span><br><span class="line">    <span class="comment">// 存储使用PCA算法算出的特征向量和特征值</span></span><br><span class="line">    <span class="function">vector&lt;Point2d&gt; <span class="title">eigen_vecs</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">eigen_val</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        eigen_vecs[i] = <span class="built_in">Point2d</span>(pca_analysis.eigenvectors.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">0</span>),</span><br><span class="line">                                pca_analysis.eigenvectors.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        eigen_val[i] = pca_analysis.eigenvalues.at&lt;<span class="keyword">double</span>&gt;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! [pca]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! [visualization]</span></span><br><span class="line">    <span class="comment">// Draw the principal components</span></span><br><span class="line">    <span class="comment">// 画出主成分图</span></span><br><span class="line">    <span class="built_in">circle</span>(img, cntr, <span class="number">3</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">    Point p1 = cntr + <span class="number">0.02</span> * <span class="built_in">Point</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(eigen_vecs[<span class="number">0</span>].x * eigen_val[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(eigen_vecs[<span class="number">0</span>].y * eigen_val[<span class="number">0</span>]));</span><br><span class="line">    Point p2 = cntr - <span class="number">0.02</span> * <span class="built_in">Point</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(eigen_vecs[<span class="number">1</span>].x * eigen_val[<span class="number">1</span>]), <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(eigen_vecs[<span class="number">1</span>].y * eigen_val[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">drawAxis</span>(img, cntr, p1, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">drawAxis</span>(img, cntr, p2, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> angle = <span class="built_in">atan2</span>(eigen_vecs[<span class="number">0</span>].y, eigen_vecs[<span class="number">0</span>].x); <span class="comment">// orientation in radians</span></span><br><span class="line">    <span class="comment">//! [visualization]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> angle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function main</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//! [pre-process]</span></span><br><span class="line">    <span class="comment">// Load image</span></span><br><span class="line">    <span class="comment">//打印提示信息</span></span><br><span class="line">    <span class="function">CommandLineParser <span class="title">parser</span><span class="params">(argc, argv, <span class="string">&quot;&#123;@input | pca_test1.jpg | input image&#125;&quot;</span>)</span></span>;</span><br><span class="line">    parser.<span class="built_in">about</span>( <span class="string">&quot;This program demonstrates how to use OpenCV PCA to extract the orientation of an object.\n&quot;</span> );</span><br><span class="line">    parser.<span class="built_in">printMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取要处理的图像</span></span><br><span class="line">    Mat src = <span class="built_in">imread</span>( samples::<span class="built_in">findFile</span>( parser.get&lt;String&gt;(<span class="string">&quot;@input&quot;</span>) ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if image is loaded successfully</span></span><br><span class="line">    <span class="comment">// 检查图像是否成功获取</span></span><br><span class="line">    <span class="keyword">if</span>(src.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Problem loading image!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示原图像</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;src&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert image to grayscale</span></span><br><span class="line">    <span class="comment">// 将原图像转为灰度图</span></span><br><span class="line">    Mat gray;</span><br><span class="line">    <span class="built_in">cvtColor</span>(src, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert image to binary</span></span><br><span class="line">    <span class="comment">// 通过threshold函数将灰度图转为二值图像! 二值图像保存在bw中</span></span><br><span class="line">    Mat bw;</span><br><span class="line">    <span class="built_in">threshold</span>(gray, bw, <span class="number">50</span>, <span class="number">255</span>, THRESH_BINARY | THRESH_OTSU);</span><br><span class="line">    <span class="comment">//! [pre-process]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! [contours]</span></span><br><span class="line">    <span class="comment">// Find all the contours in the thresholded image</span></span><br><span class="line">    <span class="comment">// 通过findContours函数找到二值图像中的所有轮廓,</span></span><br><span class="line">    <span class="comment">// 获取到的轮廓存入contours中</span></span><br><span class="line">    vector&lt;vector&lt;Point&gt; &gt; contours;</span><br><span class="line">    <span class="built_in">findContours</span>(bw, contours, RETR_LIST, CHAIN_APPROX_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Calculate the area of each contour</span></span><br><span class="line">        <span class="comment">// 计算每条轮廓的轮廓面积</span></span><br><span class="line">        <span class="keyword">double</span> area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ignore contours that are too small or too large</span></span><br><span class="line">        <span class="comment">// 舍弃掉太小和太大的面积</span></span><br><span class="line">        <span class="keyword">if</span> (area &lt; <span class="number">1e2</span> || <span class="number">1e5</span> &lt; area) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw each contour only for visualisation purposes</span></span><br><span class="line">        <span class="comment">// 绘制轮廓, 没有其他目的, 仅为可视化</span></span><br><span class="line">        <span class="built_in">drawContours</span>(src, contours, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the orientation of each shape</span></span><br><span class="line">        <span class="comment">// 查找每个轮廓的方向</span></span><br><span class="line">        <span class="built_in">getOrientation</span>(contours[i], src);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! [contours]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;output&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下还有pca.cpp,   lbph.cpp,   fisherface.cpp,   lda.cpp;   </p><h1 id="PCA源码分析"><a href="#PCA源码分析" class="headerlink" title="PCA源码分析"></a>PCA源码分析</h1><p>其实就是设置了一堆的变量,   然后调用别的函数算出协方差矩阵,   再求出特征值和特征向量;   只不过在主成分数量的选取上,   进行了些许甄别;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据矩阵, 均值矩阵, 行列向量标识, 保留的最大主成分数</span></span><br><span class="line">    PCA &amp;PCA::operator()(InputArray _data, InputArray __mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> maxComponents) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据矩阵与均值矩阵</span></span><br><span class="line">        Mat data = _data.getMat(), _mean = __mean.getMat();</span><br><span class="line">        <span class="keyword">int</span> covar_flags = CV_COVAR_SCALE;</span><br><span class="line">        <span class="keyword">int</span> len, in_count;</span><br><span class="line">        Size mean_sz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断通道是否为1个</span></span><br><span class="line">        CV_Assert(data.channels() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果输入的矩阵为列矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; CV_PCA_DATA_AS_COL) &#123;</span><br><span class="line">            len = data.rows;</span><br><span class="line">            in_count = data.cols;</span><br><span class="line">            covar_flags |= CV_COVAR_COLS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 均值向量规模为(1, len)</span></span><br><span class="line">            mean_sz = Size(<span class="number">1</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果数据矩阵为行矩阵(一般都为行矩阵)</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取数据维度</span></span><br><span class="line">            len = data.cols;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取样本量</span></span><br><span class="line">            in_count = data.rows;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置数据矩阵为行向量形式</span></span><br><span class="line">            covar_flags |= CV_COVAR_ROWS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 均值向量的规模为(len, 1), 也就是len行1列, len为数据维度</span></span><br><span class="line">            mean_sz = Size(len, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据维度和样本量之间的较小值, 其实下面这几行都是为了确定主成分数</span></span><br><span class="line">        <span class="keyword">int</span> count = std::min(len, in_count), out_count = count;</span><br><span class="line">        <span class="comment">// 防止最大主成分数超过maxComponents</span></span><br><span class="line">        <span class="keyword">if</span> (maxComponents &gt; <span class="number">0</span>)</span><br><span class="line">            out_count = std::min(count, maxComponents);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &quot;scrambled&quot; way to compute PCA (when cols(A)&gt;rows(A)):</span></span><br><span class="line">        <span class="comment">// B = A&#x27;A; B*x=b*x; C = AA&#x27;; C*y=c*y -&gt; AA&#x27;*y=c*y -&gt; A&#x27;A*(A&#x27;*y)=c*(A&#x27;*y) -&gt; c = b, x=A&#x27;*y</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据维度len超过样本量in_count, 则使用CV_COVAR_NORMAL, 否则则使用CV_COVAR_SCRAMBLED</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= in_count)</span><br><span class="line">            covar_flags |= CV_COVAR_NORMAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置显示范围的精度, 如果大于浮点数精度, 则使用原数据矩阵的精度</span></span><br><span class="line">        <span class="comment">// 实际上比CV_32F大的就只有CV_64F了; 所以这里应该是如果数据矩阵使用64位精度, 则ctype保留原精度</span></span><br><span class="line">        <span class="comment">// 否则统一使用CV_32F;</span></span><br><span class="line">        <span class="keyword">int</span> ctype = std::max(CV_32F, data.depth());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建均值数组</span></span><br><span class="line">        mean.create(mean_sz, ctype);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建协方差数组, 规模为(count, count) count为数据维度与样本量中的较小值</span></span><br><span class="line">        <span class="comment">// 精度类型与数据矩阵的精度一致</span></span><br><span class="line">        <span class="function">Mat <span class="title">covar</span><span class="params">(count, count, ctype)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果_mean不为空, 则使用_mean作为均值向量, 并设置其标志位;</span></span><br><span class="line">        <span class="keyword">if</span> (!_mean.empty()) &#123;</span><br><span class="line">            CV_Assert(_mean.size() == mean_sz);</span><br><span class="line">            _mean.convertTo(mean, ctype);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cv::CalcCovarMatrix的标志，不计算即均值向量, 改用输入向量(用于按部分计算协方差矩阵)</span></span><br><span class="line">            covar_flags |= CV_COVAR_USE_AVG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算协方差矩阵</span></span><br><span class="line">        <span class="comment">// 结果保存在covar中, 写OpenCV就喜欢这么搞, 就是不喜欢函数有返回值捏</span></span><br><span class="line">        calcCovarMatrix(data, covar, mean, covar_flags, ctype);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算协方差矩阵的特征值和特征向量</span></span><br><span class="line">        eigen(covar, eigenvalues, eigenvectors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有采用CV_COVAR_NORMAL形式来计算的协方差(就是采用CV_COVAR_SCRAMBLED形式)</span></span><br><span class="line">        <span class="keyword">if</span> (!(covar_flags &amp; CV_COVAR_NORMAL)) &#123;</span><br><span class="line">            <span class="comment">// CV_PCA_DATA_AS_ROW: cols(A)&gt;rows(A). x=A&#x27;*y -&gt; x&#x27;=y&#x27;*A</span></span><br><span class="line">            <span class="comment">// CV_PCA_DATA_AS_COL: rows(A)&gt;cols(A). x=A&#x27;&#x27;*y -&gt; x&#x27;=y&#x27;*A&#x27;</span></span><br><span class="line">            Mat tmp_data, tmp_mean = repeat(mean, data.rows / mean.rows, data.cols / mean.cols);</span><br><span class="line">            <span class="keyword">if</span> (data.type() != ctype || tmp_mean.data == mean.data) &#123;</span><br><span class="line">                data.convertTo(tmp_data, ctype);</span><br><span class="line">                subtract(tmp_data, tmp_mean, tmp_data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                subtract(data, tmp_mean, tmp_mean);</span><br><span class="line">                tmp_data = tmp_mean;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">Mat <span class="title">evects1</span><span class="params">(count, len, ctype)</span></span>;</span><br><span class="line">            gemm(eigenvectors, tmp_data, <span class="number">1</span>, Mat(), <span class="number">0</span>, evects1,</span><br><span class="line">                 (flags &amp; CV_PCA_DATA_AS_COL) ? CV_GEMM_B_T : <span class="number">0</span>);</span><br><span class="line">            eigenvectors = evects1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// normalize eigenvectors</span></span><br><span class="line">            <span class="comment">// 特征向量的归一化</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; out_count; i++) &#123;</span><br><span class="line">                Mat vec = eigenvectors.row(i);</span><br><span class="line">                normalize(vec, vec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据维度count超过主成分数量out_count, 则取前out_count个特征向量和特征值</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; out_count) &#123;</span><br><span class="line">            <span class="comment">// use clone() to physically copy the data and thus deallocate the original matrices</span></span><br><span class="line">            eigenvalues = eigenvalues.rowRange(<span class="number">0</span>, out_count).clone();</span><br><span class="line">            eigenvectors = eigenvectors.rowRange(<span class="number">0</span>, out_count).clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在PCA中,   协方差矩阵的计算公式如下。注意在这个计算公式中，矩阵的转置运算符被放到了第一个矩阵之上，对于同样的n * m矩阵，计算得到的是尺寸为m * m协方差矩阵。在一些特定场景下，如对向量元素较长的样本数据计算快速主成分分析(PCA)时会使用这种技术，一个应用实例就是人脸识别的特征脸算法。</p><img src="D:/Program%20Files/Typora/img/image-20230301212821018.png" alt="image-20230301212821018" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/webp.webp" alt="img" style="zoom: 67%;" /><p>在core.cpp中,   在对于n行 * m列的输入样本矩阵而言，当设置<code>cv::COVAR_SCALE</code>时，计算的协方差矩阵会被缩放，缩放系数等于1.0/m，但是当<code>cv::COVAR_SCRAMBLED</code>被启用时，缩放系数则等于1.0/n，可以理解为1/单组随机变量个长度。</p><p>该函数的输入输出函数中元素的基本数据类型都应该是相同的浮点数类型，协方差矩阵的尺寸根据选择的是标准<code>cv::COVAR_NORMAL</code>还是反转<code>cv::COVAR_SCRAMBLED</code>的计算策略相应为n * n和m * m。</p><p>而cv::calcCovarMatrix函数中的flags,   其实是一种类似于位图的用法,   flags为int类型,   而其他的枚举类像CV_COVAR_ROWS、CV_COVAR_USE_AVG等等,   应该都是int类型;   当需要某一个参数的时候,   只需要让flags同对应的枚举类相与,   即可保留这一信息,   而传递到cv::calcCovarMatrix函数中后,   就可以通过将flags的对应位同相应的枚举类相与,   即可获取对应的信息;   </p><p>在matmul.dispatch.cpp中包含cv::calcCovarMatrix函数的实现,   </p><img src="D:/Program%20Files/Typora/img/image-20230303184317695.png" alt="image-20230303184317695" style="zoom:80%;" /><p>如果使用normal来进行协方差矩阵的计算<br>$$<br>\sum^{2}_{NORMAL}=</p><p>z<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{0,   1}&amp;v_{0,   2}&amp;…&amp; v_{0,   n}\<br>v_{1,   0}&amp;v_{1,   1}&amp;v_{1,   2}&amp;…&amp; v_{1,   n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{m,   0}&amp;v_{m,   1}&amp;v_{m,   2}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]</p><p>*<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{0,   1}&amp;v_{0,   2}&amp;…&amp; v_{0,   n}\<br>v_{1,   0}&amp;v_{1,   1}&amp;v_{1,   2}&amp;…&amp; v_{1,   n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{m,   0}&amp;v_{m,   1}&amp;v_{m,   2}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]^T<br>$$</p><p>$$<br>\begin{align*}<br>&amp;aTa=true,   使用MulTransposedR,   矩阵的转置乘原矩阵\\<br>&amp;\sum^{2}_{NORMAL}=</p><p>z<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{1,   0}&amp;v_{2,   0}&amp;…&amp; v_{m,   0}\<br>v_{0,   1}&amp;v_{1,   1}&amp;v_{2,   1}&amp;…&amp; v_{m,   1}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{0,   n}&amp;v_{1,   n}&amp;v_{2,   n}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]</p><p>*<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{0,   1}&amp;v_{0,   2}&amp;…&amp; v_{0,   n}\<br>v_{1,   0}&amp;v_{1,   1}&amp;v_{1,   2}&amp;…&amp; v_{1,   n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{m,   0}&amp;v_{m,   1}&amp;v_{m,   2}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]\\</p><p>&amp;(n * m) * (m * n)\\<br>&amp;从代码层面表现出来就是原矩阵的列乘列,   \<br>&amp;比如,   第一列<em>第一列=第一个元素<br>\end{align</em>}<br>$$</p><p>$$<br>\begin{align*}<br>&amp;aTa=false,   使用MulTransposedL,   原矩阵乘矩阵的转置\\<br>&amp;\sum^{2}_{NORMAL}=</p><p>z<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{0,   1}&amp;v_{0,   2}&amp;…&amp; v_{0,   n}\<br>v_{1,   0}&amp;v_{1,   1}&amp;v_{1,   2}&amp;…&amp; v_{1,   n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{m,   0}&amp;v_{m,   1}&amp;v_{m,   2}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]</p><p>*<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{1,   0}&amp;v_{2,   0}&amp;…&amp; v_{m,   0}\<br>v_{0,   1}&amp;v_{1,   1}&amp;v_{2,   1}&amp;…&amp; v_{m,   1}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{0,   n}&amp;v_{1,   n}&amp;v_{2,   n}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]\\</p><p>&amp;(m * n)    *    (n * m)\\<br>&amp; 从代码层面表现出来就是原矩阵的行乘行,   \<br>&amp;比如,   第一行<em>第一行=第一个元素<br>\end{align</em>}<br>$$</p><img src="D:/Program%20Files/Typora/img/image-20230303193809910.png" alt="image-20230303193809910" style="zoom:80%;" /><p>如果aTa为真, 则使用MulTransposedR, 也就是矩阵的转置乘原矩阵<br>如果aTa为假, 则使用MulTransposedL, 也就是原矩阵乘矩阵的转置</p><p>MulTransposedR的乘积方式为<img src="D:/Program%20Files/Typora/img/image-20230303201848970.png" alt="image-20230303201848970" style="zoom:80%;" /></p><hr><p>到此为止总算是把pca.cpp的核心代码及其依赖函数分析完了,   剩下就是填写整体流程,   以及分析SIMD的优点了;   哦对了,   还有gemm的分析,   为啥100之后它要快一点呀?</p><p>找到了gemm32fc的实现！在F:\java\MStudy\opencv\sources\modules\core\src\matmul.simd.hpp里</p><p>防止越界的操作:   由于是4个4个的读取,   而且指针是指向4个元素的头元素的,   如果矩阵列数不为4的倍数,   则当j当达最后一个4元素模块的时候,   就会发生越界,   所以在最初的循环中,   要减掉元素矩阵的个数要减掉4,   然后另起一个循环处理最后的几个元素;   </p><h2 id="gemm分析"><a href="#gemm分析" class="headerlink" title="gemm分析"></a>gemm分析</h2><p>void gemm(InputArray matA, InputArray matB, double alpha, InputArray matC,<br>                     double beta, OutputArray _matD, int flags)</p><p>alpha为缩放尺度,   beta为src3的权重,   flags为对哪个矩阵进行转置(矩阵有matA,   matB和matC)</p><img src="D:/Program%20Files/Typora/img/image-20230304153828782.png" alt="image-20230304153828782" style="zoom:80%;" /><p>假设我们已经得到了协方差矩阵$C$，其奇异值分解为： $$ C = U \Sigma V^T $$ 其中，$U$和$V$是正交矩阵，$\Sigma$是一个对角矩阵，其对角线上的元素称为奇异值。 由于协方差矩阵是实对称矩阵，因此它的特征向量可以通过奇异值分解来计算。具体地说，我们可以使用以下公式来计算协方差矩阵的特征向量： $$ \mathbf{v}_i = \frac{1}{\sqrt{n-1}\sigma_i} C \mathbf{u}_i $$ 其中，$\mathbf{u}_i$和$\mathbf{v}_i$分别是奇异值分解中左奇异向量和右奇异向量的第$i$列，$\sigma_i$是$\Sigma$中第$i$个奇异值。 需要注意的是，在实际应用中，我们通常会对奇异值进行截断或者使用增量SVD等技术来加速计算过程，并且可以处理大型或高维数据集。</p><p>特征值分解法是另一种常用的方法来获取协方差矩阵的特征向量。假设我们已经得到了协方差矩阵$C$，其特征值分解为： $$ C = Q \Lambda Q^{-1} $$ 其中，$Q$是特征向量组成的正交矩阵，$\Lambda$是对角矩阵，其对角线上的元素为特征值。 由于协方差矩阵是实对称矩阵，因此它的特征向量可以通过特征值分解来计算。具体地说，我们可以使用以下公式来计算协方差矩阵的特征向量： $$ \mathbf{v}_i = Q \mathbf{e}_i $$ 其中，$\mathbf{e}_i$是单位向量，表示第$i$个特征值所对应的方向。 特征值分解法获取协方差矩阵的时间复杂度主要取决于求解特征值和特征向量的算法。一般而言，使用传统方法（如幂迭代、QR迭代等）求解特征值和特征向量的时间复杂度为$O(n^3)$。但是，在实际应用中，我们通常会使用更高效的算法（如雅可比迭代、Lanczos迭代等）来加速计算过程，并且可以处理大型或高维数据集。这些算法的时间复杂度通常为$O(kn^2)$或更低，其中$k$是特征值的数量。</p><p>传统的方法求解特征值和特征向量的时间复杂度为$O(n^3)$，主要是因为这些方法需要进行矩阵乘法和矩阵-向量乘法等基本运算，而这些运算的时间复杂度都是$O(n^2)$。因此，对于一个$n \times n$的矩阵，传统的方法需要进行$n$次迭代，每次迭代都需要进行一次矩阵乘法和一次矩阵-向量乘法，因此总的时间复杂度为$O(n^3)$。 具体来说，传统的方法包括幂迭代、QR迭代等。其中，幂迭代是最简单、最直观的求解特征值和特征向量的方法之一。它通过不断地对一个初始向量进行矩阵乘法和归一化操作来逼近协方差矩阵的最大特征值和对应的特征向量。但是，幂迭代只能求解最大特征值和对应的特征向量，并且收敛速度较慢。 QR迭代是另一种常用的求解特征值和特征向量的方法。它通过将协方差矩阵分解为正交矩阵$Q$和上三角矩阵$R$的乘积来逼近协方差矩阵的所有特征值和对应的特征向量。QR迭代可以同时求解所有特征值和特征向量，并且收敛速度较快。但是，QR迭代的计算复杂度较高，主要是因为每次迭代都需要进行一次QR分解，其时间复杂度为$O(n^3)$。</p><p>JacobiSVD类的时间复杂度主要取决于矩阵的大小和精度要求。具体来说，对于一个$m \times n$的实数或复数矩阵，JacobiSVD类的时间复杂度为$O(\min(mn^2, m^2n))$。</p><p>具体来说，对于一个$m \times n$的实数或复数矩阵，JacobiSVD类的时间复杂度为$O(\min(mn^2, m^2n))$。其中，当$m \geq n$时，JacobiSVD类的时间复杂度为$O(mn^2)$；当$m &lt; n$时，JacobiSVD类的时间复杂度为$O(m^2n)$。</p><blockquote><p>所谓奇异值求解特征向量，就是在归一化之后，不断地调整这个超平面，依据所有的点到这个超平面的距离平方和大小进行排序，该距离平方和就是特征值，而距离平方和对应的基就是特征向量。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PCA&quot;&gt;&lt;a href=&quot;#PCA&quot; class=&quot;headerlink&quot; title=&quot;PCA&quot;&gt;&lt;/a&gt;PCA&lt;/h1&gt;&lt;h2 id=&quot;PCA解析1&quot;&gt;&lt;a href=&quot;#PCA解析1&quot; class=&quot;headerlink&quot; title=&quot;PCA解析1&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>资料003</title>
    <link href="http://example.com/2023/04/26/gong-wu-yuan-kao-shi/wu-shi-ji-chu/3-zi-liao-003/"/>
    <id>http://example.com/2023/04/26/gong-wu-yuan-kao-shi/wu-shi-ji-chu/3-zi-liao-003/</id>
    <published>2023-04-26T02:16:52.000Z</published>
    <updated>2023-04-26T03:05:36.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料3"><a href="#资料3" class="headerlink" title="资料3"></a>资料3</h1><h2 id="比重"><a href="#比重" class="headerlink" title="比重"></a>比重</h2><p>题型识别:   A占B的比重;   在B中,   A所占的比重;   </p><blockquote><p>增长贡献率=$\frac{部分增长量}{整体增长量}$</p><p>利润率:   资料分析中,   利润率=$\frac{利润}{收入}$,   数量关系中,   利润率=$\frac{利润}{成本}$;   因为资料分析分析的通常是一个整体的利润,   所以不可能获得对应的成本,   需要使用利润除以收入,   而数量关系中,   常常指某一间具体的店,   所以可以得知成本,   使用利润除以成本;   </p><p>A对B的贡献率:   A占B的比重;   </p></blockquote><h2 id="基期比重"><a href="#基期比重" class="headerlink" title="基期比重"></a>基期比重</h2><p>题型识别:   给定一个年份/月份,   问这个年份/月份的前一个年份/月份的占比或比重;   </p><p>计算公式:   $\frac AB*\frac{1+b}{1+a}$;   </p><p>其中A为部分的现期量,   B为总体的现期量,   a为部分的增长率,   b为总体的增长率;   </p><blockquote><p>速算技巧</p><ol><li>先判断$\frac{1+b}{1+a}$与1的关系;   </li><li>根据选项差距截位直除$\frac AB$;   </li><li>结合选项;   </li></ol><p>由于给定了现期比重$\frac AB$,   所以要求的基期比重$\frac AB*\frac{1+b}{1+a}$和现期比重的差别就在于$\frac{1+b}{1+a}$上面;   </p><p>对于第一步,   其实就是判断b和a谁大,   就可以判断出$\frac{1+b}{1+a}$与1的关系;   </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;资料3&quot;&gt;&lt;a href=&quot;#资料3&quot; class=&quot;headerlink&quot; title=&quot;资料3&quot;&gt;&lt;/a&gt;资料3&lt;/h1&gt;&lt;h2 id=&quot;比重&quot;&gt;&lt;a href=&quot;#比重&quot; class=&quot;headerlink&quot; title=&quot;比重&quot;&gt;&lt;/a&gt;比重&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Q012_行测_数资1</title>
    <link href="http://example.com/2023/04/24/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q012-xing-ce-shu-zi-1/"/>
    <id>http://example.com/2023/04/24/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q012-xing-ce-shu-zi-1/</id>
    <published>2023-04-24T00:47:18.000Z</published>
    <updated>2023-04-26T01:57:52.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数资1"><a href="#数资1" class="headerlink" title="数资1"></a>数资1</h1><h3 id="混合增长率"><a href="#混合增长率" class="headerlink" title="混合增长率"></a>混合增长率</h3><p>识别:   部分与总体的增长率关系</p><p>固定搭配类:   进口+出口=进出口,   房产+地产=房地产,   邮政+电信=邮电<br>时间类:   上半年+下半年=全年,   第一季度+第二季度=上半年<br>逻辑类:   税收+非税收=总收入,   户籍+非户籍=总人口</p><p>判断口诀:   (1) 总体增速:   居中但不中(最小r&lt;总体&lt;最大r)     (2) 偏向基期量大的那个(哪部分基期量大,   总体增速就接近谁,   但是一般用现期量代替)</p><h3 id="两期比重升降判断"><a href="#两期比重升降判断" class="headerlink" title="两期比重升降判断"></a>两期比重升降判断</h3><p>识别:   两个时间+比重</p><p>判断方法:   $比重=\frac{部分(A)}{总体(B)}$,   </p><p>a&gt;b,   现期比&gt;基期比,   比重上升;   a&lt;b,   现期比&lt;基期比,   比重下降;   a=b,   现期比=基期比,   比重不变;   a和b指的分别是部分的增长率和总体的增长率;   </p><blockquote><p>这个应该带正负号进行计算;   而且注意,   两期平均比较和两期比重比较的结论是一样的,   只需要找准除式的分子分母,   是谁除谁,   就可以确定a和b,   然后通过比较a和b,   就可以得知,   现期和基期谁更大了;   </p></blockquote><h3 id="平均数增长率"><a href="#平均数增长率" class="headerlink" title="平均数增长率"></a>平均数增长率</h3><p>识别:   平均数+增长了…%</p><p>公式:   $r=\frac{a-b}{1+b}$,   a是分子的增长率,   b是分母的增长率;   </p><h3 id="比重求倍数"><a href="#比重求倍数" class="headerlink" title="比重求倍数"></a>比重求倍数</h3><p>要注意”是…的几倍”,   “比…多…几倍”;   </p><p>基期倍数问题—$\frac{A}{B}\frac{1+b}{1+a}$,   A和B分别是现期量,   a和b分别是增长率;   </p><p>当总体相同时,   部分数之间的倍数可以用部分量的占比来求,   但是挖坑的点可能在于时间!</p><blockquote><p>A与-A的倍数问题,   只需要拿到A与-A的占比一除就行,   而如果只有一个时间,   则出题人会在年份上做手脚,   如果有多个时间,   就是图表类的题目,   一般就是给定占比,   判断A与-A的倍数大于多少的年份有几个,   这样的题目一般解题思路—求A与-A的倍数大于X的年份数量,   A占$\frac{X}{1+X}$,   -A占$\frac{1}{1+X}$,   如果题目图表给的是A的占比,   则直接看A的占比大于$\frac{X}{1+X}$的年份,   进行统计即可;   </p></blockquote><h3 id="多年份增长率大于某个占比"><a href="#多年份增长率大于某个占比" class="headerlink" title="多年份增长率大于某个占比"></a>多年份增长率大于某个占比</h3><p>由于$\frac{现期量-基期量}{基期量}&gt;x%$,   所以可以进行公式变形,   也就是$现期量&gt;基期量(1+x%)$,   或者$现期量-基期量&gt;基期量(1+x%)$;   </p><p>而如果没有给基期量,   而是增长量,   则$\frac{增长量}{现期量-增长量}&gt;x%$,   进行公式变形之后就是$增长量&gt;(现期量-增长量)x%$,   一般如果给的是增长量,   则x=100,   所以可以变形为$增长量*2&gt;现期量$;   </p><h3 id="年均增长量"><a href="#年均增长量" class="headerlink" title="年均增长量"></a>年均增长量</h3><p>识别:   时间段+年均增长+单位</p><p>计算公式:   $年均增长量=\frac{总增长量}{年份差}=\frac{现期量-基期量}{年份差}$</p><h3 id="年均增长率"><a href="#年均增长率" class="headerlink" title="年均增长率"></a>年均增长率</h3><p>识别:   年均增长最快,   年均增速排序,   年均增长率为…</p><p>计算公式:   $(1+r)^n=\frac{现期量}{基期量}$,   要注意这个公式说明的是,   $\frac{现期量}{基期量}$越大,   年均增长率越大;   当然,   通过公式变形之后,   也可以得出$\frac{增长量}{现期量}$越大,   年均增长率越大;   </p><h3 id="多步除法"><a href="#多步除法" class="headerlink" title="多步除法"></a>多步除法</h3><p>看选项,   选项差距大截两位,   差距小截三位,   然后直接<font color='red'><strong>约分</strong></font>;   </p><blockquote><p>只要出现那种高低区分度的,   也就是四个选项两个升两个降,   则把式子列出来之后,   </p></blockquote><h3 id="基期倍数"><a href="#基期倍数" class="headerlink" title="基期倍数"></a>基期倍数</h3><p>$增长率=是几倍-1$</p><p>如果一道题求两个基期量的增长率,   就可以转化为基期倍数-1,   而$ 基期倍数=\frac{A}{B}\frac{1+b}{1+a}$,   </p><h3 id="折线题"><a href="#折线题" class="headerlink" title="折线题"></a>折线题</h3><p>找最值,   有可能题目给的几个月份有些值是正的,   有些是负的,   如果从正到负的话,   则折线图为向下的直线;   </p><p>增长率的比较—直接比较$\frac{现期}{基期}$的大小;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数资1&quot;&gt;&lt;a href=&quot;#数资1&quot; class=&quot;headerlink&quot; title=&quot;数资1&quot;&gt;&lt;/a&gt;数资1&lt;/h1&gt;&lt;h3 id=&quot;混合增长率&quot;&gt;&lt;a href=&quot;#混合增长率&quot; class=&quot;headerlink&quot; title=&quot;混合增长率&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q998_申论_积累卡</title>
    <link href="http://example.com/2023/04/22/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q998-shen-lun-ji-lei-qia/"/>
    <id>http://example.com/2023/04/22/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q998-shen-lun-ji-lei-qia/</id>
    <published>2023-04-22T06:11:59.000Z</published>
    <updated>2023-04-26T08:24:13.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="申论积累"><a href="#申论积累" class="headerlink" title="申论积累"></a>申论积累</h1><p>“乡贤理事会”对这样的村民不厌其烦地摆事实、讲道理，说服教育取得了不错的效果—开展说服教育;   </p><p>哪些人负责干啥很清楚，我们有啥需要总有人管—有组织,   有秩序;   </p><p>更需要我们从宏观的制度设计层面做出努力…—进行宏观设计</p><p>高校人才并没有体现出专业优势—专业人才匮乏,   高校专业设置与岗位需求脱节—引导高校加强调研、结合市场需求优化课程设置，组织从业者参与知识技能培训，提高…能力；</p><p>…过程中，操作大都不太符合规范。—规范…设备使用，加强作业培训</p><p>只要没人投诉举报我们，就基本不会被发现—查处违规企业依赖投诉举报—畅通监督反馈渠道，提高处罚力度。</p><p>有司法、仲裁、调解等6大类70余家机构入驻前海—引进法律机构!</p><p>享受社保,   申请保障房和补贴等等—完善公共服务! </p><p>一味地向城市看齐，误以为乡村建设就是把乡村与城市建设的一模一样—乡村建设与城市趋同，失去乡村固有特色。</p><p>因此，关键是得把这个人放到他适合的那个位置上，他才能发挥作用，否则就失去意义了。目前为止，这方面还做的不够好。”—对乡贤的定位以及人岗匹配不尽合理。</p><p>部分干部、群众为了享受国家优惠政策，不愿脱贫，不愿摘帽—个别干部和群众存在“等，靠，要”等不良思想倾向，以来国家政策，不肯摘帽。</p><p>“换过好几次”、“人本来就不多”    “只能处理一些小打小闹”“大事儿根本解决不了”—    …队伍不稳定,   处理问题经验和能力不足;   </p><p>将本职工作外包给他人，则是在客观上为交管部门的懒惰提供了方便—将本职工作外包助长懒政行为;   </p><p>我们老百姓肯定会不服气的，长此以往，又怎么得到群众的认可—降低政府公信力;   </p><p>你看看，其他镇既引进了新品种，又大力推广机械化，生产、收割效率比我们高多少！—改良品种,   推广机械化生产,   增加收益;   </p><p>一些村干部并不理会我们的想法，也故意不采纳我们的意见—有抵触心理,   支持不足;   </p><p>现在不少学者似乎缺少一种使命感,   部分电视台和网站没有承担起行业责任。—<strong>部分学者、媒体缺乏使命感和责任感</strong>;   </p><p>最起码得把那些没真本事的人拦在门外，不然不就成了…—平台要加强管理,   设立准入门槛,   核实回答者资质;   </p><p>“用户可以起到监督的作用，在主讲人不遵守条款时有选择离开的权利”—<strong>建立服务约束条款，赋予用户监督、退出权利</strong>;   </p><p>这些车都是厂家生产出来租给别人，我觉得这些都不是真正的‘共享’，更应该叫做租赁经济。—共享概念被泛化;   </p><p>一旦取消这种物质利益刺激，公众很有可能对交通违法行为采取‘睁一只眼闭一只眼—<strong>暂时的物质利益刺激会适得其反，降低公众参与社会治理的积极性、主动性</strong>。</p><p>扑进眼帘的都是多角恋、戏谑历史之类的东西—选材低俗;   </p><p>媒体的价值观决定了观众的价值观,   把人不好的欲望刺激起来…—媒体价值取向不正确;   </p><p>当时看也觉得很有意思，回家合计合计好像又什么都没有留下—输出内容缺少内涵;   </p><p>“案件审核完全是人工操作”“我们需要花不少时间仔细核对图片和视频里的信息”“这些工作相应的开支可是不小的数字呐—审核工作导致行政执法成本增加;   </p><p>给予园长王某记过处分，对教师郭某和周某给予开除处理—依法追究责任;   </p><p>只考虑钱，不考虑风险，也不做战略规划—企业过分看重利益，缺乏风险意识和战略规划;   </p><p>不是因为自己真的需要，而是想要炫耀—存在从众,   炫耀性消费心理。部分消费者缺失理性判断能力…</p><p>“国内众多承载着70、80后甚至90后人群记忆的‘老字号’纷纷回归”，说明“老字号”品牌能够承载过去的记忆，可概括为：<strong>承载记忆。</strong></p><p>“整合……设立了‘说事厅’……”—整合场地资源;   </p><p>“安装了固定电话……设置意见箱……”—畅通说事渠道;   </p><p>“不是嫌劳动强度大，就是嫌工资低不肯来”，说明村民就业心态存在问题，缺少职业素养，不愿意从事累活，较为懒惰，并且眼高手低，高不成低不就，没有工作导致贫困—<strong>职业素养差，缺少吃苦耐劳精神，好高骛远，自主脱贫积极性差</strong>。</p><p>“牵头成立了吉隆田农产品产销专业合作社，先后搭建起17座大棚种植草莓”—建大棚发展现代绿色环保生态农业。</p><p>找了200个非常靠谱的人—聚集人才;   非常多的合作机会—加强合作;   </p><p>巡查就像‘找茬’游戏一样，路况有一点变化就得第一时间发现—及时排除道路交通隐患;   </p><p>谢阿姨调解室’应运而生，调解矛盾纠纷,   作为社区社会组织的‘V益联盟’，组织了‘V益案’PK—鼓励居民自我组织自我服务;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;申论积累&quot;&gt;&lt;a href=&quot;#申论积累&quot; class=&quot;headerlink&quot; title=&quot;申论积累&quot;&gt;&lt;/a&gt;申论积累&lt;/h1&gt;&lt;p&gt;“乡贤理事会”对这样的村民不厌其烦地摆事实、讲道理，说服教育取得了不错的效果—开展说服教育;   &lt;/p&gt;
&lt;p&gt;哪些人负责</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q011_行测_言语4</title>
    <link href="http://example.com/2023/04/22/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q011-xing-ce-yan-yu-4/"/>
    <id>http://example.com/2023/04/22/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q011-xing-ce-yan-yu-4/</id>
    <published>2023-04-22T02:05:07.000Z</published>
    <updated>2023-04-23T02:51:23.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="言语4"><a href="#言语4" class="headerlink" title="言语4"></a>言语4</h1><blockquote><p>并行不悖:   两者看似不同/对立,   但是可以共存,   可以并驾齐驱;   </p><p>傍人门户:   依赖别人,   不能自立;   </p><p>邯郸学步:   一味模仿别人,   不仅没学到本事,   反而把自己的本事丢了;   </p><p>穿凿附会:   不相干的道理/事情硬扯到一起;   </p><p>亦步亦趋:   事事模仿或追随别人;   </p><blockquote><p>模仿别人的词语<br>人云亦云—说话没主见,   随声附和<br>亦步亦趋—行为没主见<br>邯郸学步—丢掉原来的本领<br>东施效颦—出丑</p></blockquote><p>如鱼得水:   遇到与自己十分契合的人或环境;   </p><p>屡见不鲜:   多次见到不觉奇怪;   </p><p>异军突起:   中性词,   不同的派别或力量一下子崛起;   </p><p>崭露头角:   初显才能,   一般指年轻人;   </p><p>雨后春笋:   新生事物大量涌现;   </p><p>一举多得:   一种举动兼收多利,   一般要三方面以上;   </p><p>两全其美:   兼顾两方的利益,   注意主题是两个主体的利益;   而不是在两个方面获利;   </p><p>公私兼顾:   既照顾到公家的利益,   又照顾到私人的利益;   </p><blockquote><p>寸步难行:   行走困难,   比喻处境艰难窘困<br>步履艰难:   指走路困难,   行动不便<br>艰难跋涉:   强调路程的艰苦<br>举步维艰:   形容处境或行动十分艰难</p></blockquote><blockquote><p>墨守成规:   固守旧规矩不肯改变,   侧重规矩制度<br>画地为牢:   只许在指定的范围内活动,   侧重于有一定的范围界限<br>抱残守缺:   思想守旧,   不知变革<br>固步自封:   安于现状,   不求改善</p></blockquote><blockquote><p>符合—符合事实/标准<br>契合—感情契合<br>贴合—贴合皮肤<br>切合—切合实际(但我感觉契合实际也可以)</p></blockquote><p>徒劳无功:   工作没有成效;   </p><p>劳民伤财:   滥用人力财力;   </p><p>覆水难收:   已成定局,   无法挽回;   </p><p>木已成舟:   同上(但是要注意形象化表达);   </p><p>尾大不掉:   比喻部下力量太强大,   不易指挥和调度;   </p><blockquote><p>蜻蜓点水:   做事肤浅不深入<br>走马观花:   侧重于观光游览观察不细致<br>浮光掠影:   侧重于影响不深刻<br>浅尝辄止:   多用于学问,   研究领域</p></blockquote><p>捉襟见肘:   顾此失彼,   应付不过来</p><blockquote><p>曲高和寡:   言论和艺术不同俗,   很少人能懂<br>阳春白雪:   高深不通俗的文艺作品</p></blockquote></blockquote><h2 id="并列对应"><a href="#并列对应" class="headerlink" title="并列对应"></a>并列对应</h2><p>三方并列可能从三个不同的角度进行说明(高,   富,   帅),   也可能是重要的事情说三遍,   也有可能是事情发展先后顺序(相识相知相爱)</p><h2 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h2><h3 id="解释类对应"><a href="#解释类对应" class="headerlink" title="解释类对应"></a>解释类对应</h3><p>是,   就是,   无异于,   比如,   无疑是…,   冒号”:   “,   破折号”—“;   </p><blockquote><p>两面词,   如果出现了所谓的”双方力量”之类的描述,   则要选择两面词:   </p><p>主次:   舍本逐末,   本末倒置,   反客为主,   喧宾夺主,   小题大做,   买椟还珠,   因小失大;   </p><p>新旧:   推陈出新,   革故鼎新,   弃旧图新,   破旧立新,   吐故纳新;   </p><p>好坏:   去芜存菁(jīng),   去粗取精,   激浊扬清,   惩恶扬善;   </p></blockquote><h3 id="重点词句对应"><a href="#重点词句对应" class="headerlink" title="重点词句对应"></a>重点词句对应</h3><p>重点词:   指代词,   主题词,   形象化表达<br>重点句:   完整语句,   前后呼应</p><blockquote><p>形象化表达!!</p><p>水—长河,   大潮,   洪流—不随波逐流急于进入市场大潮,   在研究热潮中国内外已呈现千帆竞发的局面,   在历史的长河中乘风破浪,   在历史的洪流中屹立不倒,   挺立潮头;   </p><p>路—道路,   赛道,   路口—就像到了岔路口不光是分道扬镳,   走捷径不等于另辟蹊径,   通过”直道冲刺” “弯道超车”走好复兴之路,   重庆甘肃也被视为弯道超车的新赛道;   </p><p>基因—与生俱来,   代代相传<br>因子—渗透<br>线—贯穿<br>火—付之一炬<br>稀释—减轻,   减弱</p></blockquote><blockquote><p>要注意”在一定背景之下出现一个新东西”,   选应运而生</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;言语4&quot;&gt;&lt;a href=&quot;#言语4&quot; class=&quot;headerlink&quot; title=&quot;言语4&quot;&gt;&lt;/a&gt;言语4&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;并行不悖:   两者看似不同/对立,   但是可以共存,   可以并驾齐驱;   &lt;/p&gt;
&lt;p&gt;傍人门户</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q999_申论_答题卡</title>
    <link href="http://example.com/2023/04/20/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q999-shen-lun-da-ti-qia/"/>
    <id>http://example.com/2023/04/20/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q999-shen-lun-da-ti-qia/</id>
    <published>2023-04-20T07:30:43.000Z</published>
    <updated>2023-04-26T08:24:17.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答题卡"><a href="#答题卡" class="headerlink" title="答题卡"></a>答题卡</h1><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><ol><li>用户担心个人信息安全;   信息分计算方式(<font color='red'>算法不公开</font>)不透明,   难以保证数据安全<font color='red'>数据缺乏公信力</font>;   (<font color='red'>这应该算是两个点,   一是分数不透明,   二是信息不安全</font>)</li><li>难以保证公平性;   一些企业既有基础数据,   又有借贷业务,   在业务上不具有第三方独立性;   </li><li>法律界定不明晰;   试点机构采用线上收集,   现有法律未能明晰个人生活细节;   (<font color='red'>哪些该纳入哪些不该纳入指的是信息采集内容,   范围,   边界没有明确的法律约束</font>)</li><li><font color='red'>从芝麻信用和腾讯征信可以看出:   征信标准不统一;   各自平台各自为战,   根据自身要求收集信息,   缺乏统一标准;   </font></li></ol><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><ol><li><p>政策限制条件严格;   政策不接地气,   达标率高,   未考虑基层实际情况;   政策限制条件,   附加条件多,   企业无法实际受惠;   </p></li><li><p>政策互相矛盾,   不协调;   忽视上级部门审批,   存在程序瑕疵;   </p></li><li><p>领导对中央精神和上级要求打折扣,   做选择,   搞变通(<font color='red'>对政策的执行打折扣,   做选择</font>);   选择性取舍和执行文件,   不报告重大事项,   文件撰写敷衍了事(<font color='red'>这些都可以省略,   变为—只注重部门利益,   损害群众利益,   同时文件撰写方面描述的重点不是敷衍了事,   而是</font>);   中央政策落实不到位,   导致企业和群众负担过重;   </p></li><li><p><font color='red'>执行僵化,   机械化;   教条式照搬上级政策;   未结合地方实际,   执行效率慢,   落实慢;   </font> 这一点完全没写到,   一定要抓住重点,   政策盼了好多年说明落实比例不高,   执行效率低下;   </p></li><li><p>政府盲目追求项目进度;   忽略手续批复,   未顾及规划要求,   不顾环境影响;   (<font color='red'>环境方面的描述居然被归纳为执行僵化,   机械化…可能是有一个综合考量…</font>)</p></li></ol><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><ol><li>发展不平衡不充分;   </li><li>公办幼儿园名额太少,   家长哄抢;   家长自发前往排队报名,   全家坐镇网吧网上报名;   </li><li>高档幼儿园收费标准高,   中低收入家庭望而却步;   </li><li>民办幼儿园教育质量差;   教师号召学生孤立调皮孩子;   玩教具严重缺乏,   种类有限;   建筑面积小,   设施设备简陋,   办园条件差,   教师待遇低;   </li><li>师资问题严重;   幼师态度和情绪等冷暴力;   教师工作强度与薪资不对等;   家长要求高,   社会存在偏见,   学前教育专业遇冷,   教师男女比例失调,   留不住人才;   </li></ol><blockquote><p><strong><font color='red'>从整体结构来看,   整篇文章都在说发展不平衡不充分的问题,   所以这需要讲这些问题总结出来,   而不是用公办和民办来进行说明;</font></strong>   </p><p>本篇文章说明了C市幼儿园发展不平衡不充分的问题,   具体有以下几点:   </p><ol><li>幼儿园入学门槛高;   公办幼儿园名额太少,   遭到家长哄抢;   高档幼儿园收费标准高,   中低收入家庭难以承受;   </li><li>教育质量差;   玩教具严重缺乏,   种类有限;   建筑面积小,   设施设备简陋,   办园条件差,   教师待遇低;   </li><li>师资问题严重;   幼师态度和情绪等冷暴力;   教师工作强度与薪资不对等;   家长要求高,   社会存在偏见,   学前教育专业遇冷,   教师男女比例失调,   留不住人才;   </li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;答题卡&quot;&gt;&lt;a href=&quot;#答题卡&quot; class=&quot;headerlink&quot; title=&quot;答题卡&quot;&gt;&lt;/a&gt;答题卡&lt;/h1&gt;&lt;h2 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q010_行测_言语3</title>
    <link href="http://example.com/2023/04/19/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q010-xing-ce-yan-yu-3/"/>
    <id>http://example.com/2023/04/19/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q010-xing-ce-yan-yu-3/</id>
    <published>2023-04-19T01:37:55.000Z</published>
    <updated>2023-04-21T03:12:41.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="言语3"><a href="#言语3" class="headerlink" title="言语3"></a>言语3</h1><h2 id="首尾句特征"><a href="#首尾句特征" class="headerlink" title="首尾句特征"></a>首尾句特征</h2><p>首句特征:   下定义(…指的是…),   背景引入(随着/近年来/在..大背景下),   提出观点(有人说/普遍认为)</p><p>非首句特征:   指代词指代不明确,   关联词的后半部分;   </p><p>尾句特征:   结论(因此,   所以,   看来,   这),   对策(应该,   必须,   需要),   结论+对策;   </p><p>非尾句特征:   表明原因;   </p><h2 id="逻辑填空"><a href="#逻辑填空" class="headerlink" title="逻辑填空"></a>逻辑填空</h2><p>形象化表达—使用比喻或者拟人等修辞手法的时候,   需要考虑形象化表达,   也就是空格处应填写适合于比喻对象的词语;   </p><p>对应—要观察该词语是否在并列结构之中,   如果在,   则需要依据感情色彩与并列结构相对应;   </p><p>文体风格—根据文段的风格进行判断,   如果文段较为书面,   则使用逼格比较高的词语,   如果较为口语化,   则使用逼格较低的词语;   </p><img src="D:/Program%20Files/Typora/img/image-20230421104317813.png" alt="image-20230421104317813" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230421104344218.png" alt="image-20230421104344218" style="zoom:80%;" /><p>皓首苍颜(形容老年人的容貌)</p><p>孜孜以求(不知疲倦地探求)</p><p>皓首穷经(一直到年老头白之时还在深入钻研经书和古籍)</p><p>白首相知(老年知己)</p><blockquote><p>一定要注意问号!!!!特别是那种提一个问题,   然后后面说”看上去”,   “好像”,   “似乎”,   这后面一般都是转折,   如果这道题又问的是接下来最有可能讲的内容,   那么一定就是转折的内容;   </p></blockquote><blockquote><p>技巧—语义丰富的优选,   A推动 因素 产生    B驱使 要点 内化    C驱动 要素 内生,   驱动=驱使+推动,   要素=要点+因素,   內生=内化和产生;   ….</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;言语3&quot;&gt;&lt;a href=&quot;#言语3&quot; class=&quot;headerlink&quot; title=&quot;言语3&quot;&gt;&lt;/a&gt;言语3&lt;/h1&gt;&lt;h2 id=&quot;首尾句特征&quot;&gt;&lt;a href=&quot;#首尾句特征&quot; class=&quot;headerlink&quot; title=&quot;首尾句特征&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q009_申论3</title>
    <link href="http://example.com/2023/04/17/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q009-shen-lun-3/"/>
    <id>http://example.com/2023/04/17/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q009-shen-lun-3/</id>
    <published>2023-04-17T06:50:34.000Z</published>
    <updated>2023-04-17T10:42:17.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="申论3"><a href="#申论3" class="headerlink" title="申论3"></a>申论3</h1><p>如果要写编者按,   则需要在答案前面空两个格,   然后写上编者按加冒号;   然后对内容进行概括,   最后适当补充(开头结尾);   </p><p>示例概括:   主体+行为+结果;   </p><p>公文题:   格式:   标题+称谓+落款;   内容:   就是下面这个;   语言</p><p>宣传类公文:   1. 开头—背景    2. 主体—劝服(意义,   问题/危害),   倡议对策    3. 结尾—呼吁号召生活</p><p>面对舆论的宣传类公文:   1. 开头—承认事实(描述事件)+表明态度    2. 主体—问题的处理情况/解释回应(存在误解/处理不当)+长效机制    3. 总结—(道歉致谢展望)</p><blockquote><p>编者按与评论类公文不标信号,   其他的情况灵活去看;   </p></blockquote><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>在干部和群众间架起桥梁—拉近干群关系;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;申论3&quot;&gt;&lt;a href=&quot;#申论3&quot; class=&quot;headerlink&quot; title=&quot;申论3&quot;&gt;&lt;/a&gt;申论3&lt;/h1&gt;&lt;p&gt;如果要写编者按,   则需要在答案前面空两个格,   然后写上编者按加冒号;   然后对内容进行概括,   最后适当补充(开头结尾)</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>论游戏</title>
    <link href="http://example.com/2023/04/16/sui-bi/sui-bi/you-xi-yu-sheng-chan/"/>
    <id>http://example.com/2023/04/16/sui-bi/sui-bi/you-xi-yu-sheng-chan/</id>
    <published>2023-04-16T12:14:14.000Z</published>
    <updated>2023-04-16T14:13:58.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏与生产"><a href="#游戏与生产" class="headerlink" title="游戏与生产"></a>游戏与生产</h1><p>如何阻止自己玩游戏? 这需要了解何谓游戏,   然后才能判断以哪种方式能够其实生活中绝大多数的事情都可以看成是游戏,   打篮球,   唱歌,   赛跑,   电动游戏,   扳手腕都可以看成是游戏,   而要彻底了解游戏的本质,   需要将其概念与生产的概念相结合来看;   </p><p>生产资料的获取或者提升生产力的过程总是漫长,   艰辛而痛苦的;   比如当今世界翘首以盼的可控核聚变技术,   这样一个可能推动第四次工业革命的关键性技术,   所有的国家都在倾其所有进行研究,   都想当上领头羊;   而如果此时三体人到来,   并对某个国家说,   三体人愿意无偿分享可控核聚变技术,   包括技术原理,   技术文档以及维修服务,   这个时候如果抛开一切阴谋论,   每一个国家恐怕都抵挡不住这样的诱惑,   不会有哪个国家说,   不行,   我们要享受研究可控核聚变的过程,   我们现在还不想要这项技术;   又或者,   一个刚刚入社会的大学生,   工作都没有找到,   三体人又到来了,   它说,   我现在无偿给你一亿元人民币,   不收税,   没有任何代价,   你要不要? 没人会拒绝,   没人会说,   不行,   我要享受赚钱的过程,   尽管我现在身无分文,   尽管我要去睡桥洞,   尽管以后我要背负巨额的房贷车贷,   要交礼金,   要为小孩的出生和成长工作一生,   但我不能要这笔钱!</p><p>上面所说的是获取生存资源,   而在游戏当中呢? 我一把游戏下载下来,   刚刚安装好,   然后游戏就提示说,   您已经成功通关了,   您已经是这款游戏的高手了! 您已经不用再玩了这款游戏了! 当下载第二个游戏的时候,   这款游戏又提示相同的信息—您也不用再玩这款游戏啦! 我没玩就通关了,   那我玩个毛线!! 又或者,   在一局英雄联盟刚开始的时候,   一名玩家就开挂获得了六神装和满级等级,   然后出去一个普通攻击就将敌方英雄击杀,   游戏很快就会结束,   而这种靠开挂来获取的满足感,   也会在几场游戏之后荡然无存(当然,   游戏不可能出现这种逆天漏洞,   像开脚本等作弊行为屡禁不止,   主要是因为其对于游戏平衡的破坏没有达到一个刚刚那种程度,   所以一些人会选择去开脚本,   并能够从中体会到快感);   </p><p>所以,   其实可以这么说—正是这些困难重重的关卡使得游戏的目的具有意义,   这些关卡是反效率的,   而生产过程实际上是恰恰是追求效率的;   </p><p>至此,   我们似乎能够得出游戏与生产二者的概念,   并窥探它们两者的不同;   其实核心就一个—你现在做的这件事的目的有没有实际意义,   如果说现在做的这件事情的价值(意义)完全局限于这件事情,   那么它就是游戏,   如果这件事情的价值能够提升做这件事情的人的生活水平,   或者起码到一定的实质性的收获,   那么它就是生产;   </p><p>而在实际的生活中,   将两者完全区分开是很不容易的,   人们做一件事情的动机往往混合了两者,   比如电子竞技选手不仅在为游戏的胜利而拼命奋斗,   也在为通过游戏胜利所获得的报酬而努力;   </p><p>所以说,   就像棱镜talk阐述的那样,   人们痴迷于游戏的主要原因是游戏给予了玩家玩下去的意义,   正是这些反效率的层层阻碍,   使得游戏变得有一股魔法般的引力,   吸引住玩家;   </p><p>而棱镜talk的视频到此为止了,   他只阐述了游戏吸引人的其中一个原因,   并只给出了一个宽泛的解决方法;   当然,   这算不算主要原因另说,   游戏的魅力来源还有很多,   五颜六色的画面,   真实的模拟感,   飞天遁地的超能力,   刺激大脑皮层的游戏音效,   分级奖励制度等等都可以提升玩家的黏稠度;   </p><h1 id="戒游戏"><a href="#戒游戏" class="headerlink" title="戒游戏"></a>戒游戏</h1><p>而如果有人想要从中苏醒,   单靠自己的意志力是很难解决的,   因为一群学者组成的团队能够把人类诱惑因素分析个底朝天;   所以,   本文认为,   要想戒掉游戏,   需要依靠外力,   也就是说,   需要使用一些强制性的手段,   而本文作者实际上并不对需要特殊游戏设备才能进行的电子游戏感兴趣,   而且思来想去作者的解决方案也不适用于手柄或者switch等设备(作者对此甚至一窍不通);   作者的解决方案是针对于电脑和手机游戏的;   需要的软件,   电脑—火绒安全软件,   手机—不做手机控;   具体做法:   </p><p>电脑(不联网版)—在自己大脑清醒的时候,   从网络上的哈希码生成网站中随机生成一串数字和字母的组合字符串,   将其作为火绒的访问控制的密码,   并设置上网时段控制,   同时为了完全杜绝修改,   设置密码修改时需要勾选”访问控制”,   “关闭程序”,   “控制程序”,   并将三个密保问题的答案也设置为那串字符串,   那么此时就有一个问题:   如果因为工作等原因需要修改上网时段怎么办;   解决方案:   将密码保存在一个只能联网之后才能获取的地方,   比如本人就将密码保存在了英雄联盟的客户端中(具体是在客户端的装备方案的名称当中),   这样就形成了一个闭环:   我头脑不清醒了,   我想要玩游戏了,   我就会去尝试获取密码,   而为了获取密码,   我就必须联网找到那个存放密码的地方,   而为了联网,   我又必须获取密码;   同时也解决了不能修改上网时段的问题,   即在允许上网的时段联网获取密码,   就可以进行密码的修改;   </p><p>电脑(联网版)—如果在访问控制时段需要联网,   并且只想控制某款游戏或者某款应用,   可以使用火绒的程序执行控制,   单独限制某一应用或游戏,   但是需要注意的是,   这项功能不具备特定时段的控制,   也就意味着,   上述”将密码保存于游戏客户端中”的思路行不通了,   因为想要获取密码,   必须打开客户端,   而想要打开客户端必须知道密码,   不存在某个时段能够不通过密码打开客户端了;   所以这个时候就需要用到另外一个东西—微信小程序,   蜗牛传书;   这个小程序能把一段信息进行保留,   并在设定的时间之后才能打开,   完全契合这套方法;   只不过需要保证设置传书的时候脑袋要清醒,   不像上面那套方法那样简单粗暴;   </p><p>手机(必须联网)—其实上述方法那么复杂,   只不过是因为作者没有找到对应的电脑限制软件,   所以只能在火绒上做文章,   而手机其实有对应的软件—不做手机控;   它拥有独立APP监督功能,   一下子就把上面那套方法秒了,   并完美满足手机随时都可能需要联网的特性…并对卸载软件以及关闭软件进行了相当多的应对措施,   以消除用户发作的时候尝试突破限制的可能ヾ(≧ ▽ ≦)ゝ;   </p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;游戏与生产&quot;&gt;&lt;a href=&quot;#游戏与生产&quot; class=&quot;headerlink&quot; title=&quot;游戏与生产&quot;&gt;&lt;/a&gt;游戏与生产&lt;/h1&gt;&lt;p&gt;如何阻止自己玩游戏? 这需要了解何谓游戏,   然后才能判断以哪种方式能够其实生活中绝大多数的事情都可以看成是游戏,</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Q008_行测_言语2</title>
    <link href="http://example.com/2023/04/16/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q008-xing-ce-yan-yu-2/"/>
    <id>http://example.com/2023/04/16/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q008-xing-ce-yan-yu-2/</id>
    <published>2023-04-16T02:29:59.000Z</published>
    <updated>2023-04-17T02:19:45.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="言语2"><a href="#言语2" class="headerlink" title="言语2"></a>言语2</h1><h2 id="行文脉络"><a href="#行文脉络" class="headerlink" title="行文脉络"></a>行文脉络</h2><p>中心句特征:   表达作者观点,   一般为对策/结论/评价;   </p><p>分述句特征:   </p><ol><li><p>举例子:   “比如”,   “例如”,   “…就是例证”等;   </p></li><li><p>数据资料</p></li><li><p><strong>正反论证</strong></p><p>如果提出了观点,   给出对策,   然后加上反面论证,   则这个反面论证为分述句;   而如果提出了问题,   然后进行反面论证,   则这个反面论证非常重要;   </p></li><li><p>原因解释</p></li><li><p>并列分述</p></li><li><p>上述几点的排列组合</p></li></ol><blockquote><p>提对策:   是…的研究课题,   …成为一个时代命题;   </p></blockquote><blockquote><p> 对策和对策产生的结果同时出现,   则结论不重要,   而如果这种关系是因果,   而前面的所谓”对策产生的结果”是因果结构的结果,   则这个”结果”是很重要的;   </p></blockquote><blockquote><p>总结</p><ol><li><p>总分</p><p>中心句+举例说明<br>中心句+数据资料<br>中心句+正反论证<br>中心句+原因解释<br>中心句+并列分述</p></li><li><p>分总</p><p><strong><font color='red'>“这”</font></strong>,   “由此观之”,   “基于此,   …”</p><p>“也可以这么理解”,   “简而言之”;   </p></li><li><p>分总分</p><p>话题引入+中心句+解释说明;   </p></li></ol><p>注意一定要观察特征词汇,   就像图形推理题观察特征图一样;   </p></blockquote><blockquote><p>不明确选项特征</p><ol><li><p>多为否定的描述</p><p>不能,   不应,   不可,   不适合;   优选直接说”行”的选项;   </p><p>例:   早上叫醒我的不是闹钟,   而是梦想;   </p><p>A. 叫醒我的不是闹钟;   </p><p>B. 叫醒我的是梦想;   </p><p>选B!</p></li><li><p>A能回答B,   则B更明确</p><p>例1:   付出真心才能打动心仪的女孩;   </p><p>A. 追求女孩要付出真心</p><p>B. 追求女孩的方法</p><p>A能够回答B,   所以应该选A;   </p><p>例2:   只有刷题才能上岸;   </p><p>A. 必须刷题才能上岸</p><p>B. 刷题有利于上岸</p><p>选A,   因为那是对策,   而B是意义,   但是如果没有A就只能选B了;   </p><p>而如果出现原因+结论的话,   最好的选项应该是结论的原因,   其次是结论;   </p></li></ol></blockquote><p>如何判断一个例子是不是例子呢? 这需要结合文段找找例子中是不是有关键词,   如果有什么”甚至”,   或者有什么非常好的词汇去评价这个例子,   那么它可能就不是一个例子,   而是文章想要强调的重点;   或者可以这么说,   如果例子只有一个,   并且有大量的篇幅描述这个例子,   那么应该看看这个例子是不是文章的重点;   </p><h2 id="细节判断"><a href="#细节判断" class="headerlink" title="细节判断"></a>细节判断</h2><p>标志:   题干出现正确/不正确/符合/不符合/可以得知/推出;   </p><p>常见错误选项:   </p><ol><li>无中生有</li><li>偷换概念(替换,   混搭)</li><li>偷换逻辑(强加因果,   因果倒置)</li><li>偷换时态(完成时,   进行时,   将来时)</li></ol><blockquote><p>细节主旨化:   出题人更加倾向于选项和题干主旨一致,   而不是去扣某个字眼;   我强项呀ヾ(≧ ▽ ≦)ゝ</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;言语2&quot;&gt;&lt;a href=&quot;#言语2&quot; class=&quot;headerlink&quot; title=&quot;言语2&quot;&gt;&lt;/a&gt;言语2&lt;/h1&gt;&lt;h2 id=&quot;行文脉络&quot;&gt;&lt;a href=&quot;#行文脉络&quot; class=&quot;headerlink&quot; title=&quot;行文脉络&quot;&gt;&lt;/a&gt;行文脉</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q007_申论2</title>
    <link href="http://example.com/2023/04/15/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q007-shen-lun-2/"/>
    <id>http://example.com/2023/04/15/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q007-shen-lun-2/</id>
    <published>2023-04-15T07:30:54.000Z</published>
    <updated>2023-04-16T08:51:53.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="词句解释"><a href="#词句解释" class="headerlink" title="词句解释"></a>词句解释</h1><p>词句解释题,   首先要解释一下这个词句的意思,   要么从文中找就近的总结句,   要么找就近的观点句,   要么结合词句自己编;   </p><p>然后对这个词句相关的要素进行分析,   预判感情色彩,   结合材料倾向,   就是单一题的步骤;   最后以对策的形式进行总结;   其实就是是什么为什么怎么办三个步骤;   </p><blockquote><p>不光是在村儿里销售,   还要销售到各个地方—拓宽销售渠道;   </p><p> 吸引企业帮扶—…</p><p>全家都在得病—因病致贫</p></blockquote><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>消费者喜新厌旧—消费者忠诚度不足</p><p>做国产化替代—加强本土化创新</p><p>做市场调研,   原材料比较匮乏—了解市场需求,   市场情况</p><p>拿下国际大单—开拓国际市场</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;词句解释&quot;&gt;&lt;a href=&quot;#词句解释&quot; class=&quot;headerlink&quot; title=&quot;词句解释&quot;&gt;&lt;/a&gt;词句解释&lt;/h1&gt;&lt;p&gt;词句解释题,   首先要解释一下这个词句的意思,   要么从文中找就近的总结句,   要么找就近的观点句,   要么结合词句</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q006_申论1</title>
    <link href="http://example.com/2023/04/13/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q006-shen-lun-1/"/>
    <id>http://example.com/2023/04/13/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q006-shen-lun-1/</id>
    <published>2023-04-13T06:50:21.000Z</published>
    <updated>2023-04-15T07:24:00.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="申论1"><a href="#申论1" class="headerlink" title="申论1"></a>申论1</h1><h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><p>对于经验启示类,   需要考虑普适性,   也就是说,   需要屏蔽掉一些细节,   并使用某些范围更大的此进行替代;   </p><p>对于提出 对策题,   要关注题干中是否有”问题对策一一对应”的要求,   如果有,   则需要写一组问题,   然后写对应的对策,   再写一组问题,   然后写上这组问题的对策;   </p><p>对于概述材料发生变化的题目,   如果描述过去使用了大量的篇幅,   比如描述过去和现在的篇幅一半一半,   则答案也需要写上过去的内容;   如果描述过去的内容非常少,   则不需要描述过去;   </p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><ol><li>清楚地说明了每一笔钱的去向—公开透明;   </li><li>政府的事情—政务,   村子的事情—村务;   与上面联合,   政府将事情全部说出来—保证政务公开透明,   村务也一样;   </li><li>村民都参与到了解决问题当中—自治共治;   一般说”加强(村民/基层)自治”;   </li><li>完善村里的中心广场,   儿童活动室,   文化礼堂,   养老院…等项目—加强乡村基础建设,   完善设施;   </li><li>村子”颜值”提高–改善村容村貌;   </li></ol><blockquote><p>答案的总起词:   段首段尾的词,   提取的比较大比较广比较虚的词,   反复出现的词;  </p><p>乡村振兴20字方针:   产业兴旺,   生态宜居,   乡风文明,   治理有效,   生活富裕;   </p></blockquote><ol start="6"><li>开展旅游项目—发展乡村旅游产业;   </li><li>获得利润,   进行利润分配—实现成果共享;   </li><li>不大操大办,   不吃名贵菜…—转变风气,   实行勤俭节约,   不铺张浪费;   </li><li>诚信指数制度—加强诚信体系建设;   </li><li>以前得不到解决的问题现在解决了—治理问题的能力得到提升;   </li></ol><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><ol><li>把个人资料联系方式啥的全部公开—实现警务(村务/政务)公开;   </li><li>过去的方式很慢—现在的方法方便便捷效率高;   </li><li>更好地为群众服务—提高服务效率;   </li></ol><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><ol><li>靠群众反应问题—畅通反馈渠道;   </li></ol><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>创造了财富—收入水平提高/富裕/物质生活改善;</p><p>改变生活状况—生活水平提高;   </p><p>网络汽车洗衣机冰箱—加用设备升级;   </p><p>种植小麦到种植苹果—转变产业模式/粮食作物-&gt;经济作物;   </p><p>将土地流转坐收流转金—收入多元化/收入渠道增多;   </p><p>解决住的问题—居住环境的改善;   </p><p>硬化地, 自来水,   玻璃—家庭硬件设施改善;   </p><p>果库,   大棚,   照明设施—生产设施;   </p><p>打电话,   看新鲜事—通讯便捷,   信息丰富/获取信息渠道多;   </p><p>图书室,   村民广场—文化设施,   休闲娱乐设施;   (上面这两项指的是休闲生活丰富/精神文化生活)</p><img src="D:/Program%20Files/Typora/img/image-20230415152339446.png" alt="image-20230415152339446" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230415152357319.png" alt="image-20230415152357319" style="zoom:80%;" /><blockquote><ol><li>为村民解决问题,   使村务公开透明,   完善乡村基础建设与设施,   改善村貌;   </li><li>达成共识,   提高资源综合利用效益,  创办公司,   扩大养殖规模,   提高增产,   调动村民创业热情;   </li><li>开办农家乐旅游项目,   提高村民收入,   实现成果共享;   </li><li>改变村风,   勤俭节约,   不铺张浪费,   推行诚信基础建设,   加强家风建设,   道德评议进度,   广泛传播乡村文明正能量;   </li></ol></blockquote><blockquote><ol><li>明确工作内容和联系方式;   在头像上放置联系方式和具体的工作内容,   便于民众咨询办理;   </li><li>…</li></ol></blockquote><blockquote><ol><li><p>问题<br>(1) 部分乡道村道道路硬化通车后相关部门的无作为,   部分村委会未建立起村组道路管养制度,   村民不了解村路相关信息;   没有公路养护站,   专业人才匮乏,   村组道路路产路权缺乏保护;   </p><p>(2) 保护措施老旧缺乏;   防护栏老化,   标识牌模糊,   塌方路段也无警戒线;   缺乏道路监管机制;   </p><p>(3) 缺乏有效沟通配合机制;   各部门只做自己分内的事情,   不管分外的事情;   </p></li><li><p>对策</p><p>(1) 提高政府办事积极性与效率,   督促村委会建立村组道路管养制度,   向村民宣传村路管养制度,   设置公路养护站,   招揽专业人才进行公路养护,   开展培训班进行公路养护人才的培训;   </p><p>(2) 建立健全道路管理机制;   定期检测道路保护措施,   对缺乏和陈旧的保护措施及时进行更换;   </p><p>(3) 健全各部门沟通配合机制;   发现问题后及时通知责任部门,   加强协作,   共同解决道路问题;   </p></li></ol></blockquote><blockquote><ol><li>实施包产到户，解决温饱问题；农民积极性被调动。粮食衣物充足。</li><li></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;申论1&quot;&gt;&lt;a href=&quot;#申论1&quot; class=&quot;headerlink&quot; title=&quot;申论1&quot;&gt;&lt;/a&gt;申论1&lt;/h1&gt;&lt;h2 id=&quot;对策&quot;&gt;&lt;a href=&quot;#对策&quot; class=&quot;headerlink&quot; title=&quot;对策&quot;&gt;&lt;/a&gt;对策&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q005_行测_言语1</title>
    <link href="http://example.com/2023/04/13/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q005-xing-ce-yan-yu-1/"/>
    <id>http://example.com/2023/04/13/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q005-xing-ce-yan-yu-1/</id>
    <published>2023-04-13T00:58:57.000Z</published>
    <updated>2023-04-16T14:53:50.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="言语1"><a href="#言语1" class="headerlink" title="言语1"></a>言语1</h1><h2 id="转折"><a href="#转折" class="headerlink" title="转折"></a>转折</h2><p>转折之后是重点!</p><p>典型词:   但是/可是/然而/不过/却/其实/事实上/实际上</p><p>非典型:   截然相反,   截然不同,   相对而言,   一种误读,   全新的研究,   殊不知;   </p><blockquote><p>如果出现了多处转折,   则需要结合来看,   整体感知;   </p><p>如果观点部分不明确,   则要借助分述句(进行观点的补充);   </p><p>要选择更明确的选项,   而且要注意—做法比想法更重要!</p></blockquote><blockquote><p>转折之逆向思维</p><p>当文段有”大多数人认为”,   “传统观点认为”等描述的时候,   往往需要把这个观点反过来进行论述;   </p></blockquote><h2 id="因果"><a href="#因果" class="headerlink" title="因果"></a>因果</h2><p>出现因果,   结论是重点;   </p><p>标志词:   所以,   因此,   可见,   看来,   导致,   造成(消极影响)…</p><blockquote><p>表达倾向法:   有中立色彩,   消极色彩和积极色彩,   选项的感情色彩也需要和文段一致;   </p></blockquote><blockquote><p>当文段出现大篇幅进行原因解释的时候,   正确答案多为 为何+原因,   何以是+原因 的形式;   也就是不要去选单原因或者单结论的选项;   </p></blockquote><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><blockquote><p>对策,   也就是怎么做!</p></blockquote><p>只有…才;   中间的省略号最重要,   因为那是在提对策,   这是一个方式+目的的结构;   </p><p>对策标志词:   </p><ol><li>应当,   必须,   需要,   应;   </li><li>通过…手段/措施/方法/途径,   才能…;   </li><li>…是…的前提,   保障,   基础;   </li><li>…是…的必由之路/法门之一,   …的要领在于….,   …势在必行;   </li></ol><blockquote><p><strong>反面论证</strong>提对策:   </p><p>典型格式—如果/一旦….+不好的结果;   </p><p>选项答案—**<font color='red'>把前面的做法</font>**倒过来;   </p><p>干扰选项—假设变现实,   或者强调假设而不强调结果;   </p></blockquote><blockquote><p>文段为”提出问题+分析问题”,   而没有解决问题,   这个时候,   “解决问题”的选项很可能成为答案;   </p><p>但是这个”解决问题”的选项**<font color='red'>需要与题干的问题相关</font>**,   如果不相关,   则不能选,   反而应该选问题的描述;   </p></blockquote><h2 id="并列关系"><a href="#并列关系" class="headerlink" title="并列关系"></a>并列关系</h2><p>解题要点:   全面概括,   提取共性,   排除片面;   </p><blockquote><p>文段特征:   </p><ol><li>包含并列关联词—此外,   另外,   同时,   以及,   “ ;  “</li><li>句式相同或相近;   </li><li>按照时间顺序展开;   </li><li>无明显关联词衔接;   </li></ol><p>干扰选项:   片面描述;   </p></blockquote><blockquote><p>时间顺序:   </p><blockquote><p>错误描述:   春…夏…秋…冬…,   所以瑞雪兆丰年<br>正确描述:   春…夏…秋…冬…,   中国一年四季令人神往;   </p><p><strong>也就是说如果出现这种描述,   <font color='red'>需要进行全面概括</font>;</strong>   </p></blockquote><blockquote><p>古今对比与按时间展开的比较</p><p>按时间展开至少三个方面—夏商周,   早中晚,   一二三<br>古今对比为两个方面,   而且有转折词,   有较强的对比意味</p></blockquote></blockquote><h2 id="主题词"><a href="#主题词" class="headerlink" title="主题词"></a>主题词</h2><ol><li><p>特征</p><p>(1) 中心句围绕的核心话题,   一般前有引入或后有解释说明—主题词出现频率较低</p><p>(2) 每句话都围绕相同的话题—主题词出现频率较高</p><p>(3) 话题递推的落脚点—主题词出现频率相对较低</p><blockquote><p><strong><font color='red'>一个主题词要找准,   多个主题词要找全!</font></strong></p></blockquote></li></ol><blockquote><p>设问有引导话题的功能,   一般设问的对象就是主题词;   </p></blockquote><p>这个技巧其实适合于秒杀,   但是我不太建议考场上秒杀,   加快做题速度,   提高做题量才是王道;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;言语1&quot;&gt;&lt;a href=&quot;#言语1&quot; class=&quot;headerlink&quot; title=&quot;言语1&quot;&gt;&lt;/a&gt;言语1&lt;/h1&gt;&lt;h2 id=&quot;转折&quot;&gt;&lt;a href=&quot;#转折&quot; class=&quot;headerlink&quot; title=&quot;转折&quot;&gt;&lt;/a&gt;转折&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>S002_servlet2</title>
    <link href="http://example.com/2023/04/12/hou-duan-gong-cheng-shi/java-web/s002-servlet2/"/>
    <id>http://example.com/2023/04/12/hou-duan-gong-cheng-shi/java-web/s002-servlet2/</id>
    <published>2023-04-12T13:18:36.000Z</published>
    <updated>2023-04-12T14:34:27.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>cookie用于处理客户端发送不同请求时,   所使用的相同信息;  </p><h2 id="cookie使用"><a href="#cookie使用" class="headerlink" title="cookie使用"></a>cookie使用</h2><p>创建cookie对象,   设置好它的键值对,   放入response中;   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;Msi_champ&quot;</span>, <span class="string">&quot;SKT_T1&quot;</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><ol><li><p>cookie是在浏览器端保存HTTP状态的一种技术,   cookie信息为浏览器端在访问服务端的某个资源时,   服务端在响应头中传送给服务器端的一种数据;   比如7天免密登录,   当输入一次密码并将用户名和密码发送给服务端,   服务端在响应中告诉浏览器端:   保存一下这个密码,   下次就不用输了;   </p></li><li><p>cookie分为临时cookie和持久化cookie;   如果为临时的,   则关闭浏览器后就没有了,   要想设置持久化cookie,   需要在服务端设置对应的属性—setMaxAge(x)方法;   x的单位为秒;   </p></li><li><p>注意cookie的键和值都不能有空格!</p></li><li><p>cookie路径限制;   设置cookie对象的访问路径,   当访问某一个网站的时候只能在请求中设置对应网站的cookie;   也就是说,   访问哪个网站,   就传过去哪个网站的cookie,   而这个网站(路径)就是通过setPath方法来限定的;   </p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h1&gt;&lt;p&gt;cookie用于处理客户端发送不同请求时,   所使用的相同信息;  &lt;/p&gt;
&lt;h2 id=&quot;cookie</summary>
      
    
    
    
    <category term="Java Web" scheme="http://example.com/categories/Java-Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Q0004_行测_判断4</title>
    <link href="http://example.com/2023/04/11/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q004-xing-ce-pan-duan-4/"/>
    <id>http://example.com/2023/04/11/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q004-xing-ce-pan-duan-4/</id>
    <published>2023-04-11T11:15:08.000Z</published>
    <updated>2023-04-13T00:26:50.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断4"><a href="#判断4" class="headerlink" title="判断4"></a>判断4</h1><h2 id="话题一致"><a href="#话题一致" class="headerlink" title="话题一致"></a>话题一致</h2><blockquote><p>快速定位论点和论据</p><p>找论点:   </p><ol><li>典型提示词;   因此,   所以,   这表明/意味着;   </li><li>首尾句原则;   </li><li>问啥找啥;   </li></ol><p>找论据:   </p><ol><li>典型提示词;   由于,   因为,   鉴于,   根据…</li><li>就近原则:   与论点接近;   </li><li>论据的常见形式:   原因,   实例,   实验,   数据,   调查内容;   </li></ol></blockquote><blockquote><p>判别论点论据话题是否一致</p><ol><li>概括;   对于论点进行概括,   也就是谁干了什么;   </li><li>找不同点;   如果论点中出现的词语,   在论据中找不到,   则为话题不一致了;   </li></ol></blockquote><p>如果论点论据话题不一致,   优先考虑对桥做文章;   对于加强类题型,   考虑搭桥,   也就是对于论点和论据,   去同存异,   然后建立异话题之间的联系;   对于削弱类题型,   则在去同存异之后,   切断异话题之间的联系;   </p><p>概括完成之后,   可以大致得到两句话,   即论据—谁干了啥,   论点—谁干了啥;   那么如果论点论据话题不一致,   <strong>则这个桥可以对两句话的主体进行搭建,   也可以对两句话干了啥进行搭建;</strong>   </p><h2 id="话题不一致"><a href="#话题不一致" class="headerlink" title="话题不一致"></a>话题不一致</h2><p>当论点论据话题不一致,   或者只有论点的时候,   就不能考虑搭桥;   </p><ol><li><p>加强</p><p>问”前提,   假设,   加强论证”—必要条件;   </p><p>问”加强,   支持”—解释原因,   举例子;   解释原因的力度大于举例子;   </p></li><li><p>削弱</p><p>优先否论点;   (否论据的力度弱于否论点)</p></li></ol><p>必要条件,   一个重要的方式就是说明这个方式+目的的论点很靠谱,   也就是说,   论点说为了达到这个目的,   可以通过这个方式,   那么为了加强这个论点,   我只需要说,   通过这个方式达到这个目的,   确实很靠谱(或者说,   你的这个方式,   确实能够达到这个目的);   </p><blockquote><p>小心论点中的限定范围:   当论点中提到了范围,   则要看选项有谁也提到了类似的范围,   也就是看谁与论点所指代的东西更接近;   </p></blockquote><blockquote><p>注意:   判断论点论据是否一致时,   要进行一种整体感知,   也就是说,   如果它明显不一致,   那么就不一致,   但是如果它说的较为复杂,   论点论据之间具有一些隐晦的联系,   那么它就是一致的;   另外,   对于削弱之否论点,   要傻傻的去否,   论点说了这件事是为了去干什么,   我就说这件事不是为了去干什么;   </p></blockquote><h2 id="高频论证考点"><a href="#高频论证考点" class="headerlink" title="高频论证考点"></a>高频论证考点</h2><ol><li><p>可翻译类论点</p><p>论点可以翻译为A-&gt;B,   如果想要否论点,   则为A且-B(上岸了就有对象,  我上岸了,  对象呢?)</p><p>也就类似于某个人给你画大饼,   说只要你达到了某某地步或者买了什么什么产品,   你就可以怎么怎么样,   然后我买了,   我发现屁用没有,   就是上述理论的生动解释;   在实际做题的时候,   也需要注意只有…才…</p><blockquote><p>要注意论点能翻,   才能往这方面去想,   如果论点不能翻那就不要随便翻;   </p></blockquote></li><li><p>双因论点</p><p>不是1,   而是2导致的结果;   要削弱,   就去找1导致2;   比如不是减肥,   而是节食导致的脱发,   要对其进行削弱,   只需要找到减肥导致节食的选项即可;   也就是说论点不仅在说明2导致结果,   而且在说明1不能导致结果,   那么这个时候,   我只需要说1能够导致2,   就可以建立1-&gt;2-&gt;结果的串儿,   也就是说1能够导致结果,   也就削弱了论点中的”1不能够导致结果”的话语;   </p><p>这种题目一般又正向论点和反向论点,   而问题大多是最能削弱反对者观点的是? 但是在实际的做题过程中,   其实反对者观点有可能不会拿出来,   会被省略,   所以要学会主动把逆正向观点给加上,   或者形成共识;   </p></li><li><p>因果关系(考的很少!)</p><p>论点包含因果关系时才考虑,   比如包含关键词(导致/使得/有助于/能/加强/降低等);   </p><blockquote><p>这里如果论点不能翻,   那么就不要往可翻译类论点上去想;   </p><p>而且需要区分方式目的和因果关系;   </p></blockquote><p>(1) 因果倒置<br>要考虑因果关系,   首先要看论点中是否有因果关系的关键词,   然后才能考虑因果倒置;   而因果倒置的判别其实不难,   搞清楚哪个是原因哪个是结果就行了;   </p><p>(2) 他因削弱<br>他因削弱一定要表明是这个(事情)原因也会导致结果,   并且<strong>同主体</strong>也在<strong>同时</strong>干这件事情,   也就是说<strong>同主体,   同时,   新原因,   同一结果</strong>,   缺一不可,   而且一般要结合一点常识;   举例:   </p><blockquote><p>论点:   这两年喝奶茶使露露日渐肥胖;   </p><p>A:  露露喝奶茶的时候还会打电话;   </p><p>B:  露露喝奶茶的时候还会吃面食;   </p><p>C:  面食也会使人变胖;   </p></blockquote><p>可以看到只有B项合适,   因为A项打电话不会导致变胖,   而C项不知道露露是否会吃面食;   </p></li><li><p>削弱论据</p><p>当论据是调查的时候,   可以说这个调查所选取的对象不合理,   要注意,   <strong>只能说”对象选取不合理”,   不能说对象不是其他群体;</strong>   </p></li><li><p>实验</p><p>寻找实验对比对象情况不同;   所找的不同指的是实验对象的不同点,   要注意主体只能针对实验主体,   而不能说这个主体的亲人或者与他们相关的人的不同;   </p><blockquote><p> 对于单一实验,   也就是没有对照组,   可以考虑为其增加对照组;   如果实验表明做了某件事,   达到了某个效果,   那么对照组可以是没做某件事,   达不到这个效果,   对结论进行增强;   对照组也可以是没做某件事,   但是也有对应的效果,   对结论进行削弱;   </p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断4&quot;&gt;&lt;a href=&quot;#判断4&quot; class=&quot;headerlink&quot; title=&quot;判断4&quot;&gt;&lt;/a&gt;判断4&lt;/h1&gt;&lt;h2 id=&quot;话题一致&quot;&gt;&lt;a href=&quot;#话题一致&quot; class=&quot;headerlink&quot; title=&quot;话题一致&quot;&gt;&lt;/a&gt;话题一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Q003_行测_判断3</title>
    <link href="http://example.com/2023/04/11/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q003-xing-ce-pan-duan-3/"/>
    <id>http://example.com/2023/04/11/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q003-xing-ce-pan-duan-3/</id>
    <published>2023-04-11T01:12:19.000Z</published>
    <updated>2023-04-19T02:12:58.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断3"><a href="#判断3" class="headerlink" title="判断3"></a>判断3</h1><h2 id="翻译推理"><a href="#翻译推理" class="headerlink" title="翻译推理"></a>翻译推理</h2><p>翻译规则1—前-&gt;后:   如果;   就;   都;   一定;   </p><p>翻译规则2—后-&gt;前:   只有…才;   不…不;   除非A否则不B(就是B-&gt;A);   除非A,   否则B(就是-B -&gt; A);   谁必不可少(是基础/是前提/很重要),   谁在箭头后;   </p><p> 翻译规则3—且,   或:   且关系同时成立,   或关系至少一个成立;   如果看到虽然但是,   则可以看成是且关系;   </p><p>推理规则1—逆否等价:   A-&gt;B —&gt; -B -&gt; -A;   肯前必肯后,   否后必否前;   否前肯后无必然规律;   </p><p>推理规则2—或关系中,   否1—&gt;肯1:   A || B —&gt; 若-A,   则B;   若-B,   则A;   </p><p>推理规则3—德摩根定律:   -(A与B) —&gt; -A或-B;   -(A或B) —&gt; -A 与 -B;   </p><blockquote><p> 当题干中出现嵌套的逻辑关联词的时候,   拆分来看,   比如”不从政治上认识问题、解决问题，就会陷入头痛医头、脚痛医脚的被动局面，就无法从根本上解决问题”;   可以被拆分为任解—&gt;头脚,   任解—&gt;根解;   </p><p> 另外,   或关系只能否1推1,   不能肯1推1!!!</p><p> “要么…要么”只能二选一;   </p></blockquote><blockquote><p>特殊翻译:   如果-A-&gt;B,   A-&gt;B;   则B一定为真;   </p></blockquote><h2 id="类比推理"><a href="#类比推理" class="headerlink" title="类比推理"></a>类比推理</h2><h3 id="语义关系"><a href="#语义关系" class="headerlink" title="语义关系"></a>语义关系</h3><p>近义,   反义;   先确定他们之间的关系,   如果不能出答案则考虑二级辨析:   </p><p>(1) 感情色彩:   褒义贬义中性<br>(2) 程度:   近义关系</p><h3 id="词语拆分"><a href="#词语拆分" class="headerlink" title="词语拆分"></a>词语拆分</h3><blockquote><p>什么时候考虑拆分?</p><p>成语原本被拆分,   比如”南征:   北战”<br>无明显逻辑关系,   比如”成败:   呼吸”<br>相同子重复出现,   比如”寒冷:   寒舍”</p><p>方式目的的二级辨析:   这个方式靠不靠谱,   也就是说这个成语对于以这个方式去达到这个目的情感色彩是什么;   </p></blockquote><h3 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h3><p><strong>同一层级</strong>或<strong>功能相似</strong>可以看成并列关系;   </p><p>区分:   矛盾关系和反对关系;   矛盾就是非此即彼,   反对即存在第三种情况;   </p><blockquote><p>矛盾积累</p><p>A:   -A<br>男:   女<br>阴:   阳<br>开:   关<br>白天:   黑夜<br>静态博弈:   动态博弈<br>主要矛盾:   次要矛盾<br>本能行为:   学习行为<br>物理变化:   化学变化<br>精神文明:   物质文明</p></blockquote><blockquote><p>并列关系的二级辨析</p><p>(1) 人工自然<br>(2) 命名规则(以功能/特点命名,   以外形命名)</p></blockquote><img src="D:/Program%20Files/Typora/img/image-20230411154851528.png" alt="image-20230411154851528" style="zoom:80%;" /><p>律诗:   首联,   颔联,   颈联,   尾联;   </p><img src="D:/Program%20Files/Typora/img/image-20230411155552270.png" alt="image-20230411155552270" style="zoom:80%;" /><h3 id="包容"><a href="#包容" class="headerlink" title="包容"></a>包容</h3><p>两个词的范围一大一小就可以看成是包容关系;   </p><p>要区分<strong>组成关系</strong>和<strong>种属关系</strong>;   用”是”造句,   如果通顺,   则为种属关系(即A是B的一种),   如果不通顺,   则为组成关系;   </p><blockquote><p>包容的二级辨析</p><p>组成:   外部的组成还是内部的组成;   </p><p>反向包容:   即对于题干的”A:   B”,   造句:   A<strong>不是</strong>B的一种,   表示反向种属;   A中没有B,   表示反向组成;   </p></blockquote><h3 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h3><p>两个词从不同的角度进行划分,   产生交集;   </p><p>判定方法:   用四个”有的”去造句,   即”有的A是B,   有的A不是B,   有的B是A,   有的B不是A”;   必须四个都成立;   </p><p><img src="D:/Program%20Files/Typora/img/image-20230411162143211.png" alt="image-20230411162143211" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230411162207074.png" alt="image-20230411162207074" style="zoom: 80%;" />         </p><h3 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h3><blockquote><p>高频考点</p><p>原料/成品:   二级辨析—必然/或然,   自然/人工<br>功能对应:     二级辨析—主要/次要<br>时间先后:     二级辨析–主体是否一致<br>因果关系:     二级辨析—自然原因/人为原因</p></blockquote><img src="D:/Program%20Files/Typora/img/image-20230411164143350.png" alt="image-20230411164143350" style="zoom:80%;" /><blockquote><p>词语积累</p><p>打草惊蛇:   比喻采取机密行动时,   不小心惊动了对方;   而不是说”打草为了惊蛇”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断3&quot;&gt;&lt;a href=&quot;#判断3&quot; class=&quot;headerlink&quot; title=&quot;判断3&quot;&gt;&lt;/a&gt;判断3&lt;/h1&gt;&lt;h2 id=&quot;翻译推理&quot;&gt;&lt;a href=&quot;#翻译推理&quot; class=&quot;headerlink&quot; title=&quot;翻译推理&quot;&gt;&lt;/a&gt;翻译推</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q002_行测_判断2</title>
    <link href="http://example.com/2023/04/10/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q002-xing-ce-pan-duan-2/"/>
    <id>http://example.com/2023/04/10/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q002-xing-ce-pan-duan-2/</id>
    <published>2023-04-10T12:24:18.000Z</published>
    <updated>2023-04-11T01:08:46.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断2"><a href="#判断2" class="headerlink" title="判断2"></a>判断2</h1><h2 id="空间类"><a href="#空间类" class="headerlink" title="空间类"></a>空间类</h2><p>常见立体截面图:   </p><p>能切:   </p><ol><li><p>正方体,   长方体</p><p>(1) 矩形:   拦腰切(横着切),   上下切(从上往下垂直切),   斜切(平行于某一条棱往内切)</p><p>(2) 梯形:   斜切(从上往下斜着切)</p><p>(3) 三角形:   从棱上的某一点开始斜着往内切</p><p>(4) 六面体只能切出锐角三角形</p></li><li><p>圆柱</p><p>(1) 圆(横切)    (2) 椭圆(斜切)    (3) 矩形(竖切)    [圆柱切不出梯形!]</p></li><li><p>圆锥</p><p>(1) 圆(横切)    (2) 椭圆(斜切)    (3) 三角形(竖切)</p></li><li><p>圆台</p><p>(1) 圆(横切)    (2) 椭圆(斜切)    (3) 梯形(竖切)</p></li></ol><p>不能切:   </p><p>(1) 正方体长方体不能切出直角三角形和钝角三角形;   </p><p>(2) 刀不能拐弯;   不同方向的截面不能出现在同一个选项中;   </p><p>(3) 空心图形:   切的时候如果没有碰到果肉,   则不能划线;   </p><h2 id="立体拼合"><a href="#立体拼合" class="headerlink" title="立体拼合"></a>立体拼合</h2><p>先确定是几乘几的立体图;   如果贴合完成之后是一个3*3的立体图,   那么可以数每一层的小方块数量,   如果是不规则立体,   则不要去数,   而是尝试去拼凑,   优先不考虑旋转;   </p><h2 id="定义判断"><a href="#定义判断" class="headerlink" title="定义判断"></a>定义判断</h2><p>要小心隐藏主体,   如果出现”帮助…”    “让…”,   则估计会从隐藏主体上挖坑,   在选择的时候一定要明确被隐藏的主体;   </p><p>如果题干中反复出现某一个奇奇怪怪的词,   那么它大概率是一个重要词语;   </p><p>限定词:   </p><ol><li>数量与种类的限定(互益素是<strong>一种</strong>生物释放的,   能引起<strong>它种接受生物</strong>…的…)</li><li>主动被动的限定(众人自发形成…法律规定)</li><li>直接间接(能够确保遭遇<strong>直接气候风险损失</strong>)</li><li>条件/大前提(在<strong>对每一个人都不信任</strong>的基础之上)</li><li>时间的限定(网络考古指对<strong>多年前</strong>网络上发表的各种文字图片…)</li></ol><blockquote><p>定义较长或难以读懂的题:   </p><p>单定义:   哪里读懂读哪里,   重复出现(的词语)很重要<br>多定义:   问谁就优先看谁</p><p>在做定义判断的时候,   如果出现了明确的项和不明确的项,   则优先选择明确的项;   </p><p>如果定义读不懂,   定义词又可以拆的话,   则考虑使用拆词去做题;   </p></blockquote><h2 id="组合排列"><a href="#组合排列" class="headerlink" title="组合排列"></a>组合排列</h2><p>注意:   如果说A和B在某些程度上相同,   则说明他们不是同一个人!</p><blockquote><p>列表技巧:   人作为列,   职位作为行;   如果确定了某个人的职位,   那么以这个人和这个职位相交的位置为中心,   十字画叉;   </p></blockquote><blockquote><p>4321秒杀技巧:   如果有4个人,   有一个条件是3个人满足,   有一个条件是2个人满足,   有一个条件是1个人满足或者4个人都满足;   则需要先找到满足3个人的那个条件,   找到不同的这个人(菜鸟);   然后找到满足2个人的那个条件,   找到不满足条件的两个人(菜鸟和他的队友),   这个队友就是答案;   </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断2&quot;&gt;&lt;a href=&quot;#判断2&quot; class=&quot;headerlink&quot; title=&quot;判断2&quot;&gt;&lt;/a&gt;判断2&lt;/h1&gt;&lt;h2 id=&quot;空间类&quot;&gt;&lt;a href=&quot;#空间类&quot; class=&quot;headerlink&quot; title=&quot;空间类&quot;&gt;&lt;/a&gt;空间类&lt;/h</summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Q001_行测_判断1</title>
    <link href="http://example.com/2023/04/10/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q001-xing-ce-pan-duan-1/"/>
    <id>http://example.com/2023/04/10/gong-wu-yuan-kao-shi/qiang-hua-ti-sheng/q001-xing-ce-pan-duan-1/</id>
    <published>2023-04-10T06:31:12.000Z</published>
    <updated>2023-04-16T14:59:38.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><h2 id="面"><a href="#面" class="headerlink" title="面"></a>面</h2><p>图形被分割,   窟窿比较多,   生活化粗线条的留白图形;   </p><p>考法1:   整体去数面;   </p><p>考法2:   细化考点,   面与点线不同的是,   面时需要考虑形状,   而点只有数量(当然可以跟线结合)</p><p>(1) 所有面的形状;   在三角形和四边形居多的时候;   </p><p>(2) 相同形状的面;   有长得一样的奇怪图形;   </p><p>(3) 最面的形状或属性;   与外框的关系;  如果最面的形状比较常见,   则只看最面就行,   如果不常见,   则要看最面的关系或者是与外框的关系;   </p><blockquote><p>一定要注意特征图,   即有一两幅图片会明显提示这题要考啥,   一定要学会抓住;   比如出现那种大圆套小圆的,   还有明显最面的;   </p></blockquote><h2 id="线"><a href="#线" class="headerlink" title="线"></a>线</h2><p>特征图:   单一直线,   多边形出现,   优先数直线;   单一曲线,   圆,   弧出现,   优先数曲线;   </p><p>曲线和直线可以分开数,   曲线和直线也可以做运算;   </p><blockquote><p>曲直小总结:   曲直性(出现曲线,   不过一般不会这么考),   曲直线(出现单一直线单一曲线),   曲直交点(每一幅图曲线与直线都有交点)</p></blockquote><p>平行线:   一般数组数,   也就是说,   同一方向的平行线为一组;   图形特征为同方向的线条成对出现;   如果有出头的线条,   先考虑笔画数,   如果总有与出头的线条方向平行的线要考虑平行线组数;   </p><p>笔画数:   </p><p>其特征图:   </p><p>(1) 外面一个框,   里面一条线,   为日字变形图;   </p><p>(2) 外面一个框,   里面两条线,   为田字变形图;   </p><p>(3) 多边形的相交,   相接;   </p><p>(4) 出头端点图;   </p><p>(5) 五角星,   因为能够一笔画出;   </p><p>(6) 多部分图形,   回字图形;   </p><img src="D:/Program%20Files/Typora/img/image-20230410144939824.png" alt="image-20230410144939824" style="zoom:80%;" /><p>线条交叉地非常凌乱,   交地非常硬(就是大树叉子),   而且交点过多的时候(数不了交点),   就考虑数笔画数;   </p><h2 id="点"><a href="#点" class="headerlink" title="点"></a>点</h2><p>特征图:   </p><p>(1) 线条交叉明显,   大树叉子(其实在我看来就是,   线条交叉非常地硬)</p><p>(2) 相切较多,   也就是圆和线的相切点;   </p><p>(3) 有笔画数特征但是笔画数无规律;   </p><blockquote><p>要注意:   笔画数和点数量是锁死的,   出现其中一个的特征图,   如果没有规律,   则考虑另外一个;   </p></blockquote><p>细化考法:   </p><p>(1) 切点;   大部分图都有切点;   </p><p>(2) 曲直交点;   <strong>每一幅图</strong>都有曲有直,   并且曲直相交;   </p><p>(3) 框上/框内有交点;   <strong>每一幅图</strong>都有外框;   </p><blockquote><p>当每一幅图都有曲线的时候:   </p><p>(1) 先想曲直性;   </p><p>(2) 对于单一曲线;   先考虑曲线数量,   如果无规律,   则考虑曲直线运算;   </p><p>(3) 每幅图都有曲直相交;   考虑曲直交点;   </p><p>(4) 特殊曲线—圆;   可以当曲线,   可以当外框,   可以构造切点;   </p></blockquote><h2 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h2><p>轴对称;   类等腰元素;   </p><p>中心对称;   S    N    Z    平行四边形,   及其变形图;   </p><p>轴对称+中心对称;   图形存在互相垂直的对称轴;   </p><p>细化考法:   对称轴的方向和数量,   对称轴与图形中的点线面角的关系;   </p><p>如果每一幅图行都是两到三幅对称图组成的时候,   考虑对称轴之间的关系;   </p><blockquote><p>对称轴总结:   </p><p>(1) 对称轴的简单判别,   判别图形是哪种对称;   </p><p>(2) 单一对称轴;   考虑与图形中的点线面相交的关系;   考虑对称轴的方向;   </p><p>(3) 多条对称轴;   考虑对称轴的数量;   考虑对称轴之间的位置关系,   要考虑图形拆分和内外拆分来看;   </p></blockquote><blockquote><p>区分图形间关系和对称轴关系:   都是轴对称图形就考虑对称轴,   有不是轴对称的就考虑图形间关系;   </p></blockquote><h2 id="样式规律"><a href="#样式规律" class="headerlink" title="样式规律"></a>样式规律</h2><p>即加减同异;   这种题型非常好辨识;   </p><h2 id="位置规律"><a href="#位置规律" class="headerlink" title="位置规律"></a>位置规律</h2><p>对于16宫格;   先看中间四个格子,   如果黑块数量相同,   则内外分开看;   如果黑块数量不同,   则横竖看;   </p><blockquote><p>注意平移可能隐藏了主体,   可能是顶点和端点在平移,   也可能是顶点和端点所指代的东西在平移;   比如那种一个三角形在框框内移动并且要看它的定点变化的变态题;   </p></blockquote><h2 id="空间重构"><a href="#空间重构" class="headerlink" title="空间重构"></a>空间重构</h2><p>相对面不能出现于一个三视图:   (1) 同行或同列隔一个;       (2) 紧邻中线的”Z”两端;   </p><p>相邻面折叠前后相邻位置不变:   </p><p>(1) 公共边;   两个面挨着所形成的边;   两个构成直角的面所形成的两条边;   一列/一竖四个面,   另外两个面相对的边;   </p><p>(2) 公共点;   相邻的三个面有唯一的一个公共点;   </p><blockquote><p>而描边法一般不用,   因为通过上面的各种技巧一般能够排除几个,   然后再凭借空间想象能力进行排除,   选择正确的选项;   </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断&quot;&gt;&lt;a href=&quot;#判断&quot; class=&quot;headerlink&quot; title=&quot;判断&quot;&gt;&lt;/a&gt;判断&lt;/h1&gt;&lt;h2 id=&quot;面&quot;&gt;&lt;a href=&quot;#面&quot; class=&quot;headerlink&quot; title=&quot;面&quot;&gt;&lt;/a&gt;面&lt;/h2&gt;&lt;p&gt;图形被分割, </summary>
      
    
    
    
    <category term="公考_强化提升" scheme="http://example.com/categories/%E5%85%AC%E8%80%83-%E5%BC%BA%E5%8C%96%E6%8F%90%E5%8D%87/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/04/08/gong-wu-yuan-kao-shi/wu-shi-ji-chu/n-mian-shi/"/>
    <id>http://example.com/2023/04/08/gong-wu-yuan-kao-shi/wu-shi-ji-chu/n-mian-shi/</id>
    <published>2023-04-08T02:29:39.572Z</published>
    <updated>2023-04-08T02:44:35.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我叫邓雨桐,   即将毕业于重庆邮电大学通信工程系,   成绩良好,   在校期间积极参加通信工程相关实训,   锻炼了吃苦耐劳的精神,   并且拥有过硬的编程能力,   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;自我介绍&lt;/h2&gt;&lt;p&gt;我叫邓雨桐,   即将毕业于重庆邮电大学通信工程系,   成绩良好,   在校期间积极参加通信工程相关实训,   锻炼了吃苦</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/04/04/bi-ye-lun-wen/f015-fan-yi/"/>
    <id>http://example.com/2023/04/04/bi-ye-lun-wen/f015-fan-yi/</id>
    <published>2023-04-04T00:26:38.926Z</published>
    <updated>2023-04-06T05:48:02.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视频序列中可变因素对人脸识别算法处理时间之影响"><a href="#视频序列中可变因素对人脸识别算法处理时间之影响" class="headerlink" title="视频序列中可变因素对人脸识别算法处理时间之影响"></a>视频序列中可变因素对人脸识别算法处理时间之影响</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>人脸识别是生物特征识别领域最热门的研究课题之一;   有时,   人脸识别需要在不稳定的环境下工作;   因此,   影响人脸识别性能因素的研究就是一个十分有意义的主题;   识别准确度会受到许多因素的影响,   但是人脸数据库中图片的质量和系统环境因素是需要关注的主要因素;   本研究通过严格空指环境因素来建立用户图像数据库,   以确保图像具有最小的混淆度和最好的质量;   我们也使用了多种不同的因素来测试算法的性能;   他们用于测试算法的准确度和执行速度;   我们使用处理静止图像的时间作为标准;   在对视频的测试中,   该实验通过使用影响因素变化的测试集来进行;   所有因素都与静态图片基准相同,   唯一不同的就是视频的分辨率;   实验结果表明,   人脸识别处理时间,   视频分辨率,   输入图片数量都会影响处理速度;   并且输入图像数量越小,   图片尺寸越小,   处理时间就越短;   在人脸识别算法中,   FisherFace的处理速度最快;   该实验的结果可以指明最有效的人脸识别算法;   它也可以应用于现有的系统;   </p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现如今,   生物信息已被应用于认证系统;   人的生理和行为特征主要用于这一目的;   人类生理信息广泛应用于人类身份认证,   但这需要特定的设备;   人脸识别的研究和发展受到了计算机视觉和图像处理领域研究人员的广泛关注;   因为人脸是便于用于身份验证的生理特征,   在实际使用中能够进行有效的身份识别;   而且,   人脸信息比指纹和虹膜更易被采集;   它可以应用于个人图像检索、监视、护照照片验证等各种用途;   </p><p>有时人脸识别系统需要被安装在某些不能够控制环境因素的地方;   尽管人脸数据库中的图片能够被小心收集,   像CPU速度,   光照和噪音等未知因素仍然会发生变化;   这些因素影响着人脸识别算法的准确度和性能;   另外,   不同的人脸算法各有利弊,   各自适合于不同的使用环境;   特别地,   如果对视频使用人脸算法,   每个人的人脸文件夹中会有许多张图片;   每一秒会捕获25到30张图片帧;   </p><p>因此,   人脸算法在不稳定环境因素和处理速度下的研究显得十分有意义;   因为了解这些因素,   用户在使用时就会尝试避免和控制这些因素,   以求得更稳定的人脸识别效率;   进一步说,   这可以帮助开发者选择基于应用场景之最正确的识别算法;   </p><p>该实验的重要性在于为乐于将人脸识别应用于真是系统中的人提供指导,   比如上课考勤记录系统,   每日时间记录系统和实施人脸识别系统;   此外,   处理时间于CPU速度和电池消耗有关,   因此我们可以评估系统规格和人脸识别系统的性能;   在某些情况下,   人脸识别系统可能会在互联网上运行,   导致数据传输成本,   适当的视频分辨率是衡量数据量和估计成本必不可少的;   </p><p>该论文的剩余部分如下;   第二部分描述人脸识别算法的基础方法论;   第三部分描述可能会影响处理时间的试验性因素;   第四部分对这些因素的实验结果进行展示和讨论;   最后在第五部分进行总结;   </p><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><h3 id="2-1-问题现状"><a href="#2-1-问题现状" class="headerlink" title="2.1 问题现状"></a>2.1 问题现状</h3><p>人脸识别广泛应用于身份认证;   这种方法可以用于多种目的,   但都只需要一个相机;  因此,   它可以应用于许多系统中,   如个人身份识别系统,   个人身份验证系统,   门禁系统和监控等;   所以一些人脸识别系统可能会安装在不稳定的环境当中;   前人将人脸识别系统应用于班级考勤系统;   在实际课堂上进行了测试,   但是识别率低于预期;   对于148位被试者, 识别率仅有48.18%,   这暴露了该系统不能有效应用于实际环境;   从以往的研究结果来看,   可能影响识别率的因素已经被找出并研究过了;   首先一个因素就是图片数据库;   使用人脸识别技术实现班级考勤系统是一个难题,   因为他需要将部分图像存储到参照数据库中;   要解决这个问题,   需要手动创建学生参照数据库;   文献<a href="">8</a>的研究只用少量的相关图片(大约每人8~15张),   并且所采集的图片质量并没有很好受到的控制;   这也是人脸识别应用于班级考勤系统时准确率低于预期的原因之一;   随后,   进一步研究表明,   美人的参照图片数量、图片质量(分辨率和光照)和面部遮挡物如眼镜和流海都需要被认知和控制,   以求得更高的准确率;   而环境因素也是影响因素之一;   理想的班级考勤系统能够在实时人脸识别中运行良好;   这个过程是通过从视频序列中捕捉学生的脸来完成的，人们没有站着不动来捕捉他们的图像。此外，还有的问题就是,   有时光照等系统环境会不稳定，摄像机质量可能不如图像数据库创建过程中使用的摄像机;   这些因素会干扰人脸识别过程，导致识别准确率较低。因此，本研究将对人脸识别的准确率进行比较研究，以寻找最适合的人脸识别算法。</p><h3 id="2-2-Eigenface算法"><a href="#2-2-Eigenface算法" class="headerlink" title="2.2 Eigenface算法"></a>2.2 Eigenface算法</h3><p>Turk和Pentland提出了一种基于主成分分析(PCA)的人脸识别方法，每个PCA训练集中人脸的s维向量可以基于与原始图像中最大方差方向对应的T维向量空间。通过人脸子空间的基向量定义的子空间基础向量,   对新维度进行较正常维度的缩减;   为了找到一组权重,   所有已分类的人脸图像都要被投影到图像区域的人脸上,   因为这些权重向量代表了每个向量的贡献度;   为了识别未知图像,   需要将图像投影到人脸子空间中,   并找到一组权重向量;   然后,   将未知图像投影到人脸子空间中,   也得到一组权重;   如果图像是随机变量的向量,   则将其定义为扩散矩阵的S<sub>T</sub>的PCA特征向量:<br>$$<br>S_T=\sum_{i=1}^M(x_i-\mu)(x_i-\mu)^T<br>$$<br>µ<sub>i</sub>是训练集中所有图像的平均值，x<sub>i</sub>是第i个图像，其列连接在一个向量中。投影矩阵W<sub>PCA</sub>由t个最大特征值的t个特征向量组成，形成了t维人脸空间。由于这些特征向量(PCA基向量)看起来像一些鬼脸，因此它们被命名为特征脸;   </p><h3 id="2-3-FisherFace算法"><a href="#2-3-FisherFace算法" class="headerlink" title="2.3 FisherFace算法"></a>2.3 FisherFace算法</h3><p>Fisherfaces 是一种强大的算法，它的基础理论是支持在人脸识别问题中使用线性方法进行降维，至少在寻求对光照条件的敏感性时是这样的。由于学习集已被标记，因此可以使用此信息构建更可靠的方法来降低特征空间的维数。使用特定类别的线性方法进行降维,   并在减少维度的特征空间中使用简单的分类器，可以得到比特征脸算法更好的识别率。 Fisher 线性判别法 (FLD) 是一种特定类别方法的例子，因为它试图“塑造”散点使分类更可靠。该方法在 [12] 中选择 W，使得类间散布和类内散布的比率最大化。将类间散布矩阵定义为：</p><img src="D:/Program%20Files/Typora/img/image-20230405102255652.png" alt="image-20230405102255652" style="zoom:80%;" /><p>其中x<sub>ij</sub>是第j类的第i个样本,   j是j类的平均值,   nj是j类的样本数;   同样,   类间差异是使用类间散布矩阵来计算的;   </p><img src="D:/Program%20Files/Typora/img/image-20230405102621840.png" alt="image-20230405102621840" style="zoom:80%;" /><p>其中µ是所有类别的平均值;   为了阐述特定类别线性投影的好处，我们构建了一个低维模拟分类问题，其中每个类的样本位于线性子空间附近。</p><h3 id="2-4-LBP算法"><a href="#2-4-LBP算法" class="headerlink" title="2.4 LBP算法"></a>2.4 LBP算法</h3><p>在局部二值模式(LBP)纹理分类方法中，图像中LBP编码的出现次数被收集到直方图中(也称为局部二值模式直方图，LBPH)。然后通过计算简单的直方图相似性来进行分类。然而，考虑到类似的方法用于面部图像表示会导致空间信息的丢失，因此应该在保留其位置的同时对纹理信息进行编码。实现这一目标的一种方法是使用LBP算子来构建面部的几个局部描述，并将它们组合成全局描述。因为整体表征法存在一定限制,   所以这种局部描述引起了人们的兴趣,   这可以理解。与整体方法相比，这些基于局部特征的方法对姿态或照明的变化具有更好的鲁棒性。</p><p>Ahonen等人提出的基于LBP的人脸描述的基本方法论是：将人脸图像划分为许多局部区域，并从每个区域独立地提取LBP算子。然后将描述符串接以形成脸部的全局描述。此操作符通过阈值为图像中的每个像素分配一个带有中心像素值的3x3邻域(后来对其进行了改进)的标签，并将结果视为二进制数。它们使用LBP<sup>u2</sup><sub>(P,   R)</sub>表示LBP运算符。下标表示在(P，R)邻域中使用运算符。上标u2表示仅使用统一图案，并用单个标签标记所有剩余图案。标记图像f<sub>l</sub>(x，y)的直方图可以定义为</p><img src="D:/Program%20Files/Typora/img/image-20230405104743380.png" alt="image-20230405104743380" style="zoom:80%;" /><p>其中n是LBP算子产生的标签的数量，并且</p><img src="D:/Program%20Files/Typora/img/image-20230405104854543.png" alt="image-20230405104854543" style="zoom:80%;" /><p>该直方图包含有关局部微观图案在整个图像上的分布信息，例如边缘、斑点和平坦区域。为了有效的人脸表示，还应该保留空间信息。</p><h2 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h2><p>在数字图像处理中，环境因素是指任何可能发现或影响图像处理系统的因素，包括每个过程中出现的因素。有时一些因素导致图像的人脸识别不理想，进而降低识别率。这些因素包括用户的年龄，因为人脸在不同时间可能会有很大差异。影响识别率的其他因素还有光照、脸型和纹理、眼镜等。因此，所有可控的因素都应该控制好，以便最小程度地影响识别系统。 Jafri 和 Arabnia 将导致面部外观变化的因素分为两类，内部因素和外部因素，人脸的物理性质导致了内部因素。这种因素可以分为两类，内在和人际。内部因素导致同一个人的面部外观发生变化，此类因素可能发生在每个人身上。比如年龄、面部表情和面部用品，如面部毛发、眼镜、化妆品等。人际因素也是造成不同人面部外观差异的原因，比如种族和性别，这会导致存在相似面部外观的人无法被识别的情况。外部因素通过光与面部和观察者的相互作用导致面部外观发生变化。外部因素包括光照、姿势、手势、比例和成像参数。由于人脸识别系统常用于不稳定的环境，对应的可变因素是多种多样的，有时很难控制。因此，这种因素对人脸识别准确率的影响最大。</p><h3 id="3-1-对比与评估的方法"><a href="#3-1-对比与评估的方法" class="headerlink" title="3.1 对比与评估的方法"></a>3.1 对比与评估的方法</h3><p>该实验所用的比较方法的目的为从不同的角度对不同的算法进行比较;   它可以帮助研究人员从探索性案例研究的初始水平提升到高级的一般理论模型、不变性（如因果关系或进化）水平。该实验旨在使用冗杂的可变因素比较不同人脸识别算法的准确率;   比较研究设计是很简单的;   其目的是找出不同测试用例导致不同结果的原因,   来揭示产生或导致这种变化的一般基础结构;   比较方法分为两类;   其一为描述性比较,   旨在描述并有可能解释对象的不变性,   但并不是对其进行直接改变,   而是会尽量避开他们;   另一个是规范比较;   它目标不仅是检测和解释，而且还要改变对象的当前状态，帮助改进或开发将来的类似对象时，所需要的一种特殊的研究方式;   人脸识别准确率可以由多个方面来评估;   因此,   有许多具有不同数据集的知名数据库如FERET,   Yale,   AT&amp;T,   SCFace可以选用;   但是在该实验中,   使用的是真实教室环境下的学生图片组成的数据库;   因为该实验需要在类真实的环境中找到面向使用了人脸识别技术的班级考勤系统的最合适的算法;   </p><h3 id="3-2-测试因素"><a href="#3-2-测试因素" class="headerlink" title="3.2 测试因素"></a>3.2 测试因素</h3><p>在该实验中,   许多能够影响人脸识别率的因素都可能出现在真实系统中;   在创建参考数据库的时候,   图片质量,   图片大小,   噪音等级,   光照等级,   人脸方向,   眼睛和流海都需要考虑在内;   考虑这么多是因为这些因素会直接影响训练模型质量;   尽管可以对图片进行预处理来提高训练模型质量,   输入图片仍然会包含各种冗杂因素,   进而影响人脸识别准度;   因此,   该实验研究了可能出现在真实系统中的冗杂因素,   并对人脸识别算法的准确性进行了对比测试，以期找到最适合人脸识别系统的算法;   使用到的冗杂因素如下;   </p><p>在人脸识别准度测试中,   会对视频进行三方面的调整,   分别是曝光度,   噪音以及视频分辨率;   该测试是十分有意义的,   因为人脸识别系统很可能会安装在像教室那种不稳定的环境中,   并对硬件进行限制;   测试的目的是研究各种因素对人脸识别准确率的影响，并对它们进行比较，以找到最适合应用于班级考勤记录系统的算法。因此，每个因素的变化如下所述;   </p><p>根据Tan和Triggs对于困难光照条件下的人脸识别的局部纹理特征研究表明,   光照条件是影响人脸识别准确率的主要问题。因此,   本实验第一个选取的因素就是光照;   由于学生考勤系统一般被安装在室内,   通常使用灯泡作为光源,   并且光线方向是不变的;   虽然光线强度易变,   但实际环境中不太会发生变化;   因此，该实验让光照强度在正值和负值的较小范围内变化，以调整视频亮度来研究光照对人脸识别精度的影响。</p><p>噪声是使用任何相机时图像和视频都可能出现的因素。它是由多种原因引起的，但主要是因为光线不足和相机质量较低。因此，室内人脸识别系统在光线不足的情况下,   会频繁受到噪声的影响。噪声变化是实验中使用的第二个因素。将人工高斯噪声添加到视频序列中,   因为其很有可能随机出现在视频帧中。没有噪声时被定义为正常情况,   其值为零，然后将值增加到20、25、30和50进行测试。为了研究噪声对人脸识别准确率的影响，在视频中加入了噪声;   </p><p>基于视频的人脸识别包括人脸跟踪和人脸识别两部分;   最重要的因素是图片分辨率,   根据Huang和Wang的研究,   图片中的面部细节取决于图片分辨率;   面部细节影响面部识别的性能，因为更多的面部细节可以获得更高的面部识别精度，但它对面部检测速度有一个折中。此外，不同的视频分辨率会影响面部大小和清晰度，准确度测试的最后一个因素是视频分辨率的变化。本实验旨在研究视频分辨率对人脸识别准确率的影响。本次测试中使用的视频分辨率有 720p、480p 和 360p。</p><h3 id="执行速度测试"><a href="#执行速度测试" class="headerlink" title="执行速度测试"></a>执行速度测试</h3><p>影响人脸识别系统处理速度的因素有很多，如人脸识别算法、视频分辨率、硬件等。但是，由于研究目标旨在找到实现硬件限制的班级考勤记录系统的合适的算法。复杂方法的处理速度提高是不合适的。因此，选择比较的因素是提高视频中人脸识别处理速度的简单方法，即跳帧率和视频分辨率的变化。跳帧是提高视频中人脸识别速度的正确思路，因为有些视频帧率高，处理时间长。此外，在它包含的一秒钟视频中，许多相似的帧取决于帧速率。因此，可以通过跳过一些相似的帧来减少它们，以提高人脸识别的处理速度。在实验中，跳帧率的变化分别取值 5、6、7、8、9、10、15、20 和 30，以找到最适合接受精度的跳帧。另一个需要比较的因素是视频分辨率。这个因素显然会影响处理速度，尤其是在人脸检测方面。在实验中，将使用 Haar 级联分类器搜索人脸，但该方法使用搜索窗口在图像的每个区域中查找人脸。由于这个原因，处理时间的性能将取决于视频帧的大小。<br>此外，更高的视频分辨率需要更多的存储空间。因此，本次测试的目的是寻找在性能和实际使用方面都能被接受的适合考勤系统的视频分辨率。本次测试的视频分辨率变化为 720p、480p 和 360p。</p><h3 id="基于视频的人脸识别准确率测试"><a href="#基于视频的人脸识别准确率测试" class="headerlink" title="基于视频的人脸识别准确率测试"></a>基于视频的人脸识别准确率测试</h3><p>基于视频的人脸识别是基于静止图像的人脸识别的延伸，在准确率方面有一定的挑战。该研究旨在找到最适合的人脸识别算法。基于视频的人脸识别取代了实时人脸识别。究其原因，在实际测试中，让受试者亲临现场多次对系统进行测试的方法存在复测的局限性。如果测试对象较少，会影响结果的精确度。因此，视频是本实验的最佳选择，它解决了复测的问题，而且基于视频的人脸识别过程也可以被认为是实时的人脸识别;   该实验旨在比较视频的人脸识别率,   并找寻最合适的人脸算法;   </p><p>这项工作是通过收集面向对象编程(OOP)班级的视频文件进行的，为期10周。有148名学生走过摄像机。然后，视频将被分割成更小的部分。每个视频有7.18分钟长的视频，每秒30fps，其中包含30个路人的镜头。每个受试者随机进入画面三次。测试对象与基于静止图像的测试中使用的相同。本实验测试了三种与基于静止图像的人脸识别测试类似的人脸识别算法。本实验的假设是每种算法都能达到可接受的人脸识别准确率，并且处理时间是合适的。测试因素为准确度和处理时间;   </p><img src="D:/Program%20Files/Typora/img/image-20230406101552947.png" alt="image-20230406101552947" style="zoom:80%;" /><h2 id="4-结果与讨论"><a href="#4-结果与讨论" class="headerlink" title="4. 结果与讨论"></a>4. 结果与讨论</h2><h3 id="4-1-可变因素的准确率测试"><a href="#4-1-可变因素的准确率测试" class="headerlink" title="4.1 可变因素的准确率测试"></a>4.1 可变因素的准确率测试</h3><p>该实验给出了具有可变因素的静止图像的人脸识别测试的结果。本次测试实验分为三个部分。第一个实验是在没有混淆因素的情况下进行静止图像的人脸识别测试。这是测试集中的非调整对比图像测试。该测试基于30名受试者的封闭测试集。参考数据库是以前使用的受控数据库，但将图像扩展到每个受试者40个。测试集包含参考数据库中存在的每个受试者的10个图像，但与图像不同。它通过三种算法进行了测试：EigenFace、FisherFace和LBPH。实验结果如表1所示。从图1来看，LBPH的准确率最高，为81.67%，FisherFaces的准确率为69.93%，EigenFace的准确率最低，为46.67%。</p><img src="D:/Program%20Files/Typora/img/image-20230406103800061.png" alt="image-20230406103800061" style="zoom:80%;" /><p>这与前人的班级考勤记录系统相比,   比较令人满意，因为之前的LBPH准确率为48.18%。因此,   该实验表明,   图片数据库是影响准确率的主要因素;   而包含不同人脸表情和方位的参考库可以提高LBPH的准确率。这一部分的第二个实验是在不同噪声值的情况下基于静止图像的人脸识别测试。添加了高斯噪波，通过使用不同的值20、25、30和50来调整图像。实验结果如表2所示。在每种情况下，特征脸和FisherFace的人脸识别准确率略有不同。</p><img src="D:/Program%20Files/Typora/img/image-20230406103733455.png" alt="image-20230406103733455" style="zoom:80%;" /><p>在噪声值为0和50的情况下，特征脸的准确率最高，达到46.67%。FisherFace在25岁时正确率最高，为70.0%。当噪声值为0时，LBPH的准确率最高，为81.67%。结果表明，在图2中，特征脸和FisherFace对不同的噪声具有稳定的精度。LBPH噪声对准确度的影响最大。从LBPH的准确度来看，随着噪声值的增大，LBPH的准确度不断下降。其原因是图像中噪声的干扰导致了直方图相似性的缺失。更改图像的细节可以更改直方图值。而特征脸和FisherFace不受噪声的影响，因为这些方法使用了一种统计方法，可以灵活地处理图像中的一些细节变化。在基于静止图像的人脸识别中测试的最后一个因素是图像亮度变化。此测试包含具有正值和负值的曝光调整的图像。本实验的结果如表3所示。在曝光度-10的情况下，LBPH的准确率最高，为84.0%，但其准确性与其他情况没有显著差异。在许多情况下，FisherFace算法的准确率最高，达到69.33%。特征脸算法的正确率最高，为46.67%。</p><p>在这个实验中，将测试三个可能影响人脸识别系统处理时间的因素：人脸识别算法、视频分辨率和跳帧率。人脸识别算法是首先需要关注的因素。显然，每种算法都有不同的特点，基于不同的方法。它可以假设每个算法需要不同的处理时间。在此基础上，采用特征脸、FisherFace和LBPH三种人脸识别算法进行了人脸识别处理时间的实验。在这种情况下，使用长度为7.18分钟的720p视频分辨率，没有混杂因素或任何调整，但跳帧被定义为6帧。本例的结果如表4所示。如图4所示，FisherFace算法占用的处理时间最短。对于长度为7.18分钟的视频，该算法花费的时间大约是原始长度13.31分钟的1.85倍。其次是特征脸，占原始长度的1.96倍，为14.13分钟。最后一种LBPH，处理时间最长，为14.66分钟，即视频长度的2.04倍。视频分辨率是用于测试处理时间的因素之一。根据假设人脸识别处理时间取决于视频分辨率的假设。如上所述，人脸检测模块是基于视频的人脸识别组件之一，并且使用了类Haar特征。该算法设置了一个移动窗口，并移动到图像的每个区域。因此，该测试的假设是较大的图像比较小的图像需要更多的处理时间。处理时间测试的结果如图5,   随着视频分辨率的降低，每种人脸识别算法的处理时间都呈现下降趋势。这与如上所述的假设有关，即较小的视频分辨率需要较短的处理时间。FisherFaces算法是所有案例中处理时间最短的算法，三个案例的平均处理时间约为9.79分钟。其次是特征脸，它的平均处理时间为10.18分钟。LBPH是处理时间最长的算法，平均为11.19分钟。然而，这三种算法的处理时间并没有显著差异。基于视频的人脸识别系统需要对视频的每一帧进行提取和处理。在实际应用中，视频通常为25fps或30fps，整个视频帧的处理耗时较长，不适合用于班级考勤记录系统。因此，跳帧率是在处理时间的情况下要测试的因素，因为如果跳过帧，则只选择部分视频帧进行处理，并且它可以减少处理时间。顺便说一句，跳过率是比较重要的。因为如果视频帧被跳过太多，一些人脸可能不会出现和检测到;   在该实验中,   视频使用30帧,   并捕捉了以不同姿势和表情经过摄像机的人;   人们每次在视频中至少出现一秒，所以在这个实验中，跳帧率将从每秒一帧调整。这可以确保它可以覆盖视频中的所有人。通过跳帧调整进行处理时间测试的结果如表6所示。如图6所示，处理时间的趋势取决于输入图像的数量。</p><img src="D:/Program%20Files/Typora/img/image-20230406104826870.png" alt="image-20230406104826870" style="zoom:80%;" /><p>处理时间的减少与跳帧率的增加有关，这意味着较少的输入图像需要较少的处理时间。然而，这些处理时间的结果具有类似的准确性。因此，本实验中的跳帧率范围可以适用于班级考勤记录系统。与7.18分钟的视频长度相比，在20、25和30帧跳跃的情况下，处理时间比原始视频长度更短。</p><p>据此得出结论,   对于处理时间,   其影响因素为人脸算法,   视频分辨率,   与输入图片数量;   作为实验的结果，这与假设有关，即输入图像的数量越少，图像尺寸越小越可以减少处理时间。在人脸识别算法的情况下，LBPH是处理时间最长的算法，平均为10.58分钟。第二个是特征脸，平均耗时约10.03分钟。Fisherfaces是处理时间最短的算法，平均为9.76分钟。<br>结果评估是评估人脸检测和识别准确性的过程。这个过程的目的是验证每个实验结果的准确性和有效性。有几种方法可以评估结果，但在本研究中，评估是通过手动检查完成的。原因是视频中有很多人路过镜头，有时不止一个人。虽然它可以估计受试者通过相机的时刻，但它会被叠加而导致错误，以影响初步阶段验证结果。我们可以通过手动检查考虑图像的物理特性，并对导致错误检测和识别的问题进行分类。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>在这项研究中，研究了三种有效的人脸识别算法及其变化因素。 Eigenfaces、Fisherfaces 和 LBPH 是人脸识别算法，由于这些算法在人脸识别领域广为人知和流行，所以本研究选择这些人脸识别算法进行研究。虽然人脸识别系统具有如前所述的诸多好处，但在实际的人脸识别系统中，它大多部署在不稳定的环境中。这些因素都会影响并导致系统对每个人脸识别算法的处理时间有很多冗杂因素。根据这些原因，在初步测试中检验了每个因素的假设，以研究人脸识别准确率和处理时间的影响;   基于静止图像的测试结果表明，LBPH 在正常情况下获得了最高的识别率。虽然，它可以高精度地处理测试中的曝光度变化，但是当添加噪声时它无法做到很好。 LBPH 受高斯噪声的干扰太大，该算法的精度在这种情况下远低于其他算法。 Eigenfaces 具有了相当的准确性，在所有情况下都没有显着差异。<br>Fisherfaces 的结果非常有意思，也是最快的算法，它花费的处理时间最少。即使准确率不如LBPH，但该算法可以稳定准确地处理所有因素。该测试概述了影响人脸识别准确性的因素。 LBPH 的准确性也从之前研究中的 48.18% 显着提高到新数据库的 15 个图像数据库大小的 73.3% 和 40 个图像数据库大小的 81.67%。<br>在视频测试中，实验是使用带有冗杂因素变化的测试集进行的。所有因素都与静止图像相似，但它有一个附加因素，即视频分辨率。视频外观根据曝光度的变化、噪声的变化和视频分辨率进行调整。基于视频的人脸识别测试结果的趋势与基于静止图像的测试结果相关，但三种算法的准确率大幅下降。然而，LBPH 拥有最高的精度。虽然分辨率增加了，但它比 Fish erfaces 和Eigenfaces 算法花费了更多的处理时间。 Fisherfaces 仍然是最快的算法，它在所有视频分辨率上花费的处理时间最短，对噪声和曝光度有很强的鲁棒性。同时，Eigenfaces 的精度最低。它对分辨率的影响低于LBPH。由此可见，人脸识别处理时间、人脸识别算法、视频分辨率、输入图像数量等因素对处理速度的影响。作为实验的结果，它与输入图像数量较少的假设有关，较小的图像尺寸可以减少处理时间。在人脸识别算法的情况下，Fisherfaces 是最快的算法，其处理时间分别比 Eigenfaces 和 LBPH 短。<br>可以通过将低 CPU 速度（例如 Rasberry PI 和实时视频）应用于所研究的问题并比较不同方法在解决方案质量和运行时间方面的结果来进行进一步的研究。研究研究问题的处理时间是未来研究的另一个有趣的扩展和机会。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;视频序列中可变因素对人脸识别算法处理时间之影响&quot;&gt;&lt;a href=&quot;#视频序列中可变因素对人脸识别算法处理时间之影响&quot; class=&quot;headerlink&quot; title=&quot;视频序列中可变因素对人脸识别算法处理时间之影响&quot;&gt;&lt;/a&gt;视频序列中可变因素对人脸识别算法处</summary>
      
    
    
    
    
  </entry>
  
</feed>
