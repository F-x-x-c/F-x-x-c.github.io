<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aegis</title>
  
  <subtitle>Aegis Curiser</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-05T11:18:48.503Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Deng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/05/bi-ye-lun-wen/pca-yuan-ma/"/>
    <id>http://example.com/2023/03/05/bi-ye-lun-wen/pca-yuan-ma/</id>
    <published>2023-03-05T10:44:23.881Z</published>
    <updated>2023-03-05T11:18:48.503Z</updated>
    
    <content type="html"><![CDATA[<p>下面是OpenCV对于PCA算法的c++实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*M///////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  By downloading, copying, installing or using the software you agree to this license.</span></span><br><span class="line"><span class="comment">//  If you do not agree to this license, do not download, install,</span></span><br><span class="line"><span class="comment">//  copy or use the software.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                          License Agreement</span></span><br><span class="line"><span class="comment">//                For Open Source Computer Vision Library</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.</span></span><br><span class="line"><span class="comment">// Copyright (C) 2009, Willow Garage Inc., all rights reserved.</span></span><br><span class="line"><span class="comment">// Copyright (C) 2013, OpenCV Foundation, all rights reserved.</span></span><br><span class="line"><span class="comment">// Third party copyrights are property of their respective owners.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Redistribution and use in source and binary forms, with or without modification,</span></span><br><span class="line"><span class="comment">// are permitted provided that the following conditions are met:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   * Redistribution&#x27;s of source code must retain the above copyright notice,</span></span><br><span class="line"><span class="comment">//     this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   * Redistribution&#x27;s in binary form must reproduce the above copyright notice,</span></span><br><span class="line"><span class="comment">//     this list of conditions and the following disclaimer in the documentation</span></span><br><span class="line"><span class="comment">//     and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   * The name of the copyright holders may not be used to endorse or promote products</span></span><br><span class="line"><span class="comment">//     derived from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot; and</span></span><br><span class="line"><span class="comment">// any express or implied warranties, including, but not limited to, the implied</span></span><br><span class="line"><span class="comment">// warranties of merchantability and fitness for a particular purpose are disclaimed.</span></span><br><span class="line"><span class="comment">// In no event shall the Intel Corporation or contributors be liable for any direct,</span></span><br><span class="line"><span class="comment">// indirect, incidental, special, exemplary, or consequential damages</span></span><br><span class="line"><span class="comment">// (including, but not limited to, procurement of substitute goods or services;</span></span><br><span class="line"><span class="comment">// loss of use, data, or profits; or business interruption) however caused</span></span><br><span class="line"><span class="comment">// and on any theory of liability, whether in contract, strict liability,</span></span><br><span class="line"><span class="comment">// or tort (including negligence or otherwise) arising in any way out of</span></span><br><span class="line"><span class="comment">// the use of this software, even if advised of the possibility of such damage.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//M*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;precomp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************************\</span></span><br><span class="line"><span class="comment">*                                          PCA                                           *</span></span><br><span class="line"><span class="comment">\****************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cv</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">PCA::<span class="built_in">PCA</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">PCA::<span class="built_in">PCA</span>(InputArray data, InputArray _mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> maxComponents)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">operator</span></span>()(data, _mean, flags, maxComponents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PCA::<span class="built_in">PCA</span>(InputArray data, InputArray _mean, <span class="keyword">int</span> flags, <span class="keyword">double</span> retainedVariance)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">operator</span></span>()(data, _mean, flags, retainedVariance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PCA&amp; <span class="title">PCA::operator</span><span class="params">()</span><span class="params">(InputArray _data, InputArray __mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> maxComponents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat data = _data.<span class="built_in">getMat</span>(), _mean = __mean.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="keyword">int</span> covar_flags = CV_COVAR_SCALE;</span><br><span class="line">    <span class="keyword">int</span> len, in_count;</span><br><span class="line">    Size mean_sz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert</span>( data.<span class="built_in">channels</span>() == <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span>( flags &amp; CV_PCA_DATA_AS_COL )</span><br><span class="line">    &#123;</span><br><span class="line">        len = data.rows;</span><br><span class="line">        in_count = data.cols;</span><br><span class="line">        covar_flags |= CV_COVAR_COLS;</span><br><span class="line">        mean_sz = <span class="built_in">Size</span>(<span class="number">1</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = data.cols;</span><br><span class="line">        in_count = data.rows;</span><br><span class="line">        covar_flags |= CV_COVAR_ROWS;</span><br><span class="line">        mean_sz = <span class="built_in">Size</span>(len, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = std::<span class="built_in">min</span>(len, in_count), out_count = count;</span><br><span class="line">    <span class="keyword">if</span>( maxComponents &gt; <span class="number">0</span> )</span><br><span class="line">        out_count = std::<span class="built_in">min</span>(count, maxComponents);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;scrambled&quot; way to compute PCA (when cols(A)&gt;rows(A)):</span></span><br><span class="line">    <span class="comment">// B = A&#x27;A; B*x=b*x; C = AA&#x27;; C*y=c*y -&gt; AA&#x27;*y=c*y -&gt; A&#x27;A*(A&#x27;*y)=c*(A&#x27;*y) -&gt; c = b, x=A&#x27;*y</span></span><br><span class="line">    <span class="keyword">if</span>( len &lt;= in_count )</span><br><span class="line">        covar_flags |= CV_COVAR_NORMAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ctype = std::<span class="built_in">max</span>(CV_32F, data.<span class="built_in">depth</span>());</span><br><span class="line">    mean.<span class="built_in">create</span>( mean_sz, ctype );</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">covar</span><span class="params">( count, count, ctype )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !_mean.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_Assert</span>( _mean.<span class="built_in">size</span>() == mean_sz );</span><br><span class="line">        _mean.<span class="built_in">convertTo</span>(mean, ctype);</span><br><span class="line">        covar_flags |= CV_COVAR_USE_AVG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calcCovarMatrix</span>( data, covar, mean, covar_flags, ctype );</span><br><span class="line">    <span class="built_in">eigen</span>( covar, eigenvalues, eigenvectors );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(covar_flags &amp; CV_COVAR_NORMAL) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// CV_PCA_DATA_AS_ROW: cols(A)&gt;rows(A). x=A&#x27;*y -&gt; x&#x27;=y&#x27;*A</span></span><br><span class="line">        <span class="comment">// CV_PCA_DATA_AS_COL: rows(A)&gt;cols(A). x=A&#x27;&#x27;*y -&gt; x&#x27;=y&#x27;*A&#x27;</span></span><br><span class="line">        Mat tmp_data, tmp_mean = <span class="built_in">repeat</span>(mean, data.rows/mean.rows, data.cols/mean.cols);</span><br><span class="line">        <span class="keyword">if</span>( data.<span class="built_in">type</span>() != ctype || tmp_mean.data == mean.data )</span><br><span class="line">        &#123;</span><br><span class="line">            data.<span class="built_in">convertTo</span>( tmp_data, ctype );</span><br><span class="line">            <span class="built_in">subtract</span>( tmp_data, tmp_mean, tmp_data );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">subtract</span>( data, tmp_mean, tmp_mean );</span><br><span class="line">            tmp_data = tmp_mean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Mat <span class="title">evects1</span><span class="params">(count, len, ctype)</span></span>;</span><br><span class="line">        <span class="built_in">gemm</span>( eigenvectors, tmp_data, <span class="number">1</span>, <span class="built_in">Mat</span>(), <span class="number">0</span>, evects1,</span><br><span class="line">            (flags &amp; CV_PCA_DATA_AS_COL) ? CV_GEMM_B_T : <span class="number">0</span>);</span><br><span class="line">        eigenvectors = evects1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// normalize eigenvectors</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; out_count; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            Mat vec = eigenvectors.<span class="built_in">row</span>(i);</span><br><span class="line">            <span class="built_in">normalize</span>(vec, vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( count &gt; out_count )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// use clone() to physically copy the data and thus deallocate the original matrices</span></span><br><span class="line">        eigenvalues = eigenvalues.<span class="built_in">rowRange</span>(<span class="number">0</span>,out_count).<span class="built_in">clone</span>();</span><br><span class="line">        eigenvectors = eigenvectors.<span class="built_in">rowRange</span>(<span class="number">0</span>,out_count).<span class="built_in">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PCA::write</span><span class="params">(FileStorage&amp; fs )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_Assert</span>( fs.<span class="built_in">isOpened</span>() );</span><br><span class="line"></span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;name&quot;</span> &lt;&lt; <span class="string">&quot;PCA&quot;</span>;</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;vectors&quot;</span> &lt;&lt; eigenvectors;</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;values&quot;</span> &lt;&lt; eigenvalues;</span><br><span class="line">    fs &lt;&lt; <span class="string">&quot;mean&quot;</span> &lt;&lt; mean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PCA::read</span><span class="params">(<span class="keyword">const</span> FileNode&amp; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_Assert</span>( !fn.<span class="built_in">empty</span>() );</span><br><span class="line">    <span class="built_in">CV_Assert</span>( (String)fn[<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;PCA&quot;</span> );</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">read</span>(fn[<span class="string">&quot;vectors&quot;</span>], eigenvectors);</span><br><span class="line">    cv::<span class="built_in">read</span>(fn[<span class="string">&quot;values&quot;</span>], eigenvalues);</span><br><span class="line">    cv::<span class="built_in">read</span>(fn[<span class="string">&quot;mean&quot;</span>], mean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computeCumulativeEnergy</span><span class="params">(<span class="keyword">const</span> Mat&amp; eigenvalues, <span class="keyword">double</span> retainedVariance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_DbgAssert</span>( eigenvalues.<span class="built_in">type</span>() == DataType&lt;T&gt;::type );</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">g</span><span class="params">(eigenvalues.size(), DataType&lt;T&gt;::type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ig = <span class="number">0</span>; ig &lt; g.rows; ig++)</span><br><span class="line">    &#123;</span><br><span class="line">        g.at&lt;T&gt;(ig, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> im = <span class="number">0</span>; im &lt;= ig; im++)</span><br><span class="line">        &#123;</span><br><span class="line">            g.at&lt;T&gt;(ig,<span class="number">0</span>) += eigenvalues.at&lt;T&gt;(im,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(L = <span class="number">0</span>; L &lt; eigenvalues.rows; L++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> energy = g.at&lt;T&gt;(L, <span class="number">0</span>) / g.at&lt;T&gt;(g.rows - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(energy &gt; retainedVariance)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L = std::<span class="built_in">max</span>(<span class="number">2</span>, L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PCA&amp; <span class="title">PCA::operator</span><span class="params">()</span><span class="params">(InputArray _data, InputArray __mean, <span class="keyword">int</span> flags, <span class="keyword">double</span> retainedVariance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat data = _data.<span class="built_in">getMat</span>(), _mean = __mean.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="keyword">int</span> covar_flags = CV_COVAR_SCALE;</span><br><span class="line">    <span class="keyword">int</span> len, in_count;</span><br><span class="line">    Size mean_sz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert</span>( data.<span class="built_in">channels</span>() == <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span>( flags &amp; CV_PCA_DATA_AS_COL )</span><br><span class="line">    &#123;</span><br><span class="line">        len = data.rows;</span><br><span class="line">        in_count = data.cols;</span><br><span class="line">        covar_flags |= CV_COVAR_COLS;</span><br><span class="line">        mean_sz = <span class="built_in">Size</span>(<span class="number">1</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = data.cols;</span><br><span class="line">        in_count = data.rows;</span><br><span class="line">        covar_flags |= CV_COVAR_ROWS;</span><br><span class="line">        mean_sz = <span class="built_in">Size</span>(len, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert</span>( retainedVariance &gt; <span class="number">0</span> &amp;&amp; retainedVariance &lt;= <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = std::<span class="built_in">min</span>(len, in_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;scrambled&quot; way to compute PCA (when cols(A)&gt;rows(A)):</span></span><br><span class="line">    <span class="comment">// B = A&#x27;A; B*x=b*x; C = AA&#x27;; C*y=c*y -&gt; AA&#x27;*y=c*y -&gt; A&#x27;A*(A&#x27;*y)=c*(A&#x27;*y) -&gt; c = b, x=A&#x27;*y</span></span><br><span class="line">    <span class="keyword">if</span>( len &lt;= in_count )</span><br><span class="line">        covar_flags |= CV_COVAR_NORMAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ctype = std::<span class="built_in">max</span>(CV_32F, data.<span class="built_in">depth</span>());</span><br><span class="line">    mean.<span class="built_in">create</span>( mean_sz, ctype );</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">covar</span><span class="params">( count, count, ctype )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !_mean.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_Assert</span>( _mean.<span class="built_in">size</span>() == mean_sz );</span><br><span class="line">        _mean.<span class="built_in">convertTo</span>(mean, ctype);</span><br><span class="line">        covar_flags |= CV_COVAR_USE_AVG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calcCovarMatrix</span>( data, covar, mean, covar_flags, ctype );</span><br><span class="line">    <span class="built_in">eigen</span>( covar, eigenvalues, eigenvectors );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !(covar_flags &amp; CV_COVAR_NORMAL) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// CV_PCA_DATA_AS_ROW: cols(A)&gt;rows(A). x=A&#x27;*y -&gt; x&#x27;=y&#x27;*A</span></span><br><span class="line">        <span class="comment">// CV_PCA_DATA_AS_COL: rows(A)&gt;cols(A). x=A&#x27;&#x27;*y -&gt; x&#x27;=y&#x27;*A&#x27;</span></span><br><span class="line">        Mat tmp_data, tmp_mean = <span class="built_in">repeat</span>(mean, data.rows/mean.rows, data.cols/mean.cols);</span><br><span class="line">        <span class="keyword">if</span>( data.<span class="built_in">type</span>() != ctype || tmp_mean.data == mean.data )</span><br><span class="line">        &#123;</span><br><span class="line">            data.<span class="built_in">convertTo</span>( tmp_data, ctype );</span><br><span class="line">            <span class="built_in">subtract</span>( tmp_data, tmp_mean, tmp_data );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">subtract</span>( data, tmp_mean, tmp_mean );</span><br><span class="line">            tmp_data = tmp_mean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Mat <span class="title">evects1</span><span class="params">(count, len, ctype)</span></span>;</span><br><span class="line">        <span class="built_in">gemm</span>( eigenvectors, tmp_data, <span class="number">1</span>, <span class="built_in">Mat</span>(), <span class="number">0</span>, evects1,</span><br><span class="line">            (flags &amp; CV_PCA_DATA_AS_COL) ? CV_GEMM_B_T : <span class="number">0</span>);</span><br><span class="line">        eigenvectors = evects1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// normalize all eigenvectors</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; eigenvectors.rows; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            Mat vec = eigenvectors.<span class="built_in">row</span>(i);</span><br><span class="line">            <span class="built_in">normalize</span>(vec, vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the cumulative energy content for each eigenvector</span></span><br><span class="line">    <span class="keyword">int</span> L;</span><br><span class="line">    <span class="keyword">if</span> (ctype == CV_32F)</span><br><span class="line">        L = computeCumulativeEnergy&lt;<span class="keyword">float</span>&gt;(eigenvalues, retainedVariance);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        L = computeCumulativeEnergy&lt;<span class="keyword">double</span>&gt;(eigenvalues, retainedVariance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use clone() to physically copy the data and thus deallocate the original matrices</span></span><br><span class="line">    eigenvalues = eigenvalues.<span class="built_in">rowRange</span>(<span class="number">0</span>,L).<span class="built_in">clone</span>();</span><br><span class="line">    eigenvectors = eigenvectors.<span class="built_in">rowRange</span>(<span class="number">0</span>,L).<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PCA::project</span><span class="params">(InputArray _data, OutputArray result)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat data = _data.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="built_in">CV_Assert</span>( !mean.<span class="built_in">empty</span>() &amp;&amp; !eigenvectors.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">        ((mean.rows == <span class="number">1</span> &amp;&amp; mean.cols == data.cols) || (mean.cols == <span class="number">1</span> &amp;&amp; mean.rows == data.rows)));</span><br><span class="line">    Mat tmp_data, tmp_mean = <span class="built_in">repeat</span>(mean, data.rows/mean.rows, data.cols/mean.cols);</span><br><span class="line">    <span class="keyword">int</span> ctype = mean.<span class="built_in">type</span>();</span><br><span class="line">    <span class="keyword">if</span>( data.<span class="built_in">type</span>() != ctype || tmp_mean.data == mean.data )</span><br><span class="line">    &#123;</span><br><span class="line">        data.<span class="built_in">convertTo</span>( tmp_data, ctype );</span><br><span class="line">        <span class="built_in">subtract</span>( tmp_data, tmp_mean, tmp_data );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">subtract</span>( data, tmp_mean, tmp_mean );</span><br><span class="line">        tmp_data = tmp_mean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( mean.rows == <span class="number">1</span> )</span><br><span class="line">        <span class="built_in">gemm</span>( tmp_data, eigenvectors, <span class="number">1</span>, <span class="built_in">Mat</span>(), <span class="number">0</span>, result, GEMM_2_T );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">gemm</span>( eigenvectors, tmp_data, <span class="number">1</span>, <span class="built_in">Mat</span>(), <span class="number">0</span>, result, <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">PCA::project</span><span class="params">(InputArray data)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat result;</span><br><span class="line">    <span class="built_in">project</span>(data, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PCA::backProject</span><span class="params">(InputArray _data, OutputArray result)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat data = _data.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="built_in">CV_Assert</span>( !mean.<span class="built_in">empty</span>() &amp;&amp; !eigenvectors.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">        ((mean.rows == <span class="number">1</span> &amp;&amp; eigenvectors.rows == data.cols) ||</span><br><span class="line">         (mean.cols == <span class="number">1</span> &amp;&amp; eigenvectors.rows == data.rows)));</span><br><span class="line"></span><br><span class="line">    Mat tmp_data, tmp_mean;</span><br><span class="line">    data.<span class="built_in">convertTo</span>(tmp_data, mean.<span class="built_in">type</span>());</span><br><span class="line">    <span class="keyword">if</span>( mean.rows == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_mean = <span class="built_in">repeat</span>(mean, data.rows, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">gemm</span>( tmp_data, eigenvectors, <span class="number">1</span>, tmp_mean, <span class="number">1</span>, result, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp_mean = <span class="built_in">repeat</span>(mean, <span class="number">1</span>, data.cols);</span><br><span class="line">        <span class="built_in">gemm</span>( eigenvectors, tmp_data, <span class="number">1</span>, tmp_mean, <span class="number">1</span>, result, GEMM_1_T );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">PCA::backProject</span><span class="params">(InputArray data)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat result;</span><br><span class="line">    <span class="built_in">backProject</span>(data, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCACompute</span><span class="params">(InputArray data, InputOutputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    OutputArray eigenvectors, <span class="keyword">int</span> maxComponents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    <span class="built_in">pca</span>(data, mean, <span class="number">0</span>, maxComponents);</span><br><span class="line">    pca.mean.<span class="built_in">copyTo</span>(mean);</span><br><span class="line">    pca.eigenvectors.<span class="built_in">copyTo</span>(eigenvectors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCACompute</span><span class="params">(InputArray data, InputOutputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    OutputArray eigenvectors, OutputArray eigenvalues,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span> maxComponents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    <span class="built_in">pca</span>(data, mean, <span class="number">0</span>, maxComponents);</span><br><span class="line">    pca.mean.<span class="built_in">copyTo</span>(mean);</span><br><span class="line">    pca.eigenvectors.<span class="built_in">copyTo</span>(eigenvectors);</span><br><span class="line">    pca.eigenvalues.<span class="built_in">copyTo</span>(eigenvalues);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCACompute</span><span class="params">(InputArray data, InputOutputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    OutputArray eigenvectors, <span class="keyword">double</span> retainedVariance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    <span class="built_in">pca</span>(data, mean, <span class="number">0</span>, retainedVariance);</span><br><span class="line">    pca.mean.<span class="built_in">copyTo</span>(mean);</span><br><span class="line">    pca.eigenvectors.<span class="built_in">copyTo</span>(eigenvectors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCACompute</span><span class="params">(InputArray data, InputOutputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    OutputArray eigenvectors, OutputArray eigenvalues,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">double</span> retainedVariance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    <span class="built_in">pca</span>(data, mean, <span class="number">0</span>, retainedVariance);</span><br><span class="line">    pca.mean.<span class="built_in">copyTo</span>(mean);</span><br><span class="line">    pca.eigenvectors.<span class="built_in">copyTo</span>(eigenvectors);</span><br><span class="line">    pca.eigenvalues.<span class="built_in">copyTo</span>(eigenvalues);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCAProject</span><span class="params">(InputArray data, InputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    InputArray eigenvectors, OutputArray result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    pca.mean = mean.<span class="built_in">getMat</span>();</span><br><span class="line">    pca.eigenvectors = eigenvectors.<span class="built_in">getMat</span>();</span><br><span class="line">    pca.<span class="built_in">project</span>(data, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::PCABackProject</span><span class="params">(InputArray data, InputArray mean,</span></span></span><br><span class="line"><span class="params"><span class="function">                    InputArray eigenvectors, OutputArray result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    PCA pca;</span><br><span class="line">    pca.mean = mean.<span class="built_in">getMat</span>();</span><br><span class="line">    pca.eigenvectors = eigenvectors.<span class="built_in">getMat</span>();</span><br><span class="line">    pca.<span class="built_in">backProject</span>(data, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类中的calcCovarMatrix函数实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcCovarMatrix</span><span class="params">( <span class="keyword">const</span> Mat* data, <span class="keyword">int</span> nsamples, Mat&amp; covar, Mat&amp; _mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> ctype )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CV_Assert_N</span>( data, nsamples &gt; <span class="number">0</span> );</span><br><span class="line">    Size size = data[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> sz = size.width * size.height, esz = (<span class="keyword">int</span>)data[<span class="number">0</span>].<span class="built_in">elemSize</span>();</span><br><span class="line">    <span class="keyword">int</span> type = data[<span class="number">0</span>].<span class="built_in">type</span>();</span><br><span class="line">    Mat mean;</span><br><span class="line">    ctype = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(<span class="built_in">CV_MAT_DEPTH</span>(ctype &gt;= <span class="number">0</span> ? ctype : type), _mean.<span class="built_in">depth</span>()), CV_32F);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (flags &amp; CV_COVAR_USE_AVG) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_Assert</span>( _mean.<span class="built_in">size</span>() == size );</span><br><span class="line">        <span class="keyword">if</span>( _mean.<span class="built_in">isContinuous</span>() &amp;&amp; _mean.<span class="built_in">type</span>() == ctype )</span><br><span class="line">            mean = _mean.<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _mean.<span class="built_in">convertTo</span>(mean, ctype);</span><br><span class="line">            mean = mean.<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat _data(nsamples, sz, type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nsamples; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_Assert_N</span>( data[i].<span class="built_in">size</span>() == size, data[i].<span class="built_in">type</span>() == type );</span><br><span class="line">        <span class="keyword">if</span>( data[i].<span class="built_in">isContinuous</span>() )</span><br><span class="line">            <span class="built_in">memcpy</span>( _data.<span class="built_in">ptr</span>(i), data[i].<span class="built_in">ptr</span>(), sz*esz );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Mat <span class="built_in">dataRow</span>(size.height, size.width, type, _data.<span class="built_in">ptr</span>(i));</span><br><span class="line">            data[i].<span class="built_in">copyTo</span>(dataRow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calcCovarMatrix</span>( _data, covar, mean, (flags &amp; ~(CV_COVAR_ROWS|CV_COVAR_COLS)) | CV_COVAR_ROWS, ctype );</span><br><span class="line">    <span class="keyword">if</span>( (flags &amp; CV_COVAR_USE_AVG) == <span class="number">0</span> )</span><br><span class="line">        _mean = mean.<span class="built_in">reshape</span>(<span class="number">1</span>, size.height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcCovarMatrix</span><span class="params">( InputArray _src, OutputArray _covar, InputOutputArray _mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> ctype )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_src.<span class="built_in">kind</span>() == _InputArray::STD_VECTOR_MAT || _src.<span class="built_in">kind</span>() == _InputArray::STD_ARRAY_MAT)</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;cv::Mat&gt; src;</span><br><span class="line">        _src.<span class="built_in">getMatVector</span>(src);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CV_Assert</span>( src.<span class="built_in">size</span>() &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Size size = src[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> type = src[<span class="number">0</span>].<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">        ctype = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(<span class="built_in">CV_MAT_DEPTH</span>(ctype &gt;= <span class="number">0</span> ? ctype : type), _mean.<span class="built_in">depth</span>()), CV_32F);</span><br><span class="line"></span><br><span class="line">        Mat _data(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(src.<span class="built_in">size</span>()), size.<span class="built_in">area</span>(), type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(std::vector&lt;cv::Mat&gt;::iterator each = src.<span class="built_in">begin</span>(); each != src.<span class="built_in">end</span>(); ++each, ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CV_Assert_N</span>( (*each).<span class="built_in">size</span>() == size, (*each).<span class="built_in">type</span>() == type );</span><br><span class="line">            <span class="function">Mat <span class="title">dataRow</span><span class="params">(size.height, size.width, type, _data.ptr(i))</span></span>;</span><br><span class="line">            (*each).<span class="built_in">copyTo</span>(dataRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Mat mean;</span><br><span class="line">        <span class="keyword">if</span>( (flags &amp; CV_COVAR_USE_AVG) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CV_Assert</span>( _mean.<span class="built_in">size</span>() == size );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( mean.<span class="built_in">type</span>() != ctype )</span><br><span class="line">            &#123;</span><br><span class="line">                mean = _mean.<span class="built_in">getMat</span>();</span><br><span class="line">                _mean.<span class="built_in">create</span>(mean.<span class="built_in">size</span>(), ctype);</span><br><span class="line">                Mat tmp = _mean.<span class="built_in">getMat</span>();</span><br><span class="line">                mean.<span class="built_in">convertTo</span>(tmp, ctype);</span><br><span class="line">                mean = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mean = _mean.<span class="built_in">getMat</span>().<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">calcCovarMatrix</span>( _data, _covar, mean, (flags &amp; ~(CV_COVAR_ROWS|CV_COVAR_COLS)) | CV_COVAR_ROWS, ctype );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (flags &amp; CV_COVAR_USE_AVG) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            mean = mean.<span class="built_in">reshape</span>(<span class="number">1</span>, size.height);</span><br><span class="line">            mean.<span class="built_in">copyTo</span>(_mean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat data = _src.<span class="built_in">getMat</span>(), mean;</span><br><span class="line">    <span class="built_in">CV_Assert</span>( ((flags &amp; CV_COVAR_ROWS) != <span class="number">0</span>) ^ ((flags &amp; CV_COVAR_COLS) != <span class="number">0</span>) );</span><br><span class="line">    <span class="keyword">bool</span> takeRows = (flags &amp; CV_COVAR_ROWS) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> type = data.<span class="built_in">type</span>();</span><br><span class="line">    <span class="keyword">int</span> nsamples = takeRows ? data.rows : data.cols;</span><br><span class="line">    <span class="built_in">CV_Assert</span>( nsamples &gt; <span class="number">0</span> );</span><br><span class="line">    Size size = takeRows ? <span class="built_in">Size</span>(data.cols, <span class="number">1</span>) : <span class="built_in">Size</span>(<span class="number">1</span>, data.rows);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (flags &amp; CV_COVAR_USE_AVG) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        mean = _mean.<span class="built_in">getMat</span>();</span><br><span class="line">        ctype = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(<span class="built_in">CV_MAT_DEPTH</span>(ctype &gt;= <span class="number">0</span> ? ctype : type), mean.<span class="built_in">depth</span>()), CV_32F);</span><br><span class="line">        <span class="built_in">CV_Assert</span>( mean.<span class="built_in">size</span>() == size );</span><br><span class="line">        <span class="keyword">if</span>( mean.<span class="built_in">type</span>() != ctype )</span><br><span class="line">        &#123;</span><br><span class="line">            _mean.<span class="built_in">create</span>(mean.<span class="built_in">size</span>(), ctype);</span><br><span class="line">            Mat tmp = _mean.<span class="built_in">getMat</span>();</span><br><span class="line">            mean.<span class="built_in">convertTo</span>(tmp, ctype);</span><br><span class="line">            mean = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ctype = std::<span class="built_in">max</span>(<span class="built_in">CV_MAT_DEPTH</span>(ctype &gt;= <span class="number">0</span> ? ctype : type), CV_32F);</span><br><span class="line">        <span class="built_in">reduce</span>( _src, _mean, takeRows ? <span class="number">0</span> : <span class="number">1</span>, CV_REDUCE_AVG, ctype );</span><br><span class="line">        mean = _mean.<span class="built_in">getMat</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mulTransposed</span>( data, _covar, ((flags &amp; CV_COVAR_NORMAL) == <span class="number">0</span>) ^ takeRows,</span><br><span class="line">        mean, (flags &amp; CV_COVAR_SCALE) != <span class="number">0</span> ? <span class="number">1.</span>/nsamples : <span class="number">1</span>, ctype );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calcCovarMatrix函数中，mulTransposed函数的实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mulTransposed</span><span class="params">(InputArray _src, OutputArray _dst, <span class="keyword">bool</span> ata,</span></span></span><br><span class="line"><span class="params"><span class="function">                   InputArray _delta, <span class="keyword">double</span> scale, <span class="keyword">int</span> dtype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_INSTRUMENT_REGION</span>();</span><br><span class="line"></span><br><span class="line">    Mat src = _src.<span class="built_in">getMat</span>(), delta = _delta.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> gemm_level = <span class="number">100</span>; <span class="comment">// boundary above which GEMM is faster.</span></span><br><span class="line">    <span class="keyword">int</span> stype = src.<span class="built_in">type</span>();</span><br><span class="line">    dtype = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(<span class="built_in">CV_MAT_DEPTH</span>(dtype &gt;= <span class="number">0</span> ? dtype : stype), delta.<span class="built_in">depth</span>()), CV_32F);</span><br><span class="line">    <span class="built_in">CV_Assert</span>( src.<span class="built_in">channels</span>() == <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !delta.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_Assert_N</span>( delta.<span class="built_in">channels</span>() == <span class="number">1</span>,</span><br><span class="line">            (delta.rows == src.rows || delta.rows == <span class="number">1</span>),</span><br><span class="line">            (delta.cols == src.cols || delta.cols == <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>( delta.<span class="built_in">type</span>() != dtype )</span><br><span class="line">            delta.<span class="built_in">convertTo</span>(delta, dtype);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dsize = ata ? src.cols : src.rows;</span><br><span class="line">    _dst.<span class="built_in">create</span>( dsize, dsize, dtype );</span><br><span class="line">    Mat dst = _dst.<span class="built_in">getMat</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( src.data == dst.data || (stype == dtype &amp;&amp;</span><br><span class="line">        (dst.cols &gt;= gemm_level &amp;&amp; dst.rows &gt;= gemm_level &amp;&amp;</span><br><span class="line">         src.cols &gt;= gemm_level &amp;&amp; src.rows &gt;= gemm_level)))</span><br><span class="line">    &#123;</span><br><span class="line">        Mat src2;</span><br><span class="line">        <span class="keyword">const</span> Mat* tsrc = &amp;src;</span><br><span class="line">        <span class="keyword">if</span>( !delta.<span class="built_in">empty</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( delta.<span class="built_in">size</span>() == src.<span class="built_in">size</span>() )</span><br><span class="line">                <span class="built_in">subtract</span>( src, delta, src2 );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">repeat</span>(delta, src.rows/delta.rows, src.cols/delta.cols, src2);</span><br><span class="line">                <span class="built_in">subtract</span>( src, src2, src2 );</span><br><span class="line">            &#125;</span><br><span class="line">            tsrc = &amp;src2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">gemm</span>( *tsrc, *tsrc, scale, <span class="built_in">Mat</span>(), <span class="number">0</span>, dst, ata ? GEMM_1_T : GEMM_2_T );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        MulTransposedFunc func = <span class="built_in">getMulTransposedFunc</span>(stype, dtype, ata);</span><br><span class="line">        <span class="keyword">if</span>( !func )</span><br><span class="line">            <span class="built_in">CV_Error</span>( CV_StsUnsupportedFormat, <span class="string">&quot;&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">func</span>( src, dst, delta, scale );</span><br><span class="line">        <span class="built_in">completeSymm</span>( dst, <span class="literal">false</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是getMulTransposedFunc函数的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MulTransposedFunc <span class="title">getMulTransposedFunc</span><span class="params">(<span class="keyword">int</span> stype, <span class="keyword">int</span> dtype, <span class="keyword">bool</span> ata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MulTransposedFunc func = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (stype == CV_8U &amp;&amp; dtype == CV_32F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;uchar,<span class="keyword">float</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;uchar,<span class="keyword">float</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stype == CV_8U &amp;&amp; dtype == CV_64F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;uchar,<span class="keyword">double</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;uchar,<span class="keyword">double</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_16U &amp;&amp; dtype == CV_32F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;ushort,<span class="keyword">float</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;ushort,<span class="keyword">float</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_16U &amp;&amp; dtype == CV_64F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;ushort,<span class="keyword">double</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;ushort,<span class="keyword">double</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_16S &amp;&amp; dtype == CV_32F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;<span class="keyword">short</span>,<span class="keyword">float</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;<span class="keyword">short</span>,<span class="keyword">float</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_16S &amp;&amp; dtype == CV_64F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;<span class="keyword">short</span>,<span class="keyword">double</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;<span class="keyword">short</span>,<span class="keyword">double</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_32F &amp;&amp; dtype == CV_32F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;<span class="keyword">float</span>,<span class="keyword">float</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;<span class="keyword">float</span>,<span class="keyword">float</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_32F &amp;&amp; dtype == CV_64F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;<span class="keyword">float</span>,<span class="keyword">double</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;<span class="keyword">float</span>,<span class="keyword">double</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stype == CV_64F &amp;&amp; dtype == CV_64F)</span><br><span class="line">    &#123;</span><br><span class="line">        func = ata ? MulTransposedR&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;</span><br><span class="line">                   : MulTransposedL&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CV_Assert</span>(func &amp;&amp; <span class="string">&quot;Not supported&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是MulTransposedR和MulTransposedL的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> sT, <span class="keyword">typename</span> dT&gt; <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">MulTransposedR</span><span class="params">(<span class="keyword">const</span> Mat&amp; srcmat, <span class="keyword">const</span> Mat&amp; dstmat, <span class="keyword">const</span> Mat&amp; deltamat, <span class="keyword">double</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">const</span> sT* src = srcmat.ptr&lt;sT&gt;();</span><br><span class="line">    dT* dst = (dT*)dstmat.ptr&lt;dT&gt;();</span><br><span class="line">    <span class="keyword">const</span> dT* delta = deltamat.ptr&lt;dT&gt;();</span><br><span class="line">    <span class="keyword">size_t</span> srcstep = srcmat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(src[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">size_t</span> dststep = dstmat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(dst[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">size_t</span> deltastep = deltamat.rows &gt; <span class="number">1</span> ? deltamat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(delta[<span class="number">0</span>]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> delta_cols = deltamat.cols;</span><br><span class="line">    Size size = srcmat.<span class="built_in">size</span>();</span><br><span class="line">    dT* tdst = dst;</span><br><span class="line">    dT* col_buf = <span class="number">0</span>;</span><br><span class="line">    dT* delta_buf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buf_size = size.height*<span class="built_in"><span class="keyword">sizeof</span></span>(dT);</span><br><span class="line">    AutoBuffer&lt;uchar&gt; buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( delta &amp;&amp; delta_cols &lt; size.width )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>( delta_cols == <span class="number">1</span> );</span><br><span class="line">        buf_size *= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf.<span class="built_in">allocate</span>(buf_size);</span><br><span class="line">    col_buf = (dT*)buf.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( delta &amp;&amp; delta_cols &lt; size.width )</span><br><span class="line">    &#123;</span><br><span class="line">        delta_buf = col_buf + size.height;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size.height; i++ )</span><br><span class="line">            delta_buf[i*<span class="number">4</span>] = delta_buf[i*<span class="number">4</span>+<span class="number">1</span>] =</span><br><span class="line">                delta_buf[i*<span class="number">4</span>+<span class="number">2</span>] = delta_buf[i*<span class="number">4</span>+<span class="number">3</span>] = delta[i*deltastep];</span><br><span class="line">        delta = delta_buf;</span><br><span class="line">        deltastep = deltastep ? <span class="number">4</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CV_SIMD_64F</span></span><br><span class="line">    v_float64x2 v_scale = <span class="built_in">v_setall_f64</span>(scale);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !delta )</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size.width; i++, tdst += dststep )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++ )</span><br><span class="line">                col_buf[k] = src[k*srcstep+i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( j = i; j &lt;= size.width - <span class="number">4</span>; j += <span class="number">4</span> )</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CV_SIMD_64F</span></span><br><span class="line">                <span class="keyword">if</span> (DataType&lt;sT&gt;::depth == CV_64F &amp;&amp; DataType&lt;dT&gt;::depth == CV_64F)</span><br><span class="line">                &#123;</span><br><span class="line">                    v_float64x2 s0 = <span class="built_in">v_setzero_f64</span>(), s1 = <span class="built_in">v_setzero_f64</span>();</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *tsrc = (<span class="keyword">double</span>*)(src + j);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc += srcstep )</span><br><span class="line">                    &#123;</span><br><span class="line">                        v_float64x2 a = <span class="built_in">v_setall_f64</span>((<span class="keyword">double</span>)col_buf[k]);</span><br><span class="line">                        s0 += a * <span class="built_in">v_load</span>(tsrc+<span class="number">0</span>);</span><br><span class="line">                        s1 += a * <span class="built_in">v_load</span>(tsrc+<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">v_store</span>((<span class="keyword">double</span>*)(tdst+j), s0*v_scale);</span><br><span class="line">                    <span class="built_in">v_store</span>((<span class="keyword">double</span>*)(tdst+j+<span class="number">2</span>), s1*v_scale);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">double</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">const</span> sT *tsrc = src + j;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc += srcstep )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">double</span> a = col_buf[k];</span><br><span class="line">                        s0 += a * tsrc[<span class="number">0</span>];</span><br><span class="line">                        s1 += a * tsrc[<span class="number">1</span>];</span><br><span class="line">                        s2 += a * tsrc[<span class="number">2</span>];</span><br><span class="line">                        s3 += a * tsrc[<span class="number">3</span>];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    tdst[j] = (dT)(s0*scale);</span><br><span class="line">                    tdst[j+<span class="number">1</span>] = (dT)(s1*scale);</span><br><span class="line">                    tdst[j+<span class="number">2</span>] = (dT)(s2*scale);</span><br><span class="line">                    tdst[j+<span class="number">3</span>] = (dT)(s3*scale);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( ; j &lt; size.width; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> s0 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> sT *tsrc = src + j;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc += srcstep )</span><br><span class="line">                    s0 += (<span class="keyword">double</span>)col_buf[k] * tsrc[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                tdst[j] = (dT)(s0*scale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size.width; i++, tdst += dststep )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !delta_buf )</span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++ )</span><br><span class="line">                    col_buf[k] = src[k*srcstep+i] - delta[k*deltastep+i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++ )</span><br><span class="line">                    col_buf[k] = src[k*srcstep+i] - delta_buf[k*deltastep];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( j = i; j &lt;= size.width - <span class="number">4</span>; j += <span class="number">4</span> )</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CV_SIMD_64F</span></span><br><span class="line">                <span class="keyword">if</span> (DataType&lt;sT&gt;::depth == CV_64F &amp;&amp; DataType&lt;dT&gt;::depth == CV_64F)</span><br><span class="line">                &#123;</span><br><span class="line">                    v_float64x2 s0 = <span class="built_in">v_setzero_f64</span>(), s1 = <span class="built_in">v_setzero_f64</span>();</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *tsrc = (<span class="keyword">double</span>*)(src + j);</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *d = (<span class="keyword">double</span>*)(delta_buf ? delta_buf : delta + j);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc+=srcstep, d+=deltastep )</span><br><span class="line">                    &#123;</span><br><span class="line">                        v_float64x2 a = <span class="built_in">v_setall_f64</span>((<span class="keyword">double</span>)col_buf[k]);</span><br><span class="line">                        s0 += a * (<span class="built_in">v_load</span>(tsrc+<span class="number">0</span>) - <span class="built_in">v_load</span>(d+<span class="number">0</span>));</span><br><span class="line">                        s1 += a * (<span class="built_in">v_load</span>(tsrc+<span class="number">2</span>) - <span class="built_in">v_load</span>(d+<span class="number">2</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">v_store</span>((<span class="keyword">double</span>*)(tdst+j), s0*v_scale);</span><br><span class="line">                    <span class="built_in">v_store</span>((<span class="keyword">double</span>*)(tdst+j+<span class="number">2</span>), s1*v_scale);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">double</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">const</span> sT *tsrc = src + j;</span><br><span class="line">                    <span class="keyword">const</span> dT *d = delta_buf ? delta_buf : delta + j;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc+=srcstep, d+=deltastep )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">double</span> a = col_buf[k];</span><br><span class="line">                        s0 += a * (tsrc[<span class="number">0</span>] - d[<span class="number">0</span>]);</span><br><span class="line">                        s1 += a * (tsrc[<span class="number">1</span>] - d[<span class="number">1</span>]);</span><br><span class="line">                        s2 += a * (tsrc[<span class="number">2</span>] - d[<span class="number">2</span>]);</span><br><span class="line">                        s3 += a * (tsrc[<span class="number">3</span>] - d[<span class="number">3</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    tdst[j] = (dT)(s0*scale);</span><br><span class="line">                    tdst[j+<span class="number">1</span>] = (dT)(s1*scale);</span><br><span class="line">                    tdst[j+<span class="number">2</span>] = (dT)(s2*scale);</span><br><span class="line">                    tdst[j+<span class="number">3</span>] = (dT)(s3*scale);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( ; j &lt; size.width; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> s0 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> sT *tsrc = src + j;</span><br><span class="line">                <span class="keyword">const</span> dT *d = delta_buf ? delta_buf : delta + j;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.height; k++, tsrc+=srcstep, d+=deltastep )</span><br><span class="line">                    s0 += (<span class="keyword">double</span>)col_buf[k] * (tsrc[<span class="number">0</span>] - d[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                tdst[j] = (dT)(s0*scale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> sT, <span class="keyword">typename</span> dT&gt; <span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">MulTransposedL</span><span class="params">(<span class="keyword">const</span> Mat&amp; srcmat, <span class="keyword">const</span> Mat&amp; dstmat, <span class="keyword">const</span> Mat&amp; deltamat, <span class="keyword">double</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">const</span> sT* src = srcmat.ptr&lt;sT&gt;();</span><br><span class="line">    dT* dst = (dT*)dstmat.ptr&lt;dT&gt;();</span><br><span class="line">    <span class="keyword">const</span> dT* delta = deltamat.ptr&lt;dT&gt;();</span><br><span class="line">    <span class="keyword">size_t</span> srcstep = srcmat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(src[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">size_t</span> dststep = dstmat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(dst[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">size_t</span> deltastep = deltamat.rows &gt; <span class="number">1</span> ? deltamat.step/<span class="built_in"><span class="keyword">sizeof</span></span>(delta[<span class="number">0</span>]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> delta_cols = deltamat.cols;</span><br><span class="line">    Size size = srcmat.<span class="built_in">size</span>();</span><br><span class="line">    dT* tdst = dst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !delta )</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size.height; i++, tdst += dststep )</span><br><span class="line">            <span class="keyword">for</span>( j = i; j &lt; size.height; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> sT *tsrc1 = src + i*srcstep;</span><br><span class="line">                <span class="keyword">const</span> sT *tsrc2 = src + j*srcstep;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CV_SIMD_64F</span></span><br><span class="line">                <span class="keyword">if</span> (DataType&lt;sT&gt;::depth == CV_64F &amp;&amp; DataType&lt;dT&gt;::depth == CV_64F)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *v_tsrc1 = (<span class="keyword">double</span> *)(tsrc1);</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *v_tsrc2 = (<span class="keyword">double</span> *)(tsrc2);</span><br><span class="line">                    v_float64x2 v_s = <span class="built_in">v_setzero_f64</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt;= size.width - <span class="number">4</span>; k += <span class="number">4</span> )</span><br><span class="line">                        v_s += (<span class="built_in">v_load</span>(v_tsrc1+k) * <span class="built_in">v_load</span>(v_tsrc2+k)) +</span><br><span class="line">                               (<span class="built_in">v_load</span>(v_tsrc1+k+<span class="number">2</span>) * <span class="built_in">v_load</span>(v_tsrc2+k+<span class="number">2</span>));</span><br><span class="line">                    s += <span class="built_in">v_reduce_sum</span>(v_s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt;= size.width - <span class="number">4</span>; k += <span class="number">4</span> )</span><br><span class="line">                        s += (<span class="keyword">double</span>)tsrc1[k]*tsrc2[k] + (<span class="keyword">double</span>)tsrc1[k+<span class="number">1</span>]*tsrc2[k+<span class="number">1</span>] +</span><br><span class="line">                             (<span class="keyword">double</span>)tsrc1[k+<span class="number">2</span>]*tsrc2[k+<span class="number">2</span>] + (<span class="keyword">double</span>)tsrc1[k+<span class="number">3</span>]*tsrc2[k+<span class="number">3</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>( ; k &lt; size.width; k++ )</span><br><span class="line">                    s += (<span class="keyword">double</span>)tsrc1[k] * tsrc2[k];</span><br><span class="line">                tdst[j] = (dT)(s*scale);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dT delta_buf[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> delta_shift = delta_cols == size.width ? <span class="number">4</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="function">AutoBuffer&lt;uchar&gt; <span class="title">buf</span><span class="params">(size.width*<span class="keyword">sizeof</span>(dT))</span></span>;</span><br><span class="line">        dT* row_buf = (dT*)buf.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; size.height; i++, tdst += dststep )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> sT *tsrc1 = src + i*srcstep;</span><br><span class="line">            <span class="keyword">const</span> dT *tdelta1 = delta + i*deltastep;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( delta_cols &lt; size.width )</span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.width; k++ )</span><br><span class="line">                    row_buf[k] = tsrc1[k] - tdelta1[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; size.width; k++ )</span><br><span class="line">                    row_buf[k] = tsrc1[k] - tdelta1[k];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>( j = i; j &lt; size.height; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">const</span> sT *tsrc2 = src + j*srcstep;</span><br><span class="line">                <span class="keyword">const</span> dT *tdelta2 = delta + j*deltastep;</span><br><span class="line">                <span class="keyword">if</span>( delta_cols &lt; size.width )</span><br><span class="line">                &#123;</span><br><span class="line">                    delta_buf[<span class="number">0</span>] = delta_buf[<span class="number">1</span>] =</span><br><span class="line">                        delta_buf[<span class="number">2</span>] = delta_buf[<span class="number">3</span>] = tdelta2[<span class="number">0</span>];</span><br><span class="line">                    tdelta2 = delta_buf;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CV_SIMD_64F</span></span><br><span class="line">                <span class="keyword">if</span> (DataType&lt;sT&gt;::depth == CV_64F &amp;&amp; DataType&lt;dT&gt;::depth == CV_64F)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *v_tsrc2 = (<span class="keyword">double</span> *)(tsrc2);</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *v_tdelta2 = (<span class="keyword">double</span> *)(tdelta2);</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> *v_row_buf = (<span class="keyword">double</span> *)(row_buf);</span><br><span class="line">                    v_float64x2 v_s = <span class="built_in">v_setzero_f64</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt;= size.width - <span class="number">4</span>; k += <span class="number">4</span>, v_tdelta2 += delta_shift )</span><br><span class="line">                        v_s += ((<span class="built_in">v_load</span>(v_tsrc2+k) - <span class="built_in">v_load</span>(v_tdelta2)) * <span class="built_in">v_load</span>(v_row_buf+k)) +</span><br><span class="line">                               ((<span class="built_in">v_load</span>(v_tsrc2+k+<span class="number">2</span>) - <span class="built_in">v_load</span>(v_tdelta2+<span class="number">2</span>)) * <span class="built_in">v_load</span>(v_row_buf+k+<span class="number">2</span>));</span><br><span class="line">                    s += <span class="built_in">v_reduce_sum</span>(v_s);</span><br><span class="line"></span><br><span class="line">                    tdelta2 = (<span class="keyword">const</span> dT *)(v_tdelta2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt;= size.width<span class="number">-4</span>; k += <span class="number">4</span>, tdelta2 += delta_shift )</span><br><span class="line">                        s += (<span class="keyword">double</span>)row_buf[k]*(tsrc2[k] - tdelta2[<span class="number">0</span>]) +</span><br><span class="line">                             (<span class="keyword">double</span>)row_buf[k+<span class="number">1</span>]*(tsrc2[k+<span class="number">1</span>] - tdelta2[<span class="number">1</span>]) +</span><br><span class="line">                             (<span class="keyword">double</span>)row_buf[k+<span class="number">2</span>]*(tsrc2[k+<span class="number">2</span>] - tdelta2[<span class="number">2</span>]) +</span><br><span class="line">                             (<span class="keyword">double</span>)row_buf[k+<span class="number">3</span>]*(tsrc2[k+<span class="number">3</span>] - tdelta2[<span class="number">3</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>( ; k &lt; size.width; k++, tdelta2++ )</span><br><span class="line">                    s += (<span class="keyword">double</span>)row_buf[k]*(tsrc2[k] - tdelta2[<span class="number">0</span>]);</span><br><span class="line">                tdst[j] = (dT)(s*scale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面是OpenCV对于PCA算法的c++实现&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/04/excalidraw/bi-ye-she-ji/"/>
    <id>http://example.com/2023/03/04/excalidraw/bi-ye-she-ji/</id>
    <published>2023-03-04T13:17:29.290Z</published>
    <updated>2023-03-05T08:56:44.930Z</updated>
    
    <content type="html"><![CDATA[<p>==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==</p><h1 id="Text-Elements"><a href="#Text-Elements" class="headerlink" title="Text Elements"></a>Text Elements</h1><h1 id="Embedded-files"><a href="#Embedded-files" class="headerlink" title="Embedded files"></a>Embedded files</h1><p>5a757ff9f9b8f677b0343565157de4c2cc016b5d: [[Excalidraw/assets/毕业设计/Pasted Image 20230305165632_075.png]]</p><p>%%</p><h1 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;excalidraw&quot;</span>,</span><br><span class="line"><span class="attr">&quot;version&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">&quot;source&quot;</span>: <span class="string">&quot;https://excalidraw.com&quot;</span>,</span><br><span class="line"><span class="attr">&quot;elements&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;image&quot;</span>,</span><br><span class="line"><span class="attr">&quot;version&quot;</span>: <span class="number">76</span>,</span><br><span class="line"><span class="attr">&quot;versionNonce&quot;</span>: <span class="number">418227959</span>,</span><br><span class="line"><span class="attr">&quot;isDeleted&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: <span class="string">&quot;2UQPP8zmlbUeA063mCDd8&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fillStyle&quot;</span>: <span class="string">&quot;hachure&quot;</span>,</span><br><span class="line"><span class="attr">&quot;strokeWidth&quot;</span>: <span class="number">0.5</span>,</span><br><span class="line"><span class="attr">&quot;strokeStyle&quot;</span>: <span class="string">&quot;solid&quot;</span>,</span><br><span class="line"><span class="attr">&quot;roughness&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;opacity&quot;</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">&quot;angle&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;x&quot;</span>: <span class="number">-102.02320969266435</span>,</span><br><span class="line"><span class="attr">&quot;y&quot;</span>: <span class="number">-249.09310605686437</span>,</span><br><span class="line"><span class="attr">&quot;strokeColor&quot;</span>: <span class="string">&quot;transparent&quot;</span>,</span><br><span class="line"><span class="attr">&quot;backgroundColor&quot;</span>: <span class="string">&quot;transparent&quot;</span>,</span><br><span class="line"><span class="attr">&quot;width&quot;</span>: <span class="number">198.45414320576464</span>,</span><br><span class="line"><span class="attr">&quot;height&quot;</span>: <span class="number">459.4436755889085</span>,</span><br><span class="line"><span class="attr">&quot;seed&quot;</span>: <span class="number">1699889911</span>,</span><br><span class="line"><span class="attr">&quot;groupIds&quot;</span>: [],</span><br><span class="line"><span class="attr">&quot;strokeSharpness&quot;</span>: <span class="string">&quot;round&quot;</span>,</span><br><span class="line"><span class="attr">&quot;boundElements&quot;</span>: [],</span><br><span class="line"><span class="attr">&quot;updated&quot;</span>: <span class="number">1678006603368</span>,</span><br><span class="line"><span class="attr">&quot;link&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">&quot;locked&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">&quot;status&quot;</span>: <span class="string">&quot;pending&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fileId&quot;</span>: <span class="string">&quot;5a757ff9f9b8f677b0343565157de4c2cc016b5d&quot;</span>,</span><br><span class="line"><span class="attr">&quot;scale&quot;</span>: [</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">1</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;appState&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;theme&quot;</span>: <span class="string">&quot;light&quot;</span>,</span><br><span class="line"><span class="attr">&quot;viewBackgroundColor&quot;</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemStrokeColor&quot;</span>: <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemBackgroundColor&quot;</span>: <span class="string">&quot;transparent&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemFillStyle&quot;</span>: <span class="string">&quot;hachure&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemStrokeWidth&quot;</span>: <span class="number">0.5</span>,</span><br><span class="line"><span class="attr">&quot;currentItemStrokeStyle&quot;</span>: <span class="string">&quot;solid&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemRoughness&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;currentItemOpacity&quot;</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">&quot;currentItemFontFamily&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">&quot;currentItemFontSize&quot;</span>: <span class="number">28</span>,</span><br><span class="line"><span class="attr">&quot;currentItemTextAlign&quot;</span>: <span class="string">&quot;left&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemStrokeSharpness&quot;</span>: <span class="string">&quot;sharp&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemStartArrowhead&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">&quot;currentItemEndArrowhead&quot;</span>: <span class="string">&quot;arrow&quot;</span>,</span><br><span class="line"><span class="attr">&quot;currentItemLinearStrokeSharpness&quot;</span>: <span class="string">&quot;round&quot;</span>,</span><br><span class="line"><span class="attr">&quot;gridSize&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">&quot;colorPalette&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;files&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%%</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==&lt;/p&gt;
&lt;h1 id=&quot;Text-Elements&quot;&gt;&lt;a href=&quot;#Text-Elements&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="excalidraw" scheme="http://example.com/tags/excalidraw/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/04/bi-ye-lun-wen/f014-bi-ye-lun-wen-chu-gao-01/"/>
    <id>http://example.com/2023/03/04/bi-ye-lun-wen/f014-bi-ye-lun-wen-chu-gao-01/</id>
    <published>2023-03-04T12:37:32.084Z</published>
    <updated>2023-03-05T15:32:06.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><p>录入新员工功能包括:   获取新员工信息,   训练模型;   </p><p>打卡功能包括:   加载训练模型,   获取人脸图片,   识别人脸;   </p><img src="D:/Program%20Files/Typora/img/image-20230305221759217.png" alt="image-20230305221759217" style="zoom:80%;" /><ol><li><p>录入新员工功能</p><p>录取新员工首先要获取新员工的信息,   包括姓名与人脸图片，首先需要打开摄像头，从摄像头中不断捕捉图像帧，检测到捕捉的图像帧有人脸信息之后，才将图片存入人脸；将图片存入本地之后，需要对存入的图片进行训练，将得到训练模型存入本地，方便下此调用。</p></li><li><p>打卡功能</p><p>加载训练好的模型文件，打开摄像头，从摄像头中不断捕获图像帧，识别到捕捉的图像帧有人脸信息后，对该图像帧进行人脸识别，并返回识别结果。</p></li></ol><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>按照模块划分，人脸识别考勤系统可以分为用户界面模块，人脸识别模块，数据存储模块。</p><p>用户界面模块与用户和人脸识别模块进行交互。用户界面模块的功能包括：显示可视化界面及其对应的功能按钮、显示提示信息、读取图片并传入人脸识别模块、显示人脸识别模块传来的识别信息。</p><p>人脸识别模块是该系统的核心模块，它提供如下功能：</p><ol><li><p>人脸检测功能。主要为用户界面模块所调用，使其能够提供真正拥有人脸信息的图像。</p></li><li><p>生成存储图片的信息。为存储的图片生成对应的文件夹。</p></li><li><p>训练模型文件。将用户界面传过来的图片进行预处理，包括统一尺寸、灰度图与二值图的调整，然后进行模型训练，将训练好的模型传给数据存储模块。</p></li><li><p>人脸识别。读取数据存储模块提供的模型文件，对用户界面模块传来的人脸图片通过模型文件进行对比，将识别结果交付给用户界面模块，并将更新的信息传递给数据存储模块。</p></li></ol><p>数据存储模块与人脸识别模块进行交互。由于存在图片数据和员工信息数据，所以存储地点分为本地和数据库。本地负责存储员工人脸图片和模型文件，数据库负责存储员工姓名等信息。它的功能包括：存储信息、将数据传递给人脸识别模块、更新并保存从人脸识别模块传来的相关信息。</p><p>功能测试模块的功能包括调试、日志信息打印。</p><h1 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h1><h2 id="模块实现"><a href="#模块实现" class="headerlink" title="模块实现"></a>模块实现</h2><h3 id="用户界面模块"><a href="#用户界面模块" class="headerlink" title="用户界面模块"></a>用户界面模块</h3><p>用户界面模块是基于Java提供的原生套件Swing来实现的。其主要逻辑：提供一个唯一的主窗体，以及不同的面板，面板中显示所需要显示的各种信息与按键，面板显示在唯一主窗体上。当用户想要切换界面时，将唯一主窗体上现有的面板组件全部移除，创建新的所需要的面板，并放置在唯一主窗体上，通过这样的思路达到面板切换的功能。下面介绍主窗体与主要面板。</p><ol><li><p>主窗体</p><p>由于主窗体是全局唯一的，为了避免不必要的错误，使用单例模式创建主窗体类的对象，在主窗体类文件中创建其对象，并设置其类型为private static final，再设置该类的唯一构造方法为私有，对外只提供获取该对象指针的函数。主窗体提供的功能包括设置窗体关闭按钮监听、设置新面板的方法。</p></li><li><p>主面板</p><p>主面板提供的功能按钮包括打卡按钮和员工管理按钮。</p><p>打卡按钮监听：按下按钮后，调起摄像头并捕捉图像帧，通过人脸识别模块提供的人脸检测函数进行人脸检测，将含有人脸信息的图像传递给人脸识别模块进行人脸识别。</p><p>员工管理按钮监听：按下按钮后，进入员工管理面板。</p><p>主面板还包括一个信息提示框和摄像头实时显示框。在人脸识别模块将人脸识别的信息传递过来之后，主面板将该信息整合并显示到信息提示框上。当UI界面、摄像头实时显示框和打卡功能同时使用唯一主线程的时候，在按下打卡按钮进行人脸识别时，摄像头实时显示框会出现卡顿现象，这是由于不同功能同时使用主线程，导致主线程不得不来回中断以执行不同的功能。所以在实现的时候，另起一线程来完成摄像头实时显示的功能。</p><p>调起摄像头并获取摄像头的图像帧的功能可以通过OpenCV的jar包自带的操作摄像头相关的类来实现，也可以通过其他的jar包比如webcam来实现。考虑到摄像头需要实时显示在Swing提供的JPanel面板上，而webcam本来就提供继承于JPanel的WebcamPanel类，所以本系统采用webcam来实现摄像头相关功能。</p></li><li><p>员工管理面板</p><p>读取缓存类提供的员工信息，并将对应的信息显示在员工管理面板上，并提供返回主面板和转到录入新员工面板的按钮。</p></li><li><p>录入新员工面板</p><p>在该面板中完成新员工录入的功能。它包括一个姓名输入框，一个启动录入人脸功能的按钮，以及摄像头实时显示框。同样的，为了保证UI界面的流畅度，摄像头开启功能、录入人脸功能和摄像头实时显示功能采用异步的方式实现。</p><p>其中添加新员工功能流程图如下：</p><img src="D:/Program%20Files/Typora/img/image-20230305221722587.png" alt="image-20230305221722587" style="zoom:80%;" /><p>其中进行人脸检测的函数、将图片存入本地的函数都由人脸识别模块提供。</p></li></ol><h3 id="人脸识别模块"><a href="#人脸识别模块" class="headerlink" title="人脸识别模块"></a>人脸识别模块</h3><p>人脸识别模块所提供的功能有：保存人脸图片、引擎选择、人脸检测、人脸识别。</p><ol><li><p>保存人脸图片</p><p>人脸识别模块接收用户界面模块传来的人脸图片集合，将人脸图片存入本地。其流程为：</p><img src="D:/Program%20Files/Typora/img/image-20230305221652251.png" alt="image-20230305221652251" style="zoom:80%;" /><p>其中拼音转换功能使用的是pinyin4j的jar包，该jar包可以对同音的中文汉字进行不同拼音的转化，还可以对于非中文汉字字符选择性不转化。</p></li><li><p>引擎选择</p><p>本系统支持2种引擎，一是虹软科技提供的人脸识别引擎，二是通过OpenCV提供的人脸识别接口实现的引擎。</p><p>本系统提供配置文件对引擎进行选择，只需修改配置文件中的值就可以进行引擎的切换。</p><p>两种引擎都实现了人脸检测和人脸识别的功能。</p></li><li><p>人脸检测</p><p>（1）虹软引擎的人脸检测。流程如下：</p><img src="D:/Program%20Files/Typora/img/image-20230305222840644.png" alt="image-20230305222840644" style="zoom:80%;" /><p>其中，保存图像信息、人脸信息、人脸特征所需要的ImageInfo类、FaceInfo类和faceFeature类，以及对应的方法调用都来自于虹软引擎的开放API。</p><p>（2）基于OpenCV的人脸检测。其流程图如下：</p><img src="D:/Program%20Files/Typora/img/image-20230305224809284.png" alt="image-20230305224809284" style="zoom:80%;" /><p>需要注意的是，OpenCV人脸检测所得到的人脸检测结果为OpenCV提供的MatOfRect类，用于存储多个矩阵，也就是多张对输入图片进行检测并切分后的人脸图片，而虹软引擎最后的人脸特征为虹软人脸引擎API提供的FaceFeature类。但是由于这是人脸检测，所以只需要判断最后结果的有无，即对返回结果的判空即可。</p></li><li><p>人脸识别</p><p>人脸检测在本系统中只是起到一个优化系统的作用，真正实现考勤功能的是人脸识别功能。人脸识别功能可以分为两步，一是对目标图像进行训练，生成对应的模型文件，二是对所给定的图像进行比对，通过该图像上的人脸进行判别，进而确定此人的身份。</p><p>人脸识别功能需要对训练图像进行预分类，并设置每一类图像的标签之后，才能对给定的图像进行人脸识别，并返回标签。</p><p>而在本系统中，由于每个人的人脸图片的文件夹名称为相对应的人名的拼音，所以完全可以将每个人的文件夹名称作为该类图像的标签。</p><p>（1）虹软引擎的人脸识别训练。流程图如下：</p><img src="D:/Program%20Files/Typora/img/image-20230305233016778.png" alt="image-20230305233016778" style="zoom:80%;" /><p>其中faceMap类型为Java提供的集合HashMap。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;系统设计&quot;&gt;&lt;a href=&quot;#系统设计&quot; class=&quot;headerlink&quot; title=&quot;系统设计&quot;&gt;&lt;/a&gt;系统设计&lt;/h1&gt;&lt;h2 id=&quot;功能设计&quot;&gt;&lt;a href=&quot;#功能设计&quot; class=&quot;headerlink&quot; title=&quot;功能设计&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/01/shui-mian-yan-jiu/shui-mian-yan-jiu-jie-guo/"/>
    <id>http://example.com/2023/03/01/shui-mian-yan-jiu/shui-mian-yan-jiu-jie-guo/</id>
    <published>2023-03-01T08:42:25.017Z</published>
    <updated>2023-03-06T06:59:39.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="睡眠质量研究结果"><a href="#睡眠质量研究结果" class="headerlink" title="睡眠质量研究结果"></a>睡眠质量研究结果</h1><p>​    说是研究结果,   其实是自己摸索出来的一套能够提高睡眠质量的办法而已;   </p><h2 id="何谓睡得好"><a href="#何谓睡得好" class="headerlink" title="何谓睡得好"></a>何谓睡得好</h2><p>​    本人在高中时期就体验过一次,   那天午觉睡到了下午三点,   睡醒之后就觉得神清气爽的,   去教学楼的路上被叫去打篮球,   然后把对手打爆了🤣;   在大三下期结束后的那个暑假的一段时间里,   本人睡眠质量突然变好了,   而且感觉似乎是身体中有一股气在憋着,   这股气能够抵抗一些对睡眠时造成影响的因素;   但是很奇怪,   从那段时间之后,   那种尤为清醒的状态就再也没出现过了;   </p><p>​    而所谓的睡得好,   其实不是看刚睡醒时的清醒程度,   而是看睡醒之后学习时的大脑灵活度,   就是看大脑转得快不快,   如果快,   那就是睡了个好觉;   </p><p>​    而本人现在其实并不需要这种检测手段,   只需要稍微感受一下就知道自己是否睡好;   </p><p>​    <strong><font color='red'>说明:   睡眠质量对于一天的学习与工作的影响是没有任何其他手段能够更改或者提高的,   一个人可以以某种火热的激情投身学习,   但是不管动力如何强大,   精力与效率一定会大幅度受到睡眠质量的影响, </font></strong>   这也是本人一直努力寻找提升睡眠质量方法的原因;   </p><h2 id="不能提高睡眠质量的举措"><a href="#不能提高睡眠质量的举措" class="headerlink" title="不能提高睡眠质量的举措"></a>不能提高睡眠质量的举措</h2><p>(1) 负离子发生机<br>        本人错误地高估了负离子对于睡眠质量的提高程度;   实际上,   睡眠质量与空气负离子程度没有太大关系;   开启负离子发生机能够使人提前醒来,   这可能没有什么用,   因为不清楚其机制是什么,   是让人在睡眠循环的末尾进入浅睡眠状态然后提高苏醒的几率? 还是直接叫醒,   这一点还需要观察;   </p><p>(2) 服用艾草水,   使用艾草水泡脚或者进行艾灸<br>        前俩玩意儿对睡眠质量其实没有什么影响,   而且包括睡前泡脚和睡前洗澡,   其实对睡眠的影响都不大,   而艾灸后对睡眠有一定的影响,   不过我认为其影响应该是艾灸过程中释放的艾灸烟,   但是艾灸烟的过量吸入其实并不好;   </p><p>(3) 睡前服用某菊茶<br>        没用,   而且难喝!</p><p>(4) 睡前听ASMR<br>        对睡眠质量没啥影响,   但是我爱听🙃(好好想想你丫的为什么爱听!);   </p><p>(5) 挂遮光帘<br>        睡眠时的光线其实对睡眠有影响,   但是也没有太严重,   而如果光线全部遮挡完,   其实是不益于从睡眠中醒来的,   这一点稍后再谈;   </p><p>(6) 睡前积累几件今天做的好事🤣<br>        没用;   不仅对睡眠质量没影响,   对心情好像也没什么影响;   </p><p>(7) 听Subliminal🤣🤣🤣<br>        提示:   作为坚定的无产阶级战士,   笃信马克思哲学的我反对一切虚无缥缈的事物;   Subliminal说是利用音频来刺激人的潜意识啥的,   以前我可能还会信,   但是现在我一眼就认出来,   这玩意儿和七田真的照相记忆没啥区别嘛,   都是宣称能够利用潜意识来搞事情的;   而且没有达到效果的说辞非常多,   哎呀你肯定是没有找到合适的音频,   哎呀你肯定是心不够诚,   那人家七田真也有理由说呀,   哎呀你肯定是没有掌握其中的精髓…作为无产阶级战士,   需要坚信:   一切靠自己的打拼得来,   不要去想什么歪门邪道;   </p><p>(8) 对胃做功夫<br>        以前我认为睡不好,   很有可能是</p><h2 id="可以提高睡眠质量的举措"><a href="#可以提高睡眠质量的举措" class="headerlink" title="可以提高睡眠质量的举措"></a>可以提高睡眠质量的举措</h2><p>(1) 蚊帐<br>        本人是吸蚊体质,   所以深受蚊子的侵害;   其实蚊子叮咬对睡眠质量倒是没太大影响,   主要是蚊子在本人耳边飞过的时候所制造的噪音,   非常影响睡眠;   所以挂一个蚊帐非常有必要;   </p><p>(2) 增加睡眠时间<br>        睡眠时间与睡眠质量息息相关,   但并不是睡得越多越好;   睡得太短肯定不行,   比如有时本人午觉时被吵醒,   没有达到对应的睡眠时间,   下午不仅精神不好,   而且到一定时间还会继续睡😅;   但是适度增加睡眠时间是可以的;   稍微睡长一点反而会得到较好的睡眠质量;   </p><p>​    这里说一下赖床问题,   本人不怎么赖床,   如果一个人赖床了,   估计就是没睡够,   解决方法就是拿十几天想睡多久就睡多久,   自然会调整回来的;   </p><p>(3) 维持自身温度<br>        这一点非常非常重要 ! 在夏天一定不能让自己的睡眠环境太热,   这会影响睡眠质量;   在冬天一定不能让自己的睡眠环境太冷,   如果棉被太薄就再盖一件衣物;   本人就是这样,   冬天在家里睡得好好的,   一到学校睡眠质量就开始变差,   原因找来找去,   最后发现很有可能是南山上面较其他地区而言更冷;   而夏天,   家里人不允许一整夜开空调,   真是气煞我也;   </p><p>(4) 减少光线<br>        减少光线其实说的并不是很准确,   应该说是—减少<strong>人为直射</strong>光线;   夜晚本来应该是漆黑一片的,   但是电力的大范围使用,   夜晚之人类社会的各个角落都被人造光所填满,   而这些光线并不是人类睡眠所需要的,   尤其是这些光线成分中的蓝光,   其实在太阳下山之后就应该减少暴露在人造光下面的时间了,   日出而作,   日落而息就是最好的睡眠习惯;   前面提到,   遮光帘的确能够遮挡光线,   但是它的缺点是,   在太阳升起的时候依然遮住了阳光,   这就会让人体的机制认为还没有到白天,   一旦醒过来之后,   也会昏昏沉沉的;   减少光线的另一个点就是直射,   个人认为,   如果人造光不是直接射到人的脸上,   则稍微有一点也并无大碍,   但最好还是自然的没有(也就是夜晚目及之处没有光线与光源,   这是最好的);   </p><p>(5) 一个人睡<br>        一个人睡其实也就是避免室友的鼾声的影响;   由于本人高中和大学都在住校,   并且高中和大学的寝室里面各自都有不下两个人有打呼噜的习惯,   所以本人非常痛恨打呼噜的人;   别人的呼噜影响本人的入睡,   这是肯定的;   但是别人的呼噜是否会影响本人入睡后的睡眠质量,   这个我就不得而知了,   估计是有影响的;   希望工作之后能够一个人睡吧;   </p><p>(6) 养成喝豆浆的习惯</p><blockquote><p>这里总结一下那段时期的变量:   喝豆浆坚持约一个月、一个人睡、刚降温、没有太大的压力、没有早上打篮球、有练声的习惯;   </p></blockquote><p>​    喝豆浆是从那一段睡眠质量飙升的时期中积累下来的经验;   不过在那段时间之后我尝试复刻,   但是豆浆对于睡眠质量的影响好像并不大,   也可能是豆浆的量和黄豆的量的摄入不足,   因为那时候豆浆一天起码一升半;   “量”这个问题还是得好好研究一下;   </p><p>(7) 冥想<br>        指的是广义的冥想,   其实就是用感官去感受周围的一切,   冥想的时候我的心情是平静且愉悦的;   并不是说想要从宇宙中下载啥啥信息下来,   只是多利用一下感官而已;   吃饭走路发呆都可以冥想;   不过冥想对于睡眠质量的影响呢… 似乎没什么短期的正面影响;   </p><p>(8) 有了睡意再睡<br>        这一点非常重要,   如果能够搭配维持体温,   十有八九就能睡个好觉了;   重点就在于有睡意,   如果没有睡意硬躺下闭上眼的话,   其实醒来的精神是很差的;   </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>找一份朝九晚五的压力不这么大的工作,   一个人住,   一个人睡,   每天坚持喝自己打的豆浆,   把可支配的大部分时间花在自己感兴趣又能提升自己的事情上,   在心情和睡眠上形成正反馈,   安安稳稳快快乐乐平平淡淡地过完一生;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;睡眠质量研究结果&quot;&gt;&lt;a href=&quot;#睡眠质量研究结果&quot; class=&quot;headerlink&quot; title=&quot;睡眠质量研究结果&quot;&gt;&lt;/a&gt;睡眠质量研究结果&lt;/h1&gt;&lt;p&gt;​    说是研究结果,   其实是自己摸索出来的一套能够提高睡眠质量的办法而已;   &lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/01/hou-duan-gong-cheng-shi/spring01/"/>
    <id>http://example.com/2023/03/01/hou-duan-gong-cheng-shi/spring01/</id>
    <published>2023-03-01T00:38:33.216Z</published>
    <updated>2023-03-01T07:08:02.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring01"><a href="#Spring01" class="headerlink" title="Spring01"></a>Spring01</h1><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><ol><li><p>JSP+Servlet+JavaBean</p><p>JSP就是前端页面,   Servlet用于接收和处理请求,   JavaBean为相应的对象类,   有了这三个东西,   就可以组建一个服务了;   </p><p>而Web端开发,   实际上就是前端页面和后端处理的过程,    这两者之间的连接就是请求,   所以开发者通常需要在Servlet中撰写多个xml文件,   来实现前端打过来的请求的处理;   </p></li><li><p>MVC三层架构</p><p>browser层用于传递http请求和接收http请求;   controller层用于接收browser层传递过来的请求,   并向model层提交请求,   获取数据,   当然也可以接收model层传递的数据并将数据打包成http请求发给browser层;   而controller层如果直接返回接收到的数据,   那么browser层所接收到的就是一行一行的数据,   所以在返回的时候,   需要view层对数据进行渲染;   </p></li><li><p>EJB</p><p>重量型框架,   依赖和接口比较多,   对项目的侵入性强;   </p></li><li><p>SSH</p><p>配置麻烦;   </p></li><li><p>SSM</p><p><strong>Spring官网</strong> </p><p><a href="https://spring.io/projects/spring-framework#overview">官网地址</a> </p><p><a href="https://repo.spring.io/release/org/springframework/spring/">压缩包下载地址</a> </p><p><a href="https://github.com/spring-projects/spring-framework">源码地址</a> </p><blockquote><p>生态:   可能以后会出现超越Spring的更加优秀的框架,   那时,   要想Spring能够继续被用户使用,   就需要建立一个生态,   也就是说,   需要提供开发所需要的完整组件,   Spring能够和那些组件进行关联,   让开发者在使用Spring的时候,   如果Spring相关的组件,   能够简化开发,   久而久之,   就离不开Spring了;   </p></blockquote></li><li><p>SpringBoot</p></li></ol><h2 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h2><p>实现一个具体的业务代码,   一个服务类为了获取某些数据,   需要获取一个数据类的对象,   如果直接在这个服务类中实现对应的数据类的话,   在修改这个数据类的实现子类时,   会出现大量需要修改的地方;   所以可以在测试类中进行该数据类的对象创建,   然后传入服务类,   服务类在接收数据类对象的时候,   直接接收其抽象类;   </p><p>而这个过程中,   测试类的对象创建过程其实可以交给Spring来做,   这就是Ioc控制反转思想;   </p><blockquote><p>以前在创建对象的时候,   都是自己主动去创建对象,   而引入Ioc思想之后,   就是被动的接受对象,   仅需要把自己的需求交给提供者,   复杂的工作由提供者来做,   自己只需要被动接受即可;   </p><p>类似于共产社会当中,   每户家庭只需要把自己今天想吃的菜单放在门口,   国家会派专人往菜篮子里放菜;   </p></blockquote><p>有了IoC容器之后,   就会由IoC容器来控制对象;   </p><p>引入IoC容器可以解耦合;   在未引入IoC容器之时,   一个系统的各个对象很有可能是”你中调我,   我中调你”的;   引入之后,   IoC能够将各个对象进行解耦;   </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>导入beans,   context,   core,   expression,   以及common-logging的jar包,   即可使用Spring;   </p><p>首先创建对应的xml文件,   要使用spring config类型(要记住,   maven项目中,   xml文件是需要放在resources文件夹中的);   </p><p>然后在xml文件中写下对应的bean:   </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean标签表示要创建的对象</span></span><br><span class="line"><span class="comment">    id为bean的唯一标识, 为了跟其他的bean区分开来; 不能存在两个带有相同id的bean;</span></span><br><span class="line"><span class="comment">    class为要创建的bean的完全限定名,</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;T002_SpringIoC02.bean.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给属性赋值需要使用property标签</span></span><br><span class="line"><span class="comment">        name表示属性的名称;</span></span><br><span class="line"><span class="comment">        value表示具体的属性值;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Faker&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在测试类中,   生成对应的ApplicationContext,   通过强转或者反射机制来实现对象的获取:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*applicationContext表示IoC容器的入口,</span></span><br><span class="line"><span class="comment">        想要获取对象的话, 必须要创建该类, 该类由两个读取配置文件的实现类</span></span><br><span class="line"><span class="comment">        ClasspathXmlApplicationContext: 从classpath中读取数据</span></span><br><span class="line"><span class="comment">        FileSystemXmlApplicationContext: 从当前文件系统读取数据*/</span></span><br><span class="line">    ApplicationContext context =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;ioc.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取具体的bean实例对象, 需要进行强制类型转换</span></span><br><span class="line">    Person person = (Person) context.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">    Person person1 = context.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Person对象是何时被创建的? </p><p>容器中的对象在容器创建完成之前就已经把对象创建hk’le</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring01&quot;&gt;&lt;a href=&quot;#Spring01&quot; class=&quot;headerlink&quot; title=&quot;Spring01&quot;&gt;&lt;/a&gt;Spring01&lt;/h1&gt;&lt;h2 id=&quot;初识&quot;&gt;&lt;a href=&quot;#初识&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/21/tong-xin-yuan-li/xi-ti-02/"/>
    <id>http://example.com/2023/02/21/tong-xin-yuan-li/xi-ti-02/</id>
    <published>2023-02-21T15:08:08.583Z</published>
    <updated>2023-02-23T03:02:45.534Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ-ω-ρ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ-ω-ρ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ ω ρ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ ω ρ</h2><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h2><img src="D:/Program%20Files/Typora/img/image-20230221230838276.png" alt="image-20230221230838276" style="zoom:80%;" /><p>信息的周期为1ms,   载波的频率为2 * 10<sup>3</sup>Hz,   所以载波的周期为0.5ms,   信息的周期是载波的周期的两倍,   所以在画图的时候也要这个样子,   即一个周期之内,   载波要画两个周期;   </p><img src="D:/Program%20Files/Typora/img/image-20230221231120680.png" alt="image-20230221231120680" style="zoom: 67%;" /><img src="D:/Program%20Files/Typora/img/image-20230221231211902.png" alt="image-20230221231211902" style="zoom:80%;" /><blockquote><p>注意ASK的功率谱密度是有冲击的,   因为它的取值是0和1;   </p><p>而PSK的功率谱密度没有冲击,   因为它的取值是-1和1,   等概的情况下均值为0,   所以基带信号没有那个冲击;   </p></blockquote><p>(3) </p><img src="D:/Program%20Files/Typora/img/image-20230221231419306.png" alt="image-20230221231419306" style="zoom:80%;" /><blockquote><p>2ASK和2PSK的带宽是相同的,   都是基带信号的两倍;   </p></blockquote><h2 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h2><p>如果2FSK调制系统的符号速率为1200Baud,   数字信息为”1”和发”0”时的波形分别为s<sub>1</sub>(t)=cos(7200πt),   s<sub>2</sub>=cos(12000πt)<br>(1) 如果发送的数字信息为10011,   试画出2FSK信号的波形<br>(2) 如果发送数字信息是等概的,   试画出他的功率谱示意图<br>(3) 计算2FSK信号的近似带宽</p><p>注意</p><p>(1)</p><img src="D:/Program%20Files/Typora/img/image-20230221232020411.png" alt="image-20230221232020411"  /><blockquote><p>注意要对应上面那个关系;   </p></blockquote><p>(2) </p><p><img src="D:/Program%20Files/Typora/img/image-20230221232109657.png" alt="image-20230221232109657"></p><p>2FSK可以看作两个2ASK的合成,   所以它有4个波,   每个波都要有自己的冲击;   </p><p>(3) </p><img src="D:/Program%20Files/Typora/img/image-20230221232216239.png" alt="image-20230221232216239" style="zoom:80%;" /><blockquote><p>代公式即可;   B=|f<sub>2</sub>-f<sub>1</sub>|+2B;   </p></blockquote><h2 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h2><img src="D:/Program%20Files/Typora/img/image-20230222094908580.png" alt="image-20230222094908580" style="zoom:80%;" /><p>(1)</p><p>由于2PSK传递的是-1和1,   所以均值为0,   不过这好像没什么用…</p><img src="D:/Program%20Files/Typora/img/image-20230222095402190.png" alt="image-20230222095402190" style="zoom:80%;" /><p>因为是基带信号,   所以频谱利用率的公式右上写的是2;   用频谱利用率公式算出基带信号的带宽,   用R<sub>s</sub>和B<sub>N</sub>之间的关系算出B<sub>N</sub>,   然后画出基带信号的滚降波形即可;   </p><p>(2)</p><p>2PSK的信号就相当于把基带信号往两边搬移就行,   </p><img src="D:/Program%20Files/Typora/img/image-20230222095912956.png" alt="image-20230222095912956" style="zoom:80%;" /><p>(3) </p><img src="D:/Program%20Files/Typora/img/image-20230222095934886.png" alt="image-20230222095934886" style="zoom:80%;" /><p>其实因为画图需要带宽,   所以带宽应该提前算;   </p><h2 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h2><img src="D:/Program%20Files/Typora/img/image-20230222100038534.png" alt="image-20230222100038534" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222100020651.png" alt="image-20230222100020651" style="zoom:80%;" /><p>(1)</p><p>4进制符号PSK,   也就是这种东西能够表示4种波形,   所以需要两个比特;   在图中,   一个比特是A,   一个比特是B,   A和B经过各自的单双极性变换,   A’乘以cosω<sub>0</sub>t,   B’乘以-sinω<sub>0</sub>t,   然后两个相加得到一个表达式,   把A和B转化为A’和B’,   然后分别带到式子中去做正弦信号的三角函数式合并,   得到的相位就是A和B所对应的相位;   </p><img src="D:/Program%20Files/Typora/img/image-20230222101237978.png" alt="image-20230222101237978" style="zoom:80%;" /><p>(2)</p><p>求4PSK的频带利用率;   </p><blockquote><p>如果基带信号采用矩形波,   则其频带利用率为占空比D,   对应频带信号利用率为D/2;   </p><p>如果基带信号采用滚降波,   则其频带利用率为2/(1 + α),   对应频带利用率为1/(1+α);   </p></blockquote><p>由于采用的基带信号为不归零矩形波,   所以基带信号占空比为D=1,   </p><p>就可以推出对应的频带信号利用率R<sub>s</sub>/B=1/2,   B=2R<sub>s</sub>,   又因为是4PSK,   所以R<sub>b</sub>=R<sub>s</sub> log<sub>2</sub>M,   所以频带信号的信息频带利用率<br>$$<br>\frac{R_b}{B}=\frac{R_slog_24}{2R_s}=1bps/Hz<br>$$<br><img src="D:/Program%20Files/Typora/img/image-20230222103424384.png" alt="image-20230222103424384" style="zoom:80%;" /></p><h2 id="6-8"><a href="#6-8" class="headerlink" title="6.8"></a>6.8</h2><img src="D:/Program%20Files/Typora/img/image-20230222102416817.png" alt="image-20230222102416817" style="zoom:80%;" /><p>(1)<br>$$<br>\begin{align*}<br>&amp;上面这个函数需要两个正交基,   那么首先找到s_1(t)的正交基,   f’_1(t)=cos2\pi f_ct\\<br>&amp;然后再归一化,   f’_1(t)的能量为\frac{A^2}{2}T_b=\frac{T_b}{2}\\<br>&amp;所以f_1(t)=\frac{f’_1(t)}{\sqrt{E_b}}=\sqrt{\frac2{T_b}}cos2\pi f_ct<br>\end{align*}<br>$$<br>所以<img src="D:/Program%20Files/Typora/img/image-20230222142849268.png" alt="image-20230222142849268" style="zoom:80%;" /></p><p>然后就是他们的矢量图,   是一维的</p><img src="D:/Program%20Files/Typora/img/image-20230222143246351.png" alt="image-20230222143246351" style="zoom:80%;" /><p>(2)</p><p>欧氏距离就是两点的距离<img src="D:/Program%20Files/Typora/img/image-20230222143318699.png" alt="image-20230222143318699" style="zoom:80%;" />;   </p><p>(3)<br>$$<br>归一化相关系数ρ=\frac{s_1*s_2}{\sqrt{E_1}\sqrt{E_2}}=-1<br>$$<br><img src="D:/Program%20Files/Typora/img/image-20230222144003405.png" alt="image-20230222144003405" style="zoom:80%;" /></p><p>两个信号的能量都是E<sub>b</sub>,   平均比特能量就是两个能量加起来除以二;   </p><p>(4)</p><p>最佳接收机</p><img src="D:/Program%20Files/Typora/img/image-20230222144616376.png" alt="image-20230222144616376" style="zoom:80%;" /><p>由于||s<sub>1</sub>||=√E<sub>b</sub>,   所以收到的r<sub>1</sub>=√E<sub>b</sub>+n<sub>1</sub>,   所以r<sub>1</sub>~N(√E<sub>b</sub>,   N<sub>0</sub>/2),   那么它的似然函数就可以写出来了:   <img src="D:/Program%20Files/Typora/img/image-20230222144953716.png" alt="image-20230222144953716" style="zoom:80%;" /></p><blockquote><p>够成三维空间的要求,   互相之间积分为0,   自己之间积分为1;    </p><p>然后就是要记住典型信号的归一化标准正交基</p><img src="D:/Program%20Files/Typora/img/image-20230222105503848.png" alt="image-20230222105503848" style="zoom:80%;" /></blockquote><h2 id="6-10"><a href="#6-10" class="headerlink" title="6.10"></a>6.10</h2><img src="D:/Program%20Files/Typora/img/image-20230222145217539.png" alt="image-20230222145217539" style="zoom:80%;" /><p>(1)<br>$$<br>两个函数是正交的,   两个的能量都是\frac{T_b}{2}<br>$$<br>所以两个正交基就是</p><img src="D:/Program%20Files/Typora/img/image-20230222145622445.png" alt="image-20230222145622445" style="zoom: 67%;" /><p>星座图<img src="D:/Program%20Files/Typora/img/image-20230222145820502.png" alt="image-20230222145820502" style="zoom:80%;" />,   </p><img src="D:/Program%20Files/Typora/img/image-20230222150142135.png" alt="image-20230222150142135" style="zoom:80%;" /><p>(4)</p><img src="D:/Program%20Files/Typora/img/image-20230222150650369.png" alt="image-20230222150650369" style="zoom:80%;" /><p>(5)</p><img src="D:/Program%20Files/Typora/img/image-20230222150706865.png" alt="image-20230222150706865" style="zoom:80%;" /><blockquote><p>发s<sub>1</sub>但是接收到误码,   也就是说,   发s<sub>1</sub>,   但是它的信号与s<sub>2</sub>长得更像,   所以接收信号与s<sub>2</sub>的相关大于与s<sub>1</sub>的相关;   最后求n<sub>2</sub>-n<sub>1</sub>&gt;√E<sub>b</sub>,   因为这俩服从高斯分布,   所以他们相减的高斯分布可以算出来,   把他们相减的形式看成一个高斯变量,   相当于一个服从N(0,   N<sub>0</sub>)的高斯变量求Q函数的值,   所以就是后面那个结果;   </p><p>然后再用全概率公式进行加权;   </p></blockquote><h2 id="6-13"><a href="#6-13" class="headerlink" title="6.13"></a>6.13</h2><img src="D:/Program%20Files/Typora/img/image-20230222152048783.png" alt="image-20230222152048783" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222153612692.png" alt="image-20230222153612692" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222153637518.png" alt="image-20230222153637518" style="zoom:80%;" /><blockquote><p>首先进行施密特正交化,   化出标准正交基,   然后算出各个信号的坐标;   </p><p>因为是二维的,   所以匹配滤波器在抽样时刻的样值有两个,   因为发的是s<sub>1</sub>(t),   所以为(√2+n<sub>1</sub>,   n<sub>2</sub>);   </p><p>然后是第四问,   其实就是求(√2+n<sub>1</sub>,   n<sub>2</sub>)这两个的似然函数;   </p></blockquote><h2 id="6-14"><a href="#6-14" class="headerlink" title="6.14"></a>6.14</h2><img src="D:/Program%20Files/Typora/img/image-20230222160649435.png" alt="image-20230222160649435" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222161032494.png" alt="image-20230222161032494" style="zoom:80%;" /><blockquote><p>先通过Q函数算出E<sub>b</sub>,   E<sub>b</sub>R<sub>b</sub>就是功率,   而功率又等于那玩意儿,   就可以算出幅度了,   而算出的这是接收功率,   所以加上损耗就是传输功率;   </p></blockquote><h2 id="6-20"><a href="#6-20" class="headerlink" title="6.20"></a>6.20</h2><img src="D:/Program%20Files/Typora/img/image-20230222161422291.png" alt="image-20230222161422291" style="zoom:80%;" />$$\begin{align*}&P_b与信噪比之间存在对应关系P_b=Q(\sqrt{\frac{a^2}{x\sigma^2_n}}),   P_b算出来了,  信噪比就算出来了,\\\\<p>&amp;信噪比算出来了,幅度a就算出来了,   这是接收端的幅度,   拿发送端的幅度比上a\\</p><p>&amp;就得到在信道上的衰减,<br>\end{align*}<br>$$<br><img src="D:/Program%20Files/Typora/img/image-20230222164205193.png" alt="image-20230222164205193" style="zoom:80%;" /></p><blockquote><p>并且还要注意,   由于σ<sup>2</sup><sub>n</sub>=N<sub>0</sub>B<sub>BPF</sub>,   2FSK的σ<sup>2</sup><sub>n</sub>所对应的带通滤波器的带宽是一个峰的带宽,   所以它的带宽应该是2kHz,   而2ASK和2PSK的带宽都是4kHz;   </p><p>幅度的比值化成dB的时候要注意前面的系数不是10,   而是20;   </p></blockquote><h2 id="6-21"><a href="#6-21" class="headerlink" title="6.21"></a>6.21</h2><img src="D:/Program%20Files/Typora/img/image-20230222163525765.png" alt="image-20230222163525765" style="zoom:80%;" /><p>看到发送信号幅度A和信道衰减就可以猜测那是拿来与接收信号幅度进行比值的;   </p><p>通过A/a=60dB算出a,   然后通过R<sub>s</sub>算出带宽,   就可以算出噪声功率σ<sup>2</sup><sub>n</sub>,   全部带入误比特率公式中就可以算出误比特率;   </p><img src="D:/Program%20Files/Typora/img/image-20230222165323087.png" alt="image-20230222165323087" style="zoom:80%;" /><h2 id="6-22"><a href="#6-22" class="headerlink" title="6.22"></a>6.22</h2><img src="D:/Program%20Files/Typora/img/image-20230222165400234.png" alt="image-20230222165400234" style="zoom:80%;" /><p>这部分对应的公式就四个,   基带就是2/(1+α)和D,   频带就是1/(1+α)和D/2,   FSK比较特殊,   2/M;   </p><img src="D:/Program%20Files/Typora/img/image-20230222165645045.png" alt="image-20230222165645045" style="zoom:80%;" /><h2 id="6-24"><a href="#6-24" class="headerlink" title="6.24"></a>6.24</h2><img src="D:/Program%20Files/Typora/img/image-20230222182113503.png" alt="image-20230222182113503" style="zoom:80%;" /><p>(1)</p><p>d<sub>min</sub>就是两点之间的距离,   求得r,   </p><p>盲猜都猜得到E=r<sup>2</sup>,   算出E即可;   </p><p>(3)</p><p>注意格雷码的编写方式—在保证码距为1的前提下,   尾数按照0    1    1    0的方式循环编写,   首数按照00001111的方式循环编写;   </p><img src="D:/Program%20Files/Typora/img/image-20230222184538779.png" alt="image-20230222184538779" style="zoom:80%;" /><h2 id="6-29"><a href="#6-29" class="headerlink" title="6.29"></a>6.29</h2><p>设计一个数字通信系统,   如果信息速率为14400bit/s,   经过MQAM调制以2400Baud的符号速率在300~3300Hz的电话信道中进行传输<br>(1) 试确定进制数M,   载波频率f<sub>c</sub>,   滚降系数α<br>(2) 画出限带AWGN信道条件下的最佳频带传输系统框图<br>(3) 画出信道中所传QAM信号的功率谱密度示意图;   </p><p>(1) </p><img src="D:/Program%20Files/Typora/img/image-20230222190959705.png" alt="image-20230222190959705" style="zoom:80%;" /><blockquote><p>载波选在中间,   可用带宽直接减,   频带利用率直接拿那个公式算;   </p></blockquote><p>(2)</p><img src="D:/Program%20Files/Typora/img/image-20230222193038292.png" alt="image-20230222193038292" style="zoom:80%;" /><p>(3)</p><p>频谱图从哪里到哪里,   都是题干给定的,   而要算出滚降点频率,   可以先把频谱图搬移回基带,   然后通过α,   算出滚降点频率,   再移回频带的位置;   </p><h2 id="6-31"><a href="#6-31" class="headerlink" title="6.31"></a>6.31</h2><img src="D:/Program%20Files/Typora/img/image-20230222193425722.png" alt="image-20230222193425722" style="zoom:80%;" /><p>A律13折线就代表8bit,   抽样频率为8MHz,   可算得R<sub>b</sub>,   再通过频带利用率公式算出对应的量即可;   </p><p>QAM也是一样的;   </p><img src="D:/Program%20Files/Typora/img/image-20230222193859049.png" alt="image-20230222193859049" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222194402650.png" alt="image-20230222194402650" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222194433498.png" alt="image-20230222194433498" style="zoom:80%;" /><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>注意2ASK的空间维度为1,   QPSK的空间维度为2,   MFSK的空间维度为M,   MQAM的维度为2;   </p><p>求量化电平的时候不要忘记最后加上那一个区间的区间间隔一半!</p><p>注意误比特率一定是小于某个值,   所以E<sub>b</sub>/N<sub>0</sub>就大于某个值,   所以E<sub>b</sub>就大于某个值,   R<sub>b</sub>就小于某个值;   </p><p>二元PSK、DPSK及FSK三者的抗噪声性能从优到劣的排序为PSK优于DPSK优于FSK;   </p><p>可以采用非相干调制的有2ASK    2FSK;   </p><img src="D:/Program%20Files/Typora/img/image-20230222210538029.png" alt="image-20230222210538029" style="zoom:80%;" /><p>抗噪性能2PSK=4PSK &gt; 2ASK &gt; 4ASK=16QAM</p><img src="D:/Program%20Files/Typora/img/image-20230222210630298.png" alt="image-20230222210630298" style="zoom: 80%;" /><img src="D:/Program%20Files/Typora/img/image-20230222213706753.png" alt="image-20230222213706753" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230223091551821.png" alt="image-20230223091551821" style="zoom:80%;" />$$注意如果幅度是A的话,   上式应该变为AT_sSa(\pi fT_s)$$<p>+++</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ-ω-ρ&quot;&gt;&lt;a href=&quot;#≈-≡-≠</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/21/gong-wu-yuan-kao-shi/shen-lun-da-ti-qia/"/>
    <id>http://example.com/2023/02/21/gong-wu-yuan-kao-shi/shen-lun-da-ti-qia/</id>
    <published>2023-02-21T08:22:31.080Z</published>
    <updated>2023-02-21T08:48:15.303Z</updated>
    
    <content type="html"><![CDATA[<p>村干部走访农户,   宣传倡导文明、健康、科学的生活、消费方式;   </p><p>动员有威望、有影响力的党员干部组织成立红白理事会,   制订办事标准;   </p><p>设置集中办事场所,   村民提出申请即可免费使用设备;   </p><p>减少村民办事费用;   </p><p>招揽返乡人才承包”喜庆堂”,   通过接待客人,   减免房租来平衡支出;   </p><p>办事记录制成照片贴于墙上;   </p><p>适应互联网+新业态;   转变思想方法,   用数据说话;   </p><p>提高多肉标准化要求;   减小产品区域差异;   统一规格与品相;   </p><p>提高花卉产业基础;   </p><p>引进专业人士对农户进行指导,   对农户进行多肉种植培训,   提高其在水土,   病虫防治灾害等方面的技术;   提升农户投资基础知识,   科学扩建多肉产业;   </p><p>提高大型或中型农户所占比例;   实施多肉企业化生产;   拓展多肉品种;   </p><p>政府出台相关政策,   增加对多肉的宣传力度;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;村干部走访农户,   宣传倡导文明、健康、科学的生活、消费方式;   &lt;/p&gt;
&lt;p&gt;动员有威望、有影响力的党员干部组织成立红白理事会,   制订办事标准;   &lt;/p&gt;
&lt;p&gt;设置集中办事场所,   村民提出申请即可免费使用设备;   &lt;/p&gt;
&lt;p&gt;减少村民办事费用; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/20/tong-xin-yuan-li/xi-ti-01/"/>
    <id>http://example.com/2023/02/20/tong-xin-yuan-li/xi-ti-01/</id>
    <published>2023-02-20T14:43:11.311Z</published>
    <updated>2023-02-21T15:18:02.282Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ</h2><p>通信原理以后有空再搞吧,   现在先把考试搞完~</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h2><img src="D:/Program%20Files/Typora/img/image-20230220224828213.png" alt="image-20230220224828213" style="zoom:80%;" /><p>低通<img src="D:/Program%20Files/Typora/img/image-20230220224853726.png" alt="image-20230220224853726" style="zoom:80%;" /></p><p>带通<img src="D:/Program%20Files/Typora/img/image-20230220224905589.png" alt="image-20230220224905589" style="zoom:80%;" /><br>$$<br>其中k=\frac{f_H}{B},   并且向下取整<br>$$<br>这是一个带通型信号,   但是不妨碍使用低通抽样定理去抽样;   </p><img src="D:/Program%20Files/Typora/img/image-20230220225338676.png" alt="image-20230220225338676" style="zoom:80%;" /><p>抽样在频谱上就是进行周期延拓,   所以就延拓呗;   </p><img src="D:/Program%20Files/Typora/img/image-20230220225449944.png" alt="image-20230220225449944" style="zoom:80%;" /><p>带通抽样也是一样的;   </p><h2 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h2><p>已知某信号m(t)的频谱为M(f),   将他通过传输函数为H<sub>1</sub>(f)的滤波器后再进行理想抽样,   其中,   M(f)和H<sub>1</sub>(f)如图,<br>(1)计算抽样频率<br>(2)若抽样频率f<sub>s</sub>=4f<sub>1</sub>,   画出抽样信号的频谱<br>(3)如何在接收端回复出信号m(t);   </p><p>(1)因为为低通信号,   带宽为f<sub>1</sub>,   所以抽样频率大于等于2f<sub>1</sub>;   </p><p>(2)抽样信号的频谱就是对基带信号进行周期延拓即可;   </p><p>(3)通过一个截止频率为f<sub>1</sub>的理想低通滤波器,   将抽样信号的高频分量滤掉,   再通过一个1/H<sub>1</sub>(f)的网络即可恢复;   </p><h2 id="4-10"><a href="#4-10" class="headerlink" title="4.10"></a>4.10</h2><img src="D:/Program%20Files/Typora/img/image-20230221194525355.png" alt="image-20230221194525355" style="zoom:80%;" /><p>(1) </p><img src="D:/Program%20Files/Typora/img/image-20230221191912811.png" alt="image-20230221191912811" style="zoom: 33%;" /><p>Δ=4096/2048=2mV,   I<sub>D</sub>=796/2 * Δ=398Δ;   </p><p>值大于0,   所以C<sub>1</sub>=1,   398Δ在段落6,   所以C<sub>2</sub>C<sub>3</sub>C<sub>4</sub>=101,   </p><p>C<sub>5</sub>C<sub>6</sub>C<sub>7</sub>C<sub>8</sub>=(398-256)/16=8=(1000)<sub>2</sub>;   </p><p>(2)量化电平I<sub>D</sub>=256+8 * 16 + 8=392Δ;   </p><p>量化误差e=398Δ-392Δ=6Δ=12mV;   </p><p>(3)把前面算出来的量化电平化为11位二进制码;   </p><h2 id="4-13"><a href="#4-13" class="headerlink" title="4.13"></a>4.13</h2><img src="D:/Program%20Files/Typora/img/image-20230220230211930.png" alt="image-20230220230211930" style="zoom:80%;" /><p>(1) 量化信噪比只与量化阶数有关</p><img src="D:/Program%20Files/Typora/img/image-20230220230402608.png" alt="image-20230220230402608" style="zoom:80%;" /><p>电平为-5~+5V,   量化间隔Δ=0.01V,   所以量化级数为10/0.01=1000;   所以量化信噪比为</p><img src="D:/Program%20Files/Typora/img/image-20230220231013082.png" alt="image-20230220231013082" style="zoom:80%;" /><p>(2) 首先应该画出那个表</p><img src="D:/Program%20Files/Typora/img/image-20230221191912811.png" alt="image-20230221191912811" style="zoom: 33%;" /><p>发现101位于段落6,   所以这一段的每个码都占16Δ,   并且这是双极性码,   所以应该<br>$$<br>\frac{16}{2*2048}=\frac{2^4}{2^{12}}=\frac1{2^8}=\frac1{256}<br>$$<br>量化电平256+14 * 16+8=488Δ;   </p><p>归一化值Δ=5/2048或者10/4096=0.00244V;   </p><p>故量化电平为</p><center>I<sub>D</sub>=1.19V</center><p>(3) Δ也算出来了,   拿电压除以Δ就得到了归一化Δ,   然后算他的编码,   通过阶数算出量化电平和量化误差;   </p><h2 id="4-18"><a href="#4-18" class="headerlink" title="4.18"></a>4.18</h2><img src="D:/Program%20Files/Typora/img/image-20230221201740333.png" alt="image-20230221201740333" style="zoom:80%;" /><p>(1) 低通采样定理,   14kHz;   </p><p>(2) 量化级数为8,   比特数/位数为log<sub>2</sub>8=3;   又因<br>$$<br>R_b=nf_sl<br>$$<br>所以R<sub>b</sub>=480kbit/s;   </p><blockquote><p>这里要注意,   量化级数和量化位数的关系! </p></blockquote><h2 id="4-19"><a href="#4-19" class="headerlink" title="4.19"></a>4.19</h2><img src="D:/Program%20Files/Typora/img/image-20230221202227290.png" alt="image-20230221202227290" style="zoom:80%;" /><p>(1)每路信号采用A律13折线进行编码,   意思就是使用8bit(8位)进行编码;   一个抽样周期就是一帧;   因为要复用10路,   并且有一个同步码,   所以每一帧要有11路时隙;   </p><img src="D:/Program%20Files/Typora/img/image-20230221202746838.png" alt="image-20230221202746838" style="zoom:80%;" /><p>因为帧长由抽样周期决定,   所以T<sub>s</sub>=1/f<sub>s</sub>=125us;   </p><p>路时隙T<sub>a</sub>=125us/11路;   位时隙T<sub>b</sub>=T<sub>a</sub>/8;   </p><p>(2) 11路,   每路8bit,   R<sub>b</sub>=88bit * 8000Hz=704000bit/s;   </p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h2><img src="D:/Program%20Files/Typora/img/image-20230221203452199.png" alt="image-20230221203452199" style="zoom: 80%;" /><h2 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h2><img src="D:/Program%20Files/Typora/img/image-20230221205755215.png" alt="image-20230221205755215" style="zoom:80%;" /><p>(1) 由于独立等概,   所以均值为0,   方差也可以算出来,   </p><img src="D:/Program%20Files/Typora/img/image-20230221210106241.png" alt="image-20230221210106241" style="zoom:80%;" /><blockquote><p>这里需要谨记|G<sub>T</sub>(f)|的式子;   </p><p>也需要记一记P<sub>s</sub>(f)</p></blockquote><p>由于T<sub>s</sub>没给,   所以就不代;   </p><img src="D:/Program%20Files/Typora/img/image-20230221210534162.png" alt="image-20230221210534162" style="zoom:80%;" /><p>(2) 一样的,   均值为0,   算出方差,   带入式子;   </p><p>(3) 因为第一过零点带宽等于符号周期的倒数等于符号速率<img src="D:/Program%20Files/Typora/img/image-20230221212049636.png" alt="image-20230221212049636" style="zoom:80%;" /></p><p>所以两个PAM信号的B都为10<sup>6</sup>Hz;   </p><p>(4) 由于R<sub>s</sub>=R<sub>b</sub>/log<sub>2</sub>M,   所以2PAM的带宽为6 * 10<sup>6</sup>Hz,   8PAM的带宽为2 * 10<sup>6</sup>Hz;   </p><blockquote><p>R<sub>s</sub>和R<sub>b</sub>这件的关系公式如果记不住的话,   可以想想T<sub>s</sub>和T<sub>b</sub>的关系,   传一个符号的时间肯定大于等于传一个比特的时间撒,   所以T<sub>s</sub>=T<sub>b</sub> * log<sub>2</sub>M;   信息速率R的公式就反过来就行了;   </p></blockquote><h2 id="5-9"><a href="#5-9" class="headerlink" title="5.9"></a>5.9</h2><img src="D:/Program%20Files/Typora/img/image-20230221213059005.png" alt="image-20230221213059005" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230221213110771.png" alt="image-20230221213110771" style="zoom:80%;" /><p><img src="D:/Program%20Files/Typora/img/image-20230221213041727.png" alt="image-20230221213041727"></p><p>(1) </p><img src="D:/Program%20Files/Typora/img/image-20230221213518583.png" alt="image-20230221213518583" style="zoom:80%;" /><p>(2) 对于匹配滤波器而言,   抽样时刻,   最大信号幅度</p><center>s<sub>0</sub>(t<sub>0</sub>)=kR(0)=kE</center><img src="D:/Program%20Files/Typora/img/image-20230221215436117.png" alt="image-20230221215436117" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230221215722242.png" alt="image-20230221215722242" style="zoom:80%;" /><blockquote><p>也就是说,   要先记住最大信号幅度的公式,   然后记住噪声的平均功率;   </p><p>先根据信号的波形计算信号的能量,   抽样时刻幅度值kE,   瞬时功率(幅度值平方),   然后计算噪声的平均功率,   最后计算输出信噪比;   </p></blockquote><p>然后就是问他服从什么分布,   高斯分布咯,   计算它的一维概率密度函数,   实际上就是求均值和方差,   带进去就可以了;   </p><p>(4) 先验等概,   求误比特率;   </p><img src="D:/Program%20Files/Typora/img/image-20230221220814782.png" alt="image-20230221220814782" style="zoom:80%;" /><blockquote><p>要熟记P<sub>b</sub> ! !</p></blockquote><h2 id="5-10"><a href="#5-10" class="headerlink" title="5.10"></a>5.10</h2><img src="D:/Program%20Files/Typora/img/image-20230221221109928.png" alt="image-20230221221109928" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230221221347330.png" alt="image-20230221221347330" style="zoom:80%;" /><p>平均比特能量,   查表,   Q函数为减函数,   算出即可;   </p><p>平均功率为E<sub>b</sub>/T<sub>b</sub>,   所以就是那个公式咯;   </p><h2 id="5-15"><a href="#5-15" class="headerlink" title="5.15"></a>5.15</h2><img src="D:/Program%20Files/Typora/img/image-20230221221816038.png" alt="image-20230221221816038" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230221222259297.png" alt="image-20230221222259297" style="zoom:80%;" /><blockquote><p>根据图获得滚降中心点频率B<sub>N</sub>,   而无码间干扰的最大速率为B<sub>N</sub>的两倍,   但这只是最大的,   还有不那么大的,   B<sub>N</sub>/k,   k为任意正整数都可以,   所以取1的时候有3000Baud,   取2的时候有1500Baud,   但是没有这个选项,   取3的时候1000Baud;   </p></blockquote><h2 id="5-18"><a href="#5-18" class="headerlink" title="5.18"></a>5.18</h2><img src="D:/Program%20Files/Typora/img/image-20230221223545626.png" alt="image-20230221223545626" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230221224405459.png" alt="image-20230221224405459" style="zoom:80%;" /><blockquote><p>一定谨记那个公式频带利用率的那个公式 ! ! !</p><p>然后就是传输速率R<sub>s</sub>=nlf<sub>s</sub>,   A律13折线,   所以这里的l指的是量化位数,   8;   </p></blockquote><h2 id="5-21"><a href="#5-21" class="headerlink" title="5.21"></a>5.21</h2><img src="D:/Program%20Files/Typora/img/image-20230221230224297.png" alt="image-20230221230224297" style="zoom:80%;" /><p>与上一题一样;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/19/tong-xin-yuan-li/tong-xin-yuan-li-di-6-zhang-01/"/>
    <id>http://example.com/2023/02/19/tong-xin-yuan-li/tong-xin-yuan-li-di-6-zhang-01/</id>
    <published>2023-02-19T01:31:16.350Z</published>
    <updated>2023-02-22T12:12:47.841Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ</h2><h1 id="通信原理第6章-01"><a href="#通信原理第6章-01" class="headerlink" title="通信原理第6章_01"></a>通信原理第6章_01</h1><h2 id="数字频带传输模型"><a href="#数字频带传输模型" class="headerlink" title="数字频带传输模型"></a>数字频带传输模型</h2><p>由于携带信息的信号的频率与在信道上传递信号的合适频率不相同,   甚至差别很大,   所以需要传输之前把要传输的信号调到一定的频率,   这在第三章对模拟信号就是这么干的,   而数字信号也一样;   </p><p>这一章的对象是数字基带信号去控制正弦型载波的某一个或者某几个参数,   得到的数字频带信号;   </p><p>用数字基带信号去控制载波的幅度,   得到的频带信号被称为幅移键控ASK<br>用数字基带信号去控制载波的频率,   得到的频带信号被称为频移键控FSK<br>用数字基带信号去控制载波的相位,   得到的频带信号被称为相移键控PSK<br>用数字基带信号去联合控制载波的幅度与相位,   得到的频带信号称幅度相位联合键控,   如PAM;   </p><p>对于数字频带调制的理解:   可以像第三章那样,   把数字信号的基带信号频域形式表示出来,   然后再进行频谱搬移;   也可以像第五章那样,   把0和1映射为不同的波形进行调制;   </p><p>M进制:   将k个二进制符号构造为一个M进制符号,   每一个M进制符号映射为M个波形的其中之一;   举例,   比如4个比特映射为一个十六进制数,   而十六进制数嘛,   就有十六种不同的情况,   那么这十六种不同的情况就对应着十六种不同的波形,   在传递的时候,   只需要发送那4个比特对应的十六进制数对应的波形即可;   而如果传递的符号为M进制的,   M通常为2的次幂,   所以M=2<sup>k</sup>,   而对应的</p><center>T<sub>s</sub>=kT<sub>b</sub></center><p>T<sub>b</sub>为传递一个比特需要的时间,   T<sub>s</sub>为传递一个符号所需要的时间,   一个M进制符号对应着k个比特,   所以为k倍的关系;   </p><p>接收机的作用就是接收0≤t≤T<sub>s</sub>间的信号,   判断这个信号到底是M个波形中的哪一个;   </p><h2 id="二进制数字信号正弦载波调制"><a href="#二进制数字信号正弦载波调制" class="headerlink" title="二进制数字信号正弦载波调制"></a>二进制数字信号正弦载波调制</h2><h3 id="调制信号的时域表示"><a href="#调制信号的时域表示" class="headerlink" title="调制信号的时域表示"></a>调制信号的时域表示</h3><ol><li><p>2ASK<br>$$<br>s_{2ASK}(t)=b(t)c(t)=[\sum^\infty_{n=-\infty}a_ng_T(t-nT_b)] * A_ccos2\pi f_ct<br>$$</p><p>其中a<sub>n</sub>为0或者1;   </p><p>调制之后的波形<br>$$<br>S_{2ASK}(t)=\left{ \begin{array}{rcl}<br>&amp;s_1(t)=A_cg_T(t)cos2\pi f_ct&amp;,   &amp;1\<br>&amp;0&amp;,   &amp;0\<br>\end{array}\right.<br>$$</p><img src="D:/Program%20Files/Typora/img/image-20230220203920737.png" alt="image-20230220203920737" style="zoom:80%;" /><p>2ASK使用载波的幅度来存储信号的信息;   </p><p>信号产生:   使用开关电路,   发1的时候就打开电路,   发0的时候就断开电路;   </p><img src="D:/Program%20Files/Typora/img/image-20230220205346718.png" alt="image-20230220205346718" style="zoom:80%;" /></li><li><p>2PSK</p><img src="D:/Program%20Files/Typora/img/image-20230220204142238.png" alt="image-20230220204142238" style="zoom:80%;" /><p>2PSK使用载波的0和π相位来存储信号的信息;   </p><p>2PSK的产生:   发1的时候照常,   发0的时候反转相位即可;   </p></li><li><p>2FSK</p><img src="D:/Program%20Files/Typora/img/image-20230220204654243.png" alt="image-20230220204654243" style="zoom:80%;" /><p>2FSK使用不同频率的载波来存储信号的信息;   </p><p>2FSK可以看作两列2ASK的叠加,   也就是两列2ASK分别取不同频率的载波,   一列存储0信号(求反之后乘载波),   一列存储1信号,   再把两列相加即可;   </p><p>2FSK的产生:   发1的时候接一种载波,   发0的时候接另一种载波;   或者直接使用VCO进行频偏;   </p></li></ol><h3 id="二进制数字调制信号的功率谱及带宽"><a href="#二进制数字调制信号的功率谱及带宽" class="headerlink" title="二进制数字调制信号的功率谱及带宽"></a>二进制数字调制信号的功率谱及带宽</h3><p>(1) 2ASK<br>        由于乘了一个正弦波,   所以在频谱上把基带信号向两边搬移,   并且分为了两部分,   所以2ASK的功率谱为<br>$$<br>P_{2ASK}(f)=\frac{A^2_c}{4}[P_b(f+f_c)+P_b(f-f_c)]<br>$$<br>P<sub>b</sub>(f)为基带信号的功率谱,   2ASK带宽为基带信号带宽的两倍;   </p><p>如果基带信号为单极性不归零信号,   码元间隔T<sub>b</sub>;   </p><img src="D:/Program%20Files/Typora/img/image-20230220211935258.png" alt="image-20230220211935258" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230220212020667.png" alt="image-20230220212020667" style="zoom:80%;" /><blockquote><p>因为带宽只算一半,   所以2ASK的带宽为基带信号的第一过零点带宽的两倍;   </p></blockquote><p>如果基带信号为滚降型信号,   则</p><img src="D:/Program%20Files/Typora/img/image-20230220212309874.png" alt="image-20230220212309874" style="zoom:80%;" /><p>(2) 2PSK<br>        与2ASK相似,   不过由于2PSK发的是-1和1,   是等概的,   所以在载波处没有冲击;   </p><img src="D:/Program%20Files/Typora/img/image-20230220212756901.png" alt="image-20230220212756901" style="zoom:80%;" /><p>(3) 2FSK<br>        由于2FSK可以看作是两列2ASK的和,   所以2FSK的频谱也可以看作是两列2ASK的叠加</p><img src="D:/Program%20Files/Typora/img/image-20230220213144090.png" alt="image-20230220213144090" style="zoom:80%;" /><h3 id="多进制数字调制信号的功率谱及带宽"><a href="#多进制数字调制信号的功率谱及带宽" class="headerlink" title="多进制数字调制信号的功率谱及带宽"></a>多进制数字调制信号的功率谱及带宽</h3><p>(1) MASK信号<br>        <img src="D:/Program%20Files/Typora/img/image-20230220214519859.png" alt="image-20230220214519859" style="zoom:80%;" /><br>        <img src="D:/Program%20Files/Typora/img/image-20230220214543891.png" alt="image-20230220214543891" style="zoom:80%;" /><br>        MASK的带宽为其基带信号的两倍,   但是这个基带信号为多进制信号;<br>$$<br>\begin{align*}<br>&amp;2ASK&amp;T_s=T_b&amp;&amp;B_{基}=\frac1{T_s}&amp;&amp;B_{2ASK}=2B_{基}=\frac2{T_s}=\frac2{T_b}\\<br>&amp;4ASK&amp;T_s=2T_b&amp;&amp;B_{基}=\frac1{T_s}&amp;&amp;B_{4ASK}=2B_{基}=\frac2{T_s}=\frac1{T_b}<br>\end{align*}<br>$$<br><img src="D:/Program%20Files/Typora/img/image-20230220215647861.png" alt="image-20230220215647861" style="zoom:80%;" /></p><p>(2) QPSK<br>        使用构成4个直角的相位可以从0相位开始,   也可以从45度相位开始;<br>        由于MPSK可以看作两列正交的多电平MASK叠加,   所以在相同的基带信号下,   其带宽和频带利用率与MASK的都是相同的;   </p><p>相关的习题只需要记住两个公式<br>$$<br>\begin{align*}<br>&amp;基带<br>\frac{R_s}B=\left{ \begin{array}{rcl}<br>&amp;D,   &amp;矩形波\<br>&amp;\frac2{1+\alpha},   &amp;滚降\<br>\end{array}\right.<br>\\<br>&amp;频带<br>\frac{R_s}B=\left{ \begin{array}{rcl}<br>&amp;\frac D2,   &amp;矩形波\<br>&amp;\frac1{1+\alpha},   &amp;滚降\<br>\end{array}\right.<br>\\<br>&amp;\frac{R_b}B=\frac{R_s}Blog_2M<br>\end{align*}<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/18/sui-bi/wu-bian-de-ling-gan-01/"/>
    <id>http://example.com/2023/02/18/sui-bi/wu-bian-de-ling-gan-01/</id>
    <published>2023-02-18T13:05:39.470Z</published>
    <updated>2023-02-18T13:36:58.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动力之反向思考"><a href="#动力之反向思考" class="headerlink" title="动力之反向思考"></a>动力之反向思考</h1><p>一直以来我都在思考如何减小诱惑,   如何提高接触诱惑的门槛,   以让自己能够持续努力,   但是今天突然想到,   如果对努力的门槛进行修改,   也可以影响坚持;   </p><p>比如突然想到,   如果将学习用品放置在很远的地方,   实际上相当于提高了学习的门槛,   比如人在楼上,   但是要下楼去才能学习;   而降低学习的门槛,   越想越合理,   联系宁老师的进步本和随时学习;   </p><p>不过我也有专门的降低学习门槛的方法,   2023/02/18目前为止还是挺有用的,   把”第一个最简单的任务设为翻开书本”与奖励相结合,   也就是完成这个根本无需任何成本的任务就可以领取奖励,   随后的奖励随任务难度的增加而增加;   </p><p>“无消耗的简单任务与奖励挂钩”这一点虽小,   但是很重要;   </p><p>这种方式来源于赛尔号,   登陆游戏就可以领取每日任务的奖励,   从而促使玩家完成每日任务,   而每日任务的完成度与游戏时长挂钩;   赛尔号的策划们属实是把人性的弱点拿捏了,   不过能为我所用,   就是好事;   </p><h1 id="奇怪的南山"><a href="#奇怪的南山" class="headerlink" title="奇怪的南山"></a>奇怪的南山</h1><p>大四下回到邮电大学之后,   本人的嗓音条件变好了,   而且没有太多可追溯的原因;   </p><p>一开始我也没有太注意,   直到想到大四上一到南山上,   嗓音条件也莫名其妙地变好了,   当时归功于暑假的咽音练习,   不过之后条件又变差了;   </p><p>不知道是与海拔相关还是与海拔的变化相关,   还是说南山上空气比较好? 不过大四上结束之后回到家里,   突然咽音就轻松上C5了,   然后又差了回去,   当时归因于新冠;   </p><p>总不能是吃了几块牛肉干的原因吧🤣</p><p>真是奇怪~ 不过嗓音条件变好就是好事,   起码我很高兴;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动力之反向思考&quot;&gt;&lt;a href=&quot;#动力之反向思考&quot; class=&quot;headerlink&quot; title=&quot;动力之反向思考&quot;&gt;&lt;/a&gt;动力之反向思考&lt;/h1&gt;&lt;p&gt;一直以来我都在思考如何减小诱惑,   如何提高接触诱惑的门槛,   以让自己能够持续努力,   但是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/18/bi-ye-lun-wen/deng-yu-tong-di-si-zhou-zhou-bao/"/>
    <id>http://example.com/2023/02/18/bi-ye-lun-wen/deng-yu-tong-di-si-zhou-zhou-bao/</id>
    <published>2023-02-18T02:09:59.269Z</published>
    <updated>2023-02-18T06:11:03.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四次周报"><a href="#第四次周报" class="headerlink" title="第四次周报"></a>第四次周报</h1><ol><li><p>学习AdaBoost分类方法</p><p>多个弱分类器通过加权的方式形成一个强分类器;   试着用数学方式表示AdaBoost,   类似这种</p><img src="D:/Program%20Files/Typora/img/image-20230218135223562.png" alt="image-20230218135223562" style="zoom: 80%;" /></li><li><p>学习PCA算法</p><p>一个降维的方法,   用于特征脸算法,   线性代数味道较重;   同时理解了降维的概念,   PCA应是一种线性降维的算法;   </p></li><li><p>学习特征脸算法</p><p>核心就是PCA,   这个无需多谈;   </p></li><li><p>分析OpenCV中对EigenFace算法的实现</p><img src="D:/Program%20Files/Typora/img/image-20230218135514382.png" alt="image-20230218135514382" style="zoom:80%;" /><p>虽然我不会c++,   但是源码分析并不是太吃语言特性,   而且还有api嘛;   </p><p>除开一大段判别代码后,   EigenFace的训练方法的核心代码还是在于PCA,   不过在投影到PCA子空间的时候利用的是LDA;   </p><p>所以要搞懂EigenFace,   还需要看看PCA和LDA的实现;   </p><img src="D:/Program%20Files/Typora/img/image-20230218140229274.png" alt="image-20230218140229274" style="zoom:80%;" /><p>在预测函数中,   使用余弦距离公式算出距离之后,   其判断是在收集器中进行的,   所以还需要研究一下收集器的实现,   其实都可以猜到了eigen_face.cpp的构造函数(不知道是不是这么叫)中的阈值threshold是在收集器中使用的;   </p></li><li><p>准备公考中,   还是没太多时间做毕设🤷‍♂️;   </p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四次周报&quot;&gt;&lt;a href=&quot;#第四次周报&quot; class=&quot;headerlink&quot; title=&quot;第四次周报&quot;&gt;&lt;/a&gt;第四次周报&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;学习AdaBoost分类方法&lt;/p&gt;
&lt;p&gt;多个弱分类器通过加权的方式形成一个强分类器;   试着</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/17/bi-ye-lun-wen/f012-adaboost-deng/"/>
    <id>http://example.com/2023/02/17/bi-ye-lun-wen/f012-adaboost-deng/</id>
    <published>2023-02-17T13:42:11.227Z</published>
    <updated>2023-02-28T13:16:58.415Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ</h2><h1 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h1><p>算法思想:   为每一个样本数据分配初始值,   在每一步迭代过程中,   通过新加入的基本分类器的分类错误率来逐步调整权值,   当达到预先指定的迭代次数或者预测错误概率足够小的时候,   便可以将迭代过程中的基本分类器进行组合,   得到一个强分类器;<br>$$<br>\begin{align*}<br>&amp;算法输入:   \\<br>&amp;训练集(x_1,   y_2),   …(x_N,   y_N),   x_i为训练样本,   y_i为训练标签,   取值为{1,   -1},    \\<br>&amp;i=1,   2,   …,   N,  \\<br>&amp;弱分类器h_m,   m=1,   2,   …,   M\\</p><p>&amp;算法输出:   强分类器H\\\<br>&amp;算法流程:   \\<br>&amp;(1)初始化N个训练样本的权值分布;   \<br>&amp;P_0={p_{0_1},   p_{0_2},   …,   p_{0_N}}={\frac1N,   \frac1N,   …,   \frac1N}\\</p><p>&amp;(2) 进行K次迭代,   选取按照当前权值,   分类错误率最低的弱分类器h作为第k个基本分类器H_k,   \<br>&amp;并计算H_k的分类错误率e_k:   \<br>&amp;e_k=\sum^N_{i=1}p_{k-1}I(H_k(x_i)≠y_i),   \\<br>&amp;I(H_k(x_i)≠y_i)=\left{ \begin{array}{rcl}<br>&amp;1&amp;,   &amp;H_k(x_i)≠y_i\<br>&amp;0&amp;,   &amp;H_k(x_i)=y_i\<br>\end{array}\right.,   \\</p><p>&amp;利用e_k计算当前弱分类器H_k在最终强分类器中的权重\beta_k\<br>&amp;\beta_k=\frac12ln(\frac{1-e_k}{e_k})\\<br>&amp;更新训练样本的权值分布P_k(式子太大不给了)\\\</p><p>&amp;(3)按照各个 弱分类器的权重组合弱分类器,   得到强分类器\<br>&amp;H=sign(\sum^K_{i=1}\beta_iH_i)<br>\end{align*}<br>$$</p><blockquote><p>那个含不等于的式子的意思是,   如果把x<sub>i</sub>传入分类器得到的结果不为y<sub>i</sub>,   即分类错误,   则整体式子为1,   如果分类正确则输出0;   </p><p>e<sub>k</sub>那个式子就代表如果分类错误,   则统计,   没错则不统计,   实际上就是在统计分类错误率;   </p><p>对于最后的那个式子,   符号函数对于&gt;0的自变量取1,   &lt;0的自变量取-1;   也就是说,   把一个数据传进每一个弱分类器中,   判断结果乘以对应的权重,   各个结果之和若大于0,   则分到一类,   若小于零,   则分到另一类;   </p></blockquote><h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h1><p>降维的概念:   描述一个三维空间,   需要使用三个量,   用着三个量描述某个物体在空间中的位置,   而对于高维空间,   虽然三微生物无法想象,   但是可以同样使用不断增加维度的方式对其进行描述;   </p><p>在机器学习与数据挖掘等领域中,   数据模型算法的复杂度常常与数据维度挂钩;   而在图像处理方面的数据维度,   我认为可以简单理解为”特征”,   比如人脸图像,   要想描述一张人脸,   可能需要对人脸的五官进行描述,   比如眼睛的长度,   鼻孔的大小,   嘴唇的宽度等等;   每个特征可以用一个数值来代替,   这些数值组合在一起构成一个特征向量,   来描述某张人脸;   当想要检测这张人脸是否为彭于晏时,   只需比对这些特征即可;   </p><p>想要对图像描述的更精细,   就需要更多的特征,   而由于算法复杂度与数据维度挂钩,   所以应该采用某种方法将大量的特征映射为少量的特征,   也就是降维,   在数学上为从”多分量向量”映射为”少分量向量”的过程;   </p><p>在降维过程中,   使用者需要的特征信息被保留,   而丢弃掉那些对使用者目的无关的信息;   </p><blockquote><p>而PCA的步骤:   </p><p>对每一个数据集的每一维数据进行相对于均值的归一化,   得到归一化矩阵,   然后求其协方差矩阵<strong>C</strong>,   获得<strong>C</strong>的特征值与特征向量,   选取最大的k个特征值对应的特征向量,   组成特征向量矩阵<strong>P</strong>,   <strong>P</strong>就是降维之后的矩阵;   </p></blockquote><h1 id="特征脸法"><a href="#特征脸法" class="headerlink" title="特征脸法"></a>特征脸法</h1><p>步骤</p><p>训练:   </p><ol><li><p>对图片进行预处理</p><p>灰度化,   统一尺寸,   光照归一化;   </p></li><li><p>将图片转化为一个向量</p><p>将图片矩阵的每一行连在一起,   并转化为列向量;   </p></li><li><p>零均值化</p><p>对每一个维度求平均,   平均值组合到一起形成平均脸向量,   每个人脸向量减去该平均脸向量,   从而完成零均值化处理;   </p></li><li><p>PCA</p><p>算出归一化矩阵的协方差矩阵的特征值与特征向量,   特征向量的维度和原始图像的维度一致,   故这些特征向量就是特征脸;   </p><blockquote><p>设经过零均值化的矩阵为<strong>X</strong>,   <strong>X</strong>为m行n列,   m为每一张图片的维度数,   n为训练的图片数,   由于图片数远远小于维度数,   所以可以把原本为m行m列的协方差矩阵<strong>C</strong></p><center>C = X X<sup>T</sup></center><p>变为<strong>C’</strong></p><center>C'= X<sup>T</sup>X</center><p>这样,   协方差矩阵的规模就变为了n行n列,   从而减少运算量;   </p></blockquote><p>对于所获得的特征脸向量,   每一张图片都可以是这些特征脸向量的线性组合,   从而每一张图片都可以用一个向量**θ<sup>T</sup>**表示</p><center>θ<sup>T</sup> = [θ<sub>1</sub>,   θ<sub>2</sub>,...,   θ<sub>n</sub>]</center></li><li><p>对比</p><p>通过特征脸向量将输入图片向量化,   得到一个特征向量,   将该特征向量与已有的特征向量通过距离度量的方法进行对比,   从而判断是否为同一个人;   </p></li></ol><p>EigenFace代码实现(opencv_contrib-3.4\modules\face\src\eigen_faces.cpp)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;precomp.hpp&quot;</span> <span class="comment">// 包含预编译头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/face.hpp&gt;</span> <span class="comment">// 包含OpenCV的人脸识别头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;face_utils.hpp&quot;</span> <span class="comment">// 包含人脸识别的工具函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span> <span class="comment">// 包含set容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span> <span class="comment">// 包含数值限制头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> <span class="comment">// 包含输入输出流头文件</span></span></span><br><span class="line"><span class="keyword">namespace</span> cv <span class="comment">// 定义命名空间cv</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> face <span class="comment">// 定义命名空间face</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Turk, M., and Pentland, A. &quot;Eigenfaces for recognition.&quot;. Journal of</span></span><br><span class="line"><span class="comment">// Cognitive Neuroscience 3 (1991), 71–86.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eigenfaces</span> :</span> <span class="keyword">public</span> EigenFaceRecognizer <span class="comment">// 定义Eigenfaces类，继承自EigenFaceRecognizer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initializes an empty Eigenfaces model.</span></span><br><span class="line">    <span class="built_in">Eigenfaces</span>(<span class="keyword">int</span> num_components = <span class="number">0</span>, <span class="keyword">double</span> threshold = DBL_MAX) <span class="comment">// 构造函数，初始化空的Eigenfaces模型，参数num_components表示特征数量，threshold表示阈值</span></span><br><span class="line">        <span class="comment">//: BasicFaceRecognizerImpl(num_components, threshold)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _num_components = num_components; <span class="comment">// 将参数num_components赋值给_num_components</span></span><br><span class="line">        _threshold = threshold; <span class="comment">// 将参数threshold赋值给_threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Computes an Eigenfaces model with images in src and corresponding labels</span></span><br><span class="line">    <span class="comment">// in labels.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">train</span><span class="params">(InputArrayOfArrays src, InputArray labels)</span> CV_OVERRIDE</span>; <span class="comment">// 训练函数，参数src表示输入图像，labels表示标签</span></span><br><span class="line">    <span class="comment">// Send all predict results to caller side for custom result handling</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">predict</span><span class="params">(InputArray src, Ptr&lt;PredictCollector&gt; collector)</span> <span class="keyword">const</span> CV_OVERRIDE</span>; <span class="comment">// 预测函数，参数src表示输入图像，collector表示收集器</span></span><br><span class="line">    <span class="function">String <span class="title">getDefaultName</span><span class="params">()</span> <span class="keyword">const</span> CV_OVERRIDE <span class="comment">// 获取默认名称</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;opencv_eigenfaces&quot;</span>; <span class="comment">// 返回opencv_eigenfaces</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Eigenfaces</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eigenfaces::train</span><span class="params">(InputArrayOfArrays _src, InputArray _local_labels)</span> </span>&#123; <span class="comment">// 训练函数</span></span><br><span class="line">    <span class="keyword">if</span>(_src.<span class="built_in">total</span>() == <span class="number">0</span>) &#123; <span class="comment">// 如果输入图像为空</span></span><br><span class="line">        String error_message = format(<span class="string">&quot;Empty training data was given. You&#x27;ll need more than one sample to learn a model.&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="built_in">CV_Error</span>(Error::StsBadArg, error_message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(_local_labels.<span class="built_in">getMat</span>().<span class="built_in">type</span>() != CV_32SC1) &#123; <span class="comment">// 如果标签类型不是CV_32SC1</span></span><br><span class="line">        String error_message = format(<span class="string">&quot;Labels must be given as integer (CV_32SC1). Expected %!d(MISSING), but was %!d(MISSING).&quot;</span>, CV_32SC1, _local_labels.<span class="built_in">type</span>()); <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="built_in">CV_Error</span>(Error::StsBadArg, error_message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// make sure data has correct size</span></span><br><span class="line">    <span class="keyword">if</span>(_src.<span class="built_in">total</span>() &gt; <span class="number">1</span>) &#123; <span class="comment">// 如果输入图像数量大于1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(_src.<span class="built_in">total</span>()); i++) &#123; <span class="comment">// 遍历每一张图像</span></span><br><span class="line">            <span class="keyword">if</span>(_src.<span class="built_in">getMat</span>(i<span class="number">-1</span>).<span class="built_in">total</span>() != _src.<span class="built_in">getMat</span>(i).<span class="built_in">total</span>()) &#123; <span class="comment">// 如果图像大小不一致</span></span><br><span class="line">                String error_message = format(<span class="string">&quot;In the Eigenfaces method all input samples (training images) must be of equal size! Expected %!d(MISSING) pixels, but was %!d(MISSING) pixels.&quot;</span>, _src.<span class="built_in">getMat</span>(i<span class="number">-1</span>).<span class="built_in">total</span>(), _src.<span class="built_in">getMat</span>(i).<span class="built_in">total</span>()); <span class="comment">// 抛出异常</span></span><br><span class="line">                <span class="built_in">CV_Error</span>(Error::StsUnsupportedFormat, error_message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get labels</span></span><br><span class="line">    Mat labels = _local_labels.<span class="built_in">getMat</span>(); <span class="comment">// 获取标签</span></span><br><span class="line">    <span class="comment">// observations in row</span></span><br><span class="line">    Mat data = <span class="built_in">asRowMatrix</span>(_src, CV_64FC1); <span class="comment">// 将输入图像转换为行矩阵</span></span><br><span class="line">    <span class="comment">// number of samples</span></span><br><span class="line">   <span class="keyword">int</span> n = data.rows; <span class="comment">// 获取样本数量</span></span><br><span class="line">    <span class="comment">// assert there are as much samples as labels</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(labels.<span class="built_in">total</span>()) != n) &#123; <span class="comment">// 如果样本数量和标签数量不一致</span></span><br><span class="line">        String error_message = format(<span class="string">&quot;The number of samples (src) must equal the number of labels (labels)! len(src)=%!d(MISSING), len(labels)=%!d(MISSING).&quot;</span>, n, labels.<span class="built_in">total</span>()); <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="built_in">CV_Error</span>(Error::StsBadArg, error_message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear existing model data</span></span><br><span class="line">    _labels.<span class="built_in">release</span>(); <span class="comment">// 释放_labels</span></span><br><span class="line">    _projections.<span class="built_in">clear</span>(); <span class="comment">// 清空_projections</span></span><br><span class="line">    <span class="comment">// clip number of components to be valid</span></span><br><span class="line">    <span class="keyword">if</span>((_num_components &lt;= <span class="number">0</span>) || (_num_components &gt; n)) <span class="comment">// 如果特征数量不合法</span></span><br><span class="line">        _num_components = n; <span class="comment">// 将特征数量设置为样本数量</span></span><br><span class="line">    <span class="comment">// perform the PCA</span></span><br><span class="line">    <span class="comment">// 输入数据为行向量的形式</span></span><br><span class="line">    <span class="function">PCA <span class="title">pca</span><span class="params">(data, Mat(), PCA::DATA_AS_ROW, _num_components)</span></span>; <span class="comment">// 调用PCA算法</span></span><br><span class="line">    <span class="comment">// copy the PCA results</span></span><br><span class="line">    _mean = pca.mean.<span class="built_in">reshape</span>(<span class="number">1</span>,<span class="number">1</span>); <span class="comment">// 将PCA的均值赋值给_mean</span></span><br><span class="line">    _eigenvalues = pca.eigenvalues.<span class="built_in">clone</span>(); <span class="comment">// 将PCA的特征值赋值给_eigenvalues</span></span><br><span class="line">    <span class="built_in">transpose</span>(pca.eigenvectors, _eigenvectors); <span class="comment">// 将PCA的特征向量赋值给_eigenvectors</span></span><br><span class="line">    <span class="comment">// store labels for prediction</span></span><br><span class="line">    _labels = labels.<span class="built_in">clone</span>(); <span class="comment">// 将标签赋值给_labels</span></span><br><span class="line">    <span class="comment">// save projections</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sampleIdx = <span class="number">0</span>; sampleIdx &lt; data.rows; sampleIdx++) &#123; <span class="comment">// 遍历每一个样本</span></span><br><span class="line">        Mat p = LDA::<span class="built_in">subspaceProject</span>(_eigenvectors, _mean, data.<span class="built_in">row</span>(sampleIdx)); <span class="comment">// 计算投影</span></span><br><span class="line">        _projections.<span class="built_in">push_back</span>(p); <span class="comment">// 将投影结果保存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预测函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eigenfaces::predict</span><span class="params">(InputArray _src, Ptr &lt;PredictCollector&gt; collector)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从输入数组中获取数据</span></span><br><span class="line">    Mat src = _src.<span class="built_in">getMat</span>();</span><br><span class="line">    <span class="comment">// 确保用户传入的数据正确</span></span><br><span class="line">    <span class="keyword">if</span> (_projections.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        String error_message = <span class="string">&quot;This Eigenfaces model is not computed yet. Did you call Eigenfaces::train?&quot;</span>; </span><br><span class="line">        <span class="built_in">CV_Error</span>(Error::StsError, error_message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_eigenvectors.rows != <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(src.<span class="built_in">total</span>())) &#123;</span><br><span class="line">        <span class="comment">// 检查数据对齐</span></span><br><span class="line">        String error_message = format(</span><br><span class="line">                <span class="string">&quot;Wrong input image size. Reason: Training and Test images must be of equal size! Expected an image with %!d(MISSING) elements, but got %!d(MISSING).&quot;</span>,</span><br><span class="line">                _eigenvectors.rows, src.<span class="built_in">total</span>());</span><br><span class="line">        <span class="built_in">CV_Error</span>(Error::StsBadArg, error_message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据投影到PCA子空间</span></span><br><span class="line">    Mat q = LDA::<span class="built_in">subspaceProject</span>(_eigenvectors, _mean, src.<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    collector-&gt;<span class="built_in">init</span>(_projections.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 遍历投影数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> sampleIdx = <span class="number">0</span>; sampleIdx &lt; _projections.<span class="built_in">size</span>(); sampleIdx++) &#123;</span><br><span class="line">        <span class="comment">// 计算投影数据之间的距离</span></span><br><span class="line">        <span class="keyword">double</span> dist = <span class="built_in">norm</span>(_projections[sampleIdx], q, NORM_L2);</span><br><span class="line">        <span class="comment">// 获取标签</span></span><br><span class="line">        <span class="keyword">int</span> label = _labels.at&lt;<span class="keyword">int</span>&gt;((<span class="keyword">int</span>) sampleIdx);</span><br><span class="line">        <span class="comment">// 如果找到了满足条件的, 则终止循环</span></span><br><span class="line">        <span class="keyword">if</span> (!collector-&gt;<span class="built_in">collect</span>(label, dist))<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>可以发现,   除开一大段判别代码后,   EigenFace的训练方法的核心代码还是在于PCA,   不过PCA传回了三个值:   均值,   特征值,   特征向量;   训练方法只使用了特征向量这个值;   利用LDA计算投影,   并将其保存在_projections中,   以供后面的预测方法使用;   </p><p>EigenFace的预测方法:   用LDA将数据映射到PCA子空间,   然后挨个计算数据与投影之间的距离,   并汇总到收集器中进行判断,   而构造函数的中的阈值threshold应该是用于最后这里,   最后的代码的意思应该是如果成功找到了一个满足条件的,   则终止循环;   </p><p>所以如果想彻底还要再研究一下OpenCV对PCA和LDA的实现,   以及对收集器的实现;   </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/16/tong-xin-yuan-li/tong-xin-yuan-li-di-5-zhang-03/"/>
    <id>http://example.com/2023/02/16/tong-xin-yuan-li/tong-xin-yuan-li-di-5-zhang-03/</id>
    <published>2023-02-16T14:10:25.668Z</published>
    <updated>2023-02-22T13:35:30.142Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ</h2><p>[TOC]</p><h1 id="数字基带传输-03"><a href="#数字基带传输-03" class="headerlink" title="数字基带传输_03"></a>数字基带传输_03</h1><h2 id="限带信道中PAM信号无码间干扰基带传输"><a href="#限带信道中PAM信号无码间干扰基带传输" class="headerlink" title="限带信道中PAM信号无码间干扰基带传输"></a>限带信道中PAM信号无码间干扰基带传输</h2><h3 id="无码间干扰之传输实例"><a href="#无码间干扰之传输实例" class="headerlink" title="无码间干扰之传输实例"></a>无码间干扰之传输实例</h3><p>由于频带是有限的,   所以在信号传输的时候,   每个码元都会被限制在一定的频带之中,   而频带受限的话,   对应的时域就会展宽,   或者说在时域信号是无限的,   一个信号在有效持续时间内延展到其他的码元中去,   对其他码元造成影响,   被称为码间干扰;   </p><p>为了消除码间串扰,   需要在当前周期中信号的采样时刻处让其他的信号过零点即可,   也就是说在采样处,   其他信号的幅度值为0,   而需要采样的幅度值不为0即可;   也就是</p><p>$$<br>x(kT_s)=\left{ \begin{array}{rcl}<br>&amp;1(或非零常数)&amp;,   &amp;k=0时\<br>&amp;0&amp;,   &amp;k为其他常数\<br>\end{array}\right.<br>$$<br>对信号的频域图进行切割,   若切割并进行频谱搬移后的频谱可以成为一条平着的直线,   则可以进行无码间干扰传输,   而在频域上切割,   其实就是把频谱图的横坐标轴划分为一个一个的T<sub>s</sub>块,   如下图;   这种切割方式对信号的形状有所需求,   也就是把切割后的其他部分搬到基周期上来要能变成一条直线,   其次就是约束了T<sub>s</sub>,   它的倒数也就是码元速率R<sub>s</sub>,   所以无码间干扰基带传输是被限制了码率的;   </p><img src="D:/Program%20Files/Typora/img/image-20230217091038476.png" alt="image-20230217091038476" style="zoom:80%;" /><p>设切割的点为B<sub>N</sub>,   则无码间串扰的传输速率为R<sub>s</sub>=2B<sub>N</sub>;<br>$$<br>因为B_N=\frac1{2T_s}=\frac{R_s}2<br>$$</p><blockquote><p>总结</p><p>如果数字基带传输系统的传输函数在f=1/2T<sub>s</sub>处出现互补特性,   则无码间干扰的最大符号速率为1/T<sub>s</sub>,   称这种互补特性为滚降特性,   互补特性的中心频率点为滚降点,   若滚降点频率为B<sub>N</sub>,   则无码间干扰的最大符号速率R<sub>s</sub>=2B<sub>N</sub>,   在B<sub>N</sub>处可以叠加,   在B<sub>N</sub>/k处都可以进行互补叠加特性;   </p><p>在B<sub>N</sub>/k处都可以叠加是因为B<sub>N</sub>对应着R<sub>s_max</sub>,   R<sub>s_max</sub>对应着T<sub>s_min</sub>,   也就是时域上的最小抽样值,   这个抽样值和频域的零点是对应的,   而抽样值也可以选择每个两个零点抽样一次,   也可以选择每个三个零点抽样一次,   只不过这样T<sub>s</sub>增加,   R<sub>s</sub>就减小了,   但这样做是可以的;   </p><p>换句话说,   当T<sub>s</sub>=kT<sub>s_min</sub>,   则R<sub>s</sub>= 1/k R<sub>s_max</sub>,   则B’<sub>N</sub>= 1/k B<sub>N_max</sub>;   </p></blockquote><p>滚降点如果往内收缩,   最多收缩为理想低通的模样</p><img src="D:/Program%20Files/Typora/img/image-20230217093959578.png" alt="image-20230217093959578" style="zoom:80%;" /><p>此时的滚降点和带宽位于同一频率处,   由于得到了码元速率的单位Baud与滚降点频率的单位Hz之间的关系,   则在等效低通的时候,   由于B=B<sub>N</sub>,   则基带系统的频带利用率理论最大值<br>$$<br>η_{max}=\frac{R_s}{B}=2Baud/Hz<br>$$<br>奈奎斯特采样定律只能限制码元速率,   而不能限制信息速率,   因为R<sub>b</sub>=R<sub>s</sub>log<sub>2</sub>M,   信息速率可以获得进制数的增加带来的增益</p><img src="D:/Program%20Files/Typora/img/image-20230217095121444.png" alt="image-20230217095121444" style="zoom:80%;" /><h3 id="滚降特性"><a href="#滚降特性" class="headerlink" title="滚降特性"></a>滚降特性</h3><img src="D:/Program%20Files/Typora/img/image-20230217100641866.png" alt="image-20230217100641866" style="zoom:80%;" /><p>设滚降系数为<br>$$<br>\alpha=\frac{B-B_N}{B_N}<br>$$</p><p>由于R<sub>s_max</sub>=2B<sub>N</sub>,   所以最大频带利用率为<br>$$<br>\frac{R_s}{B}=\frac{2}{1+\alpha}<br>$$<br>α一般是在(0,   1)之间的,   所以最大频带利用率在(1,   2)之间;   </p><blockquote><p>对不同的α传输函数的比较</p><img src="D:/Program%20Files/Typora/img/image-20230217102512062.png" alt="image-20230217102512062" style="zoom:80%;" /><p>这个过程B<sub>N</sub>始终不变,   故R<sub>s</sub>始终不变;   </p><p>α=0时,   为理想低通,   呈矩形,   也就是最陡峭的时候,   带宽最小;   </p><p>α慢慢增大时,   陡峭程度开始减小,   α=1时,   陡峭程度变为最小,    带宽最大;   </p><p>在时域谱上看,   α=1时,   尾部衰减最快,   α=0时,   尾部衰减最慢;   </p><img src="D:/Program%20Files/Typora/img/image-20230217103046007.png" alt="image-20230217103046007" style="zoom:80%;" /><p>尾部衰减地越快,   定时容限就会越大,   对定时精度的要求就可以越小;   </p></blockquote><img src="D:/Program%20Files/Typora/img/image-20230217103326530.png" alt="image-20230217103326530" style="zoom:80%;" /><p>找到滚降的中心点即可,   1000,   500,   1000,   1500;   </p><p>对于矩形波,   其码元频带利用率就等于占空比<br>第一过零点带宽为1/τ,   码元速率为1/T<sub>s</sub>,   </p><img src="D:/Program%20Files/Typora/img/image-20230217104238121.png" alt="image-20230217104238121" style="zoom:80%;" /><p>对于滚降型波形</p><img src="D:/Program%20Files/Typora/img/image-20230217104818633.png" alt="image-20230217104818633" style="zoom:80%;" /><h3 id="最佳基带传输系统"><a href="#最佳基带传输系统" class="headerlink" title="最佳基带传输系统"></a>最佳基带传输系统</h3><p>指既可以消除码间干扰,   又可以使抗噪声性能最理想(误码率最小)的数字基带系统;   </p><p>基带系统传输总特性为<br>$$<br>X(f)=G_T(f)    C(f)G_R(f)<br>$$<br>把中间的信道看成一个滤波器,   但是先不考虑,   也就是假设信道为理想信道;   </p><p>由于要求无码间干扰,   所以该系统滤波器需要据有升余弦滚降特性<br>$$<br>X(f)=|X_{rc}(f)|e^{-j2\pi ft_d}<br>$$<br>后面跟了一个t<sub>d</sub>的时延是为了工程上的需要;   </p><p>由于要使系统的抗噪性能最佳,   所以接受滤波器需要为匹配滤波器,    而匹配滤波器的频域特性为—接收滤波器为发送滤波器的共轭乘一个延迟<br>$$<br>G_R(f)=G_T^*(f)e^{-j2\pi ft_0}<br>$$<br>式子代入上式,   </p><img src="D:/Program%20Files/Typora/img/image-20230217110730693.png" alt="image-20230217110730693" style="zoom:80%;" /><p>为了获得最佳基带传输系统，可使发送滤波器和接收滤波器的幅频特性分别等于升余弦的平方根频谱;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/12/tong-xin-yuan-li/tong-xin-yuan-li-di-5-zhang-02/"/>
    <id>http://example.com/2023/02/12/tong-xin-yuan-li/tong-xin-yuan-li-di-5-zhang-02/</id>
    <published>2023-02-12T12:25:11.770Z</published>
    <updated>2023-02-16T14:00:38.080Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ τ σ</h2><h1 id="数字基带传输-02"><a href="#数字基带传输-02" class="headerlink" title="数字基带传输_02"></a>数字基带传输_02</h1><h2 id="匹配滤波器"><a href="#匹配滤波器" class="headerlink" title="匹配滤波器"></a>匹配滤波器</h2><p>由于抽样器都是取波形中的其中一个脉冲进行01判断的,   所以可能会出错,   但是一个周期中的能量其实是极具说服力的,   是稳定表现该周期内传递的信息的,   所以在抽样之前建议对这个周期的能量进行某种变换,   也就是对这个周期的能量进行通盘考虑,   形成一个数,   判断这个数,   给出判别值;   </p><p>以此即可给出匹配滤波器的定义:   在接收机内采用一种线性滤波器,   当信号和加性噪声通过它时,   滤波器在某一个特定时刻进行抽样,   保证在抽样时刻的**<font color='red'>输出信噪比最大</font>**(也就是信号瞬时功率与噪声平均功率之比最大),   这种滤波器被称为匹配滤波器;   而输出信噪比就是上面说的对一个周期内的能量的衡量;   </p><p>匹配滤波器的时频表示:<br>$$<br>\begin{align*}<br>&amp;频域:   H(f)=KS^*(f)e^{-j2\pi ft_0}\\<br>&amp;时域:   h(t)=Ks(t_0-t)<br>\end{align*}<br>$$<br>也就是将输入信号沿y轴翻转,   然后向右平移t<sub>0</sub> ;   </p><p>t<sub>0</sub>为抽样时刻,   为保证滤波器物理可实现,   需要使t<sub>0</sub>-t&lt;0,   即t&gt;t<sub>0</sub>时,   s(t<sub>0</sub>-t)=0;   而为了让时延尽可能地小,   需要让t<sub>0</sub>尽可能地小,   则t<sub>0</sub>一般取信号消失地时刻;   </p><center>h(t)=Ks(T-t)</center><p>t<sub>0</sub>可以取更大,   但是最好是T时刻;<br>$$<br>\begin{align*}<br>&amp;输入信号:   s(t)\\<br>&amp;匹配滤波器:   h(t)=Ks(t_0-t)\\<br>&amp;输出信号:   s_o(t)= \int ^{\infty}_{-\infty}s(t-\tau)h(\tau)d\tau=KR(t-t_0)\\<br>&amp;采样时刻最大值:   s_o(t_0)=KR(0)=KE<br>\end{align*}<br>$$<br>也就是说匹配滤波器是一个相关器;   </p><img src="D:/Program%20Files/Typora/img/image-20230211221937480.png" alt="image-20230211221937480" style="zoom: 67%;" /><p>对于最大信噪比的结论,   匹配滤波器的最大信噪比与输入信号的波形无关,   持续时间无关,   只与信号的能量有关,   满足于上面说的”匹配滤波器通过能量进行信号的判决”;   </p><p>对于采样时刻信号+噪声的概率分布,   噪声的均值为0,   所以均值为信号的均值KE,   该信号没有直流功率,   只有交流功率,   所以信号的平均功率就是交流功率就是方差,   K<sup>2</sup>N<sub>0</sub>E/2;   </p><p>由于对应的题目一定会要求计算E的,   所以复习一下E的求法:   对信号求平方,   然后积分,   就可以的到能量;   </p><img src="D:/Program%20Files/Typora/img/image-20230212202349026.png" alt="image-20230212202349026" style="zoom:80%;" /><p>h(t)为匹配滤波器的冲激响应,   所以h(t)为原信号的对称翻转右移形式;   可先求出他们的自相关    s<sub>o</sub>(t)=s(t) * h(t)=R(t-t<sub>0</sub>),   然后再根据需要的t<sub>0</sub>进行调整;   输出的最大值出现在t<sub>0</sub>时刻</p><center>s<sub>o</sub>(t<sub>0</sub>)=R(0)=A<sup>2</sup>T</center><p>抽样时刻的概率密度函数需要求得均值和方差,   均值就是能量E,   方差依赖于E,   默认K=1;<br>$$<br>\begin{align*}<br>&amp;f(y)=\frac1{\sqrt{2\pi }\sigma_n}exp[-\frac{(y-a)^2}{2\sigma^2_n}]\\<br>&amp;a=A^2T\\<br>&amp;\sigma^2=\frac{K^2EN_0}2=\frac{N_0A^2T}{2}<br>\end{align*}<br>$$</p><blockquote><p>对老师课间给的题目的解析</p><p>题目:   AMI系统中，信息符号0、1等概分布，码元速率为10Baud。采用双极性归零码，波形为矩形波，占空比为0.5,   该系统的第一过零点带宽为多少?</p><p>码元速率为10Baud,   也就是每秒钟发送10个码元,   码元周期(也就是一个码的长度)为0.1s,   占空比对应着归零码,   也就是发送一个码元的那个波仅需要持续0.05s,   那么1/0.05=20hz就可以了,   吗?</p><p>不,   那是对于PAM信号而言的,   对于AMI码,   第一过零点带宽恒等于1/T<sub>s</sub>,   所以应该是1/0.1=10hz;   </p></blockquote><h2 id="AWGN信道条件下的2PAM数字基带系统的抗噪性能"><a href="#AWGN信道条件下的2PAM数字基带系统的抗噪性能" class="headerlink" title="AWGN信道条件下的2PAM数字基带系统的抗噪性能"></a>AWGN信道条件下的2PAM数字基带系统的抗噪性能</h2><p>对于高斯变量,   </p><img src="D:/Program%20Files/Typora/img/image-20230212213212567.png" alt="image-20230212213212567" style="zoom: 50%;" />$$\begin{align*}&U~N(a,   \sigma^2)\\\\&P(U>x)=Q(\frac d\sigma)=Q(\frac{x-a}\sigma)\\\\&P(U>x)=\frac12erfc(\frac{x-a}{\sqrt2\sigma})\end{align*}$$<h3 id="2PAM数基系统的抗噪模型"><a href="#2PAM数基系统的抗噪模型" class="headerlink" title="2PAM数基系统的抗噪模型"></a>2PAM数基系统的抗噪模型</h3><img src="D:/Program%20Files/Typora/img/image-20230212213436196.png" alt="image-20230212213436196" style="zoom:80%;" /><p>接收滤波器输出的信号y(t)是一个信号+噪声的高斯分布的波,   要从这个波中分出哪些是0哪些是1,<br>$$<br>s_i(t)=\left{ \begin{array}{rcl}<br>s_1(t),   &amp;b_k=1\<br>s_2(t),   &amp;b_k=0\<br>\end{array}\right.<br>$$<br>接收端出现两种错误:   </p><p>当发送s<sub>1</sub>(t)时,   噪声在抽样时刻呈现一个较大的负值,   使得接收端将它错判为s<sub>2</sub>(t),   其条件概率为P(e|s<sub>1</sub>);   </p><p>当发送s<sub>2</sub>(t)时,   噪声在抽样时刻呈现一个较大的负值,   使得接收端将它错判为s<sub>1</sub>(t),   其条件概率为P(e|s<sub>2</sub>);   </p><p>总误符号率为P<sub>b</sub>=P(s<sub>1</sub>)P(e|s<sub>1</sub>)+P(s<sub>2</sub>)P(e|s<sub>2</sub>)</p><p>接收端接收到信号,   需要对这个信号进行抽样,   而由于前面说过,   滤波器滤过的信号是一个信号值+噪声的高斯波,   所以抽样值如下:<br>$$<br>y(kT_b)=\left{ \begin{array}{rcl}<br>a+n_o(kT_b),   &amp;发s_1(t)时\<br>-a+n_o(kT_b),   &amp;发s_2(t)时\<br>\end{array}\right.<br>$$<br>所以抽样时刻的概率密度曲线如下图</p><img src="D:/Program%20Files/Typora/img/image-20230212215639347.png" alt="image-20230212215639347" style="zoom:80%;" /><p>由于目的是求得判决门限的取值,   误码率最小的判决门限的取法就是最佳取法,   所以根据这个图,   算出误码率;<br>$$<br>比如P(e|s_2)就是上图浅灰色那块区域的面积,   也等于Q(\frac{V_d-(-a)}{\sigma^2_n})=Q(\frac{V_d+a}{\sigma^2_n})<br>$$<br>然后就一顿算~~    就得到一个结论<br>$$<br>\begin{align*}<br>&amp;最佳判决门限V_d^<em>与初始的先验概率是相关的,\\<br>&amp;如果P(s_1)=P(s_2),则V_d^</em>=0;   \\<br>&amp;此时,   基带传输系统的总误比特率P_b为\\<br>&amp;P_b=Q(\frac a{\sigma_n})=Q(\sqrt{\frac {a^2}{\sigma_n^2}})=\frac12erfc(\sqrt\frac{a^2}{\sigma^2_n})<br>\end{align*}<br>$$<br>把误比特率写成第二个式子的形式,   是因为该式子可以看成信噪比,   即基带传输系统的误码率与抽样时刻的信噪比r直接相关,   其中r为<br>$$<br>r=\frac{a^2}{\sigma^2_n}<br>$$</p><p>以上为双极性,   而对于单极性,   等概时V<sub>d</sub>=a/2,   其误码率为<br>$$<br>P_b=Q(\sqrt{\frac {a^2}{4\sigma_n^2}})=\frac12erfc(\sqrt\frac{a^2}{8\sigma^2_n})<br>$$</p><blockquote><p>相同信噪比,   双极性的误码率更低;   </p><p>相同信噪比,   即r=a<sup>2</sup>/σ<sub>n</sub><sup>2</sup>相同,   因Q函数中单极性的分母大,   则分式整体小,   因Q函数为减函数,   故单极性的误码率较大,   双极性的误码率较小;   </p><p>但是在相同信噪比的前提下,   由于单极性和双极性的发送信号之平均功率不同,   所以这种对比是不公平的,   需要将单极性发1时的幅度值变为√2,   才公平;   </p></blockquote><h3 id="匹滤的最佳接收的误比特率"><a href="#匹滤的最佳接收的误比特率" class="headerlink" title="匹滤的最佳接收的误比特率"></a>匹滤的最佳接收的误比特率</h3><p>在使用匹配滤波器的前提下,   最小误码率的接受准则就映射为了最大信噪比的接受准则;   换句话说,   想要最小误码率,   就需要最大信噪比,   而如何获取最大信噪比呢? 就是使用匹配滤波器;   </p><p>双极性2PAM误比特率:   </p><p>前面提到通过匹配滤波器后,   得到的那个值a就是KE,<br>$$<br>s_o(kT_s)=\left{ \begin{array}{rcl}<br>&amp;KE,   &amp;发s_1(t)时\<br>&amp;-KE,   &amp;发s_2(t)时\<br>\end{array}\right.<br>$$<br>由于这是2PAM系统,   所以E<sub>b</sub>=E,   所有东西一伙带入,   得到双极性误码率<br>$$<br>P_b=Q(\sqrt{\frac{2E_b}{N_0}})=\frac12erfc(\sqrt\frac{E_b}{N_0})<br>$$</p><p>对于单极性,   抽样时刻<br>$$<br>s_o(kT_s)=\left{ \begin{array}{rcl}<br>&amp;KE_1,   &amp;发s_1(t)时\<br>&amp;0,   &amp;发s_2(t)时\<br>\end{array}\right.<br>$$<br>每bit能量E<sub>b</sub>=1/2E<sub>1</sub>误比特率为<br>$$<br>P_b=Q(\sqrt\frac{E_b}{N_0})=\frac12erfc(\sqrt\frac{E_b}{2N_0})<br>$$</p><p>该结论有较高的抽象性,   该结论表明,   两个信号只要能量相同,   在AWGN信道中,   当其他条件相同时,   这两个信号的抗噪性能是相同的,   不管这两个信号长什么样子;   </p><img src="D:/Program%20Files/Typora/img/image-20230216220030856.png" alt="image-20230216220030856" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ-τ-σ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/10/bi-ye-lun-wen/deng-yu-tong-di-san-ci-zhou-bao/"/>
    <id>http://example.com/2023/02/10/bi-ye-lun-wen/deng-yu-tong-di-san-ci-zhou-bao/</id>
    <published>2023-02-10T13:57:53.091Z</published>
    <updated>2023-02-10T14:51:08.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三次周报"><a href="#第三次周报" class="headerlink" title="第三次周报"></a>第三次周报</h1><ol><li><p>增加虹软人脸识别引擎于系统之中</p><p>使用配置文件的方式,   达到轻松修改识别算法的目的;   </p><img src="D:/Program%20Files/Typora/img/image-20230210215947385.png" alt="image-20230210215947385" style="zoom:80%;" /></li><li><p>初步测试</p><p>(1) 统计 “检测到人脸特征” 但是 “识别算法未识别出该人脸是谁” 的帧数;   </p><p>Eigen算法还是不能用;   </p><p>Fisher算法非常不够稳定,   有时候是3~6帧,   有时候是30多帧;   </p><p>LBPH算法足够稳定,   在0~2帧左右;   </p><p>虹软识别引擎足够稳定,   在0~1帧左右;   </p><p>(2) 统计侧脸识别率;   </p><p>基础算法都不行,   只有虹软引擎可以,   并且稳定在0~1帧;   </p><p>(3) 录入时和检测时的光照不同( 3.5瓦台灯全功率照明和关闭),   统计未识别帧数;  </p><p>LBPH算法在该种情况下不能够识别,   只有当照明度类似时才可以;   </p><p>虹软引擎可以识别,   且稳定在0帧;   </p><p>(4) 后面还有脸部阻隔物(如眼镜)测试,   歪脸测试,   虹软引擎都能完美驾驭,   而基础算法均不可以;   </p></li><li><p>待完成任务</p><p>​        该系统使用的OpenCV的jar包是带有扩展包的4.1.0,   它提供基于深度学习的人脸识别算法,   以后试试把它纳入到系统中来;   (之所以现在没有实现它,   是因为OpenCV把那些基础算法都扔到了扩展包中,   而在高版本的jar包中所实现的基于深度学习的人脸算法对应的类FaceRecognizerSF并没有继承于扩展包中所有人脸算法的实现子类的父类—FaceRecognizer,   自然不能像切换基础人脸算法类那样去更改实现子类;   FaceRecognizerSF有一套自己的书写标准,   所以还需要时间去琢磨)</p><p>​        像数据库那种东西就先不弄了;   </p></li><li><p>总结</p><p>这周着实没干嘛,   一直在准备省考😭,   还有开学考试😭😭;   </p><blockquote><p>向老师提问:   我现在有点不明白老师所说的多多挖掘算法到底是啷个意思,   指的是不同算法的测试吗? 还是要纳入更多的可选择人脸算法到系统中? 还是深入算法原理和实现? 还有对于不同算法的测试方法,   老师有没有啥子建议,   还望老师不吝赐教;   </p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三次周报&quot;&gt;&lt;a href=&quot;#第三次周报&quot; class=&quot;headerlink&quot; title=&quot;第三次周报&quot;&gt;&lt;/a&gt;第三次周报&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加虹软人脸识别引擎于系统之中&lt;/p&gt;
&lt;p&gt;使用配置文件的方式,   达到轻松修改识别算法的目的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/10/gong-wu-yuan-kao-shi/shen-lun-005/"/>
    <id>http://example.com/2023/02/10/gong-wu-yuan-kao-shi/shen-lun-005/</id>
    <published>2023-02-10T08:21:38.199Z</published>
    <updated>2023-02-10T09:09:15.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="评价类"><a href="#评价类" class="headerlink" title="评价类"></a>评价类</h2><p>评论类公文的识别—评论类公文的目的是对某些现象或观点进行评价;   </p><p>时评,   评论文;   </p><p>表态+相关要素+对策;   </p><blockquote><p>评论类文章的介绍必须写 !</p></blockquote><img src="D:/Program%20Files/Typora/img/image-20230210162543151.png" alt="image-20230210162543151" style="zoom:80%;" /><img src="D:/Program%20Files/Typora/img/image-20230210161837931.png" alt="image-20230210161837931" style="zoom:80%;" /><blockquote><p>复习</p><p>对答案时,   看有没有漏掉的点,   有没有规范词,   有没有表述可以简略,   重新梳理逻辑,   将给自己听,   最后重新蒙着答案将这道题做一遍,   再对答案查看剩余毛病;   </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;评价类&quot;&gt;&lt;a href=&quot;#评价类&quot; class=&quot;headerlink&quot; title=&quot;评价类&quot;&gt;&lt;/a&gt;评价类&lt;/h2&gt;&lt;p&gt;评论类公文的识别—评论类公文的目的是对某些现象或观点进行评价;   &lt;/p&gt;
&lt;p&gt;时评,   评论文;   &lt;/p&gt;
&lt;p&gt;表态+</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/09/gong-wu-yuan-kao-shi/shen-lun-003/"/>
    <id>http://example.com/2023/02/09/gong-wu-yuan-kao-shi/shen-lun-003/</id>
    <published>2023-02-09T12:15:05.732Z</published>
    <updated>2023-02-10T08:53:53.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公文题"><a href="#公文题" class="headerlink" title="公文题"></a>公文题</h1><p>写一份指导意见,   或者讲话稿;   </p><p>语言分—结尾号召一句就可以了;   </p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="具体格式"><a href="#具体格式" class="headerlink" title="具体格式"></a>具体格式</h3><ol><li><p>标题</p><p>发文机关+”关于”+事由+”的”+文种;   如果是非正式的,   不加发文机关;   </p><p>书写格式—标题要居中书写,   不带书名号;   尽量一行之内写下;   </p></li><li><p>称谓或主送机关</p><p>(1) 称谓(对象为人物)</p><p>尊敬的与会嘉宾,   广大的家长朋友们;   </p><p>(2) 主送机关(对象为单位)</p><p>各社区,   各街道办;   </p><p>(3) 书写格式</p><p>顶格书写;   </p></li><li><p>落款</p><p>(1) 单位(个人)</p><p>某企业工会(写在时间上一行);   </p><p>(2) 时间</p><p>xxxx年xx月xx日;   </p><p>(3) 书写格式</p><p>落款位于文章右下方,   日期右空四个格子(空几个都行),   发文者以日期为准上方居中;   </p></li></ol><blockquote><p>公文格式:   原则—标题一定写,   如果题干给了落款称呼,   那就写上;   </p><p>例外:   </p><p>特殊文种<br>        讲话稿,   发言稿—只写标题称呼<br>        工作方案,   调查报告—只写标题,   关于<br>        新闻稿,   评论类公文—只写标题</p><p>特殊要求<br>        提纲/内容要点/不必注意格式;   有这样的字样的不必写格式,   如果有空间则写标题;   </p></blockquote><h2 id="方案类"><a href="#方案类" class="headerlink" title="方案类"></a>方案类</h2><p>识别—为某个或某些对象能够更好地完成工作或任务而进行的规划,   一般侧重对策,   建议和具体做法;   </p><p>与主题相关的对策写在核心的部分,   其他要素写在开头;   </p><p>开头—交代缘由(背景,   根据,   目的,   意义,   问题)<br>主体—具体的解决问题的对策<br>结尾—看情况写</p><blockquote><p>如果题干中出现格式规范等词,   就说明是公文题;   </p></blockquote><h2 id="总结类"><a href="#总结类" class="headerlink" title="总结类"></a>总结类</h2><img src="D:/Program%20Files/Typora/img/image-20230209215305546.png" alt="image-20230209215305546" style="zoom:80%;" /><p>“编者按”可以不写标题</p><h1 id="规范词积累"><a href="#规范词积累" class="headerlink" title="规范词积累"></a>规范词积累</h1><p>多种身份的人——各界人士、各行各业人员</p><p>有用、有价值的事物——资源 </p><p>固定的方式方法——模式 </p><p>确定线上线下老师——双师教学</p><img src="D:/Program%20Files/Typora/img/image-20230210161732390.png" alt="image-20230210161732390" style="zoom:80%;" /><p>走访群众、了解群众情况——深入基层、基层走访</p><p>确保地区无违法、犯罪问题——治安、安全</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;公文题&quot;&gt;&lt;a href=&quot;#公文题&quot; class=&quot;headerlink&quot; title=&quot;公文题&quot;&gt;&lt;/a&gt;公文题&lt;/h1&gt;&lt;p&gt;写一份指导意见,   或者讲话稿;   &lt;/p&gt;
&lt;p&gt;语言分—结尾号召一句就可以了;   &lt;/p&gt;
&lt;h2 id=&quot;格式&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/08/gong-wu-yuan-kao-shi/shen-lun-002/"/>
    <id>http://example.com/2023/02/08/gong-wu-yuan-kao-shi/shen-lun-002/</id>
    <published>2023-02-08T12:31:44.524Z</published>
    <updated>2023-02-08T14:18:30.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h1><h2 id="词句解释题"><a href="#词句解释题" class="headerlink" title="词句解释题"></a>词句解释题</h2><p>题型识别:   谈谈你对什么什么观点    某句话的理解;   </p><p>思路:   整体写这个东西的定义,   展开写这个东西的相关要素并且做好预判,   写一些总结性的对策;   </p><img src="D:/Program%20Files/Typora/img/image-20230208212055532.png" alt="image-20230208212055532" style="zoom:80%;" /><p>词句解释题可以当作单一题去看待,   只不过需要分析好题干;   </p><h2 id="观点现象分析题"><a href="#观点现象分析题" class="headerlink" title="观点现象分析题"></a>观点现象分析题</h2><p>题型判断:   对…观点/现象/的看法/见解/评价/认识;   </p><p>思路:   </p><p>(1) 表态;   简介;   </p><p>(2) 分析理由;   围绕主题,   写出资料中能够支撑态度的各种要素(问题/定义/原因/意义/危害)</p><p>(3) 对策;   应该怎么做;   有则摘抄,   无则补充(在字数要求之内);   </p><p>技巧:   表态的方法与常用词汇</p><p>(1) 赞同:   正确的/科学的/合理的/全面的;   </p><p>(2) 反对:   不科学的/不合理的/不支持的/错误的/偏颇的/偏激的/绝对的/片面的;   </p><p>(3) 辩证看待:   有积极方面的,   也有消极方面的/有利有弊/有待考证/有待观察/尚未定论的;   (就算是10个优点加上1个缺点,   对这个东西的看待也应该是辩证的)</p><blockquote><p>如果有特殊要求–”有理有据,   论据充实”,   则答案中需要有事例;   </p></blockquote><blockquote><p>巧立名目:   变着法儿地出一些名目来达到一些不正当的目的;   </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;综合题&quot;&gt;&lt;a href=&quot;#综合题&quot; class=&quot;headerlink&quot; title=&quot;综合题&quot;&gt;&lt;/a&gt;综合题&lt;/h1&gt;&lt;h2 id=&quot;词句解释题&quot;&gt;&lt;a href=&quot;#词句解释题&quot; class=&quot;headerlink&quot; title=&quot;词句解释题&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/08/gong-wu-yuan-kao-shi/4-shu-liang-004/"/>
    <id>http://example.com/2023/02/08/gong-wu-yuan-kao-shi/4-shu-liang-004/</id>
    <published>2023-02-08T04:56:24.275Z</published>
    <updated>2023-02-08T08:00:19.160Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ"><a href="#≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ" class="headerlink" title="≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ"></a>≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √  Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ π φ</h2><h2 id="排列组合与概率"><a href="#排列组合与概率" class="headerlink" title="排列组合与概率"></a>排列组合与概率</h2><h3 id="分类与分步"><a href="#分类与分步" class="headerlink" title="分类与分步"></a>分类与分步</h3><p>分类,   就是单独的从这些东西中拿出一个来,   都可以完成某件事情,   这叫分类;   </p><p>分步,   先怎么怎么样再怎么怎么样,   就是分步;   </p><p>分类相加,   分布相乘;   说的应该是概率或者可选择的方法数;   </p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列与顺序相关,   组合与顺序无关;   从集合中任意挑选两个元素交换位置,   如果对结果有影响,   则为排列,   如果无影响则为组合;   </p><blockquote><p>或者说有顺序还是无顺序,   这样似乎就落入了高中数学排列组合的怪圈,   还是交换位置吧;   </p></blockquote><p>$$<br>\begin{align*}<br>&amp;A_n^m=n*(n-1)<em>(n-2)</em>…<em>(n-m+1)<br>\end{align</em>}<br>$$</p><blockquote><p>解释:   因为要满足右边有m个式子,   而[0,   m-1]刚好有m个式子,   所以最后是要加1;   </p><p>现在的我不需思考就可想出这个问题的答案,   但是与提问者已经天各一方;   </p></blockquote><p>$$<br>C^m_n=\frac {A^m_n}{A^m_m}=\frac{m*(m-1)<em>(m-2)</em>…<em>(m-n+1)}{m</em>(m-1)<em>(m-2)</em>…<em>2</em>1}<br>$$</p><blockquote><p>特定题型</p><ol><li><p>相邻,   捆绑法;   </p><p>要挨着的,   就先捆在一起,   当成一个整体去排;   </p></li><li><p>不相邻,   插空法;   </p><p>把没有要求的先排好,   空出空位给那些不想挨在一起的人;   后一步是A,   不是C;   </p></li><li><p>错位排列,   结论;   </p><p>题型判断:   每个人拿出一个什么东西,   不到自己这里;   </p><table><thead><tr><th>元素个数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>错排数</td><td>0</td><td>1</td><td>2</td><td>9</td><td>44</td></tr></tbody></table></li><li><p>枚举法(情况10中以内);   </p></li><li><p>圆桌排列;   n个人A<sup>n-1</sup><sub>n-1</sub>种情况;   (线性排列为A<sup>n</sup><sub>n</sub>)</p></li></ol></blockquote><h3 id="求概率"><a href="#求概率" class="headerlink" title="求概率"></a>求概率</h3><p>分类相加,   分步相乘</p><p>给情况求概率,   给概率求概率;   </p><blockquote><p>跟屁虫问题</p><p>识别:   两个主体,   做同一件事的概率;   </p><p>直接指定一个人,   不管他的概率,   看另一个人满足条件的概率是什么;   </p></blockquote><h3 id="容斥问题"><a href="#容斥问题" class="headerlink" title="容斥问题"></a>容斥问题</h3><p>两集合:   总数=A+B-A∩B+都不;   </p><p>三集合(标准型):   分别给出了两两交集,   A + B + C - A∩B - A∩C - B∩C + A∩B∩C + 都不;   识别—既…又…,   就是分开给的,   一部分人喜欢这个,   一部分人喜欢那个,   一部分人极喜欢这个又喜欢那个;   </p><p>三集合(非标准型):   统一给出满足两者,   A + B + C + 都不 - 满足两项 - 2 * 满足三项,   相当于贴窗户纸,   拿三张圆纸糊住,   两两相交的地方撕一片,   三三相交的地方撕两片就这样;   识别—参加两项,   喜欢两种;   参加这个的有多少人,   参加那个的有多少人,   参加**<font color='red'>两项活动</font>**的有多少人,   意思就是统一给出参加两项活动的人的数量;   </p><blockquote><p>方法:   几集合,   啥方法;   </p></blockquote><p>如果问只满足某一项的有多少,   没有对应的公式,   只能画图;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;≈-≡-≠-＝-≤≥-＜-＞-≮-≯-∷-±-＋-－-×-÷-／-∫-∮-∝-∞-∧-∨-∑-∏-∪-∩-∈-∵-∴-⊥-‖-∠-⌒-≌-∽-√-Ⅰ-Ⅱ-⊕-⊙∥α-β-γ-δ-ε-ζ-η-θ-Δ-π-φ&quot;&gt;&lt;a href=&quot;#≈-≡-≠-＝-≤≥-＜-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/07/gong-wu-yuan-kao-shi/4-shu-liang-003/"/>
    <id>http://example.com/2023/02/07/gong-wu-yuan-kao-shi/4-shu-liang-003/</id>
    <published>2023-02-07T08:36:29.849Z</published>
    <updated>2023-02-07T14:12:16.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="行程问题"><a href="#行程问题" class="headerlink" title="行程问题"></a>行程问题</h2><h3 id="基本行程"><a href="#基本行程" class="headerlink" title="基本行程"></a>基本行程</h3><p>火车过桥</p><p>火车完全通过桥走的路程:   路程=桥长-车长;   </p><p>火车完全在桥上走的路程:   路程=桥长-车长;   </p><p>等距离公式<br>$$<br>\overline{v}=\frac{2v_1v_2}{v_1 + v_2}<br>$$<br>如果v<sub>1</sub>和v<sub>2</sub>的距离相等,   就可以用等距离公式;   </p><p>如果路程为往返,   可以用等距离公式;   </p><p>如果单程上下坡距离相等,   可以用等距离公式;   </p><p>如果单程上下坡距离不相等,   不可以用等距离公式;   </p><p>如果往返上下坡距离不相等,   可以用等距离公式;   </p><p>如果是三段的,   并且是上坡下坡平坡的往返,   建议把上坡和下坡两段先求平均速度,   但是不能够求平坡和上(下)坡的,   因为往返速度不一样;   一般上坡和下坡的平均速度等于平坡;   </p><h3 id="相对行程"><a href="#相对行程" class="headerlink" title="相对行程"></a>相对行程</h3><p>相遇问题</p><p>S<sub>相遇</sub>=(V<sub>1</sub>+V<sub>2</sub>)T;   </p><p>追及问题</p><p>S<sub>追击</sub>=(V<sub>1</sub>-V<sub>2</sub>)T;   </p><p>要注意是追击距离,   追击距离其实就是初始距离,   如果有三辆车相对于被追击车的初始距离是相同的,   那么他们的追击距离就是相同的,   为初始距离;   </p><p>环形相遇</p><p>两人在环形跑道上跑,   相同地点,   相同时间点,   背向而行;   </p><p>S<sub>相遇</sub>=(V<sub>1</sub>+V<sub>2</sub>)T;   相遇一次,   S<sub>相遇</sub>=1圈,   相遇十四次,   S<sub>相遇</sub>=14圈;   </p><p>环形追及</p><p>在环形跑道上,   同时出发,   同向而行;   </p><p>S<sub>追及</sub>=(V<sub>1</sub>-V<sub>2</sub>)T;   </p><p>S<sub>追及</sub>为追击路程,   需要联系一下上面的哪个式子;   </p><p>同端出发</p><p>两人同一点出发,   同方向,   速度不同,   到另一端点再折回,   两人不断相遇;   </p><p>两个人一共走了 (V<sub>1</sub>+V<sub>2</sub>)T=2nS 这么多距离;   </p><p>其中n为两人相遇的次数,   S为单程距离;   </p><p>两端出发</p><p>(V<sub>1</sub>+V<sub>2</sub>)T=(2n - 1)S</p><p>流水行船<br>$$<br>\begin{align*}<br>&amp;V_{顺}=V_{船}+V_{水}&amp; V_{逆}=V_{船}-V_{水}\\<br>&amp;V_{船}=\frac{V_{顺}+V_{逆}}{2}&amp;V_{水}=\frac{V_{顺}-V_{逆}}{2}\\<br>&amp;静水速度=船速&amp;漂流速度=水速<br>\end{align*}<br>$$</p><h2 id="几何问题"><a href="#几何问题" class="headerlink" title="几何问题"></a>几何问题</h2><p>面积公式<br>$$<br>\begin{align*}<br>&amp;S_{菱形}=\frac{对角线乘积}2&amp;S_{扇形} =\frac{n}{360}\pi r^2 \\<br>\end{align*}<br>$$<br>表面积公式<br>$$<br>\begin{align*}<br>&amp;S_{正方体}=6a^2&amp;S_{长方体}=2ab+2bc+2ac\\<br>&amp;S_{球}=4\pi r^2&amp;S_{圆柱}=2\pi r^2+2\pi rh\\<br>\end{align*}<br>$$</p><p>体积公式<br>$$<br>\begin{align*}<br>&amp;V_{正方体}=a^3&amp;V_{长方体}=abc\\<br>&amp;V_{柱体}=Sh&amp;V_{锥体}=\frac13Sh &amp;&amp; V_{球}=\frac34\pi r^3<br>\end{align*}<br>$$</p><p>勾股定理</p><p>3    4    5以及6    8    10以及5    12    13;   </p><p>后面两组面积等于周长;   </p><p>面积比例</p><p>底相同的三角形,   面积比等于高之比;    </p><p>高相同的三角形,   面积比等于底边之比;   </p><p>相似图形,   边之比等于相似比,   面积比=相似比的平方,   体积比=相似比的平方</p><p>几何最值</p><p>四边形周长一定时,   正方形面积最大;   若2(a+b)一定,   当a=b时,   a * b最大;   </p><p>四边形面积一定时,   正方形周长最小;   若a * b一定,   当a=b时,   a+b最小;<br>$$<br>a+b≤2ab<br>$$</p><p>平面最短距离</p><p>点到点,   直接连;   点到线,   做镜面;   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;行程问题&quot;&gt;&lt;a href=&quot;#行程问题&quot; class=&quot;headerlink&quot; title=&quot;行程问题&quot;&gt;&lt;/a&gt;行程问题&lt;/h2&gt;&lt;h3 id=&quot;基本行程&quot;&gt;&lt;a href=&quot;#基本行程&quot; class=&quot;headerlink&quot; title=&quot;基本行程&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
</feed>
