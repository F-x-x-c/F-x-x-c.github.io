<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CSAPP_Chapter3 | Aegis</title><meta name="author" content="Deng"><meta name="copyright" content="Deng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 程序编码本小结基于C语言到可执行文件的变化过程,   稍微深入地讲解了各个过程;     首先涉及Linux的一个指令 linux&gt; gcc -Og -o p p1.c p2.c  p1.c和p2.c是要编译的文件,   -Og是一种优化策略,   .i文件被编译器编译为汇编代码时,   可以选择不同的汇编代码实现,   -O1和-O2这两种优化策略的目的是为了提高汇编代码的效率,   但这">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP_Chapter3">
<meta property="og:url" content="http://example.com/2022/03/08/csapp/csapp-chapter3/index.html">
<meta property="og:site_name" content="Aegis">
<meta property="og:description" content="1. 程序编码本小结基于C语言到可执行文件的变化过程,   稍微深入地讲解了各个过程;     首先涉及Linux的一个指令 linux&gt; gcc -Og -o p p1.c p2.c  p1.c和p2.c是要编译的文件,   -Og是一种优化策略,   .i文件被编译器编译为汇编代码时,   可以选择不同的汇编代码实现,   -O1和-O2这两种优化策略的目的是为了提高汇编代码的效率,   但这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-03-08T12:09:50.000Z">
<meta property="article:modified_time" content="2022-06-19T02:38:05.675Z">
<meta property="article:author" content="Deng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/03/08/csapp/csapp-chapter3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CSAPP_Chapter3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-19 10:38:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Aegis" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.picsum.photos/id/145/4288/2848.jpg?hmac=UkhcwQUE-vRBFXzDN1trCwWigpm7MXG5Bl5Ji103QG4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aegis</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CSAPP_Chapter3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-created" datetime="2022-03-08T12:09:50.000Z" title=" 2022-03-08 20:09:50">2022-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-updated" datetime="2022-06-19T02:38:05.675Z" title=" 2022-06-19 10:38:05">2022-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSAPP/">CSAPP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CSAPP_Chapter3"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-程序编码"><a href="#1-程序编码" class="headerlink" title="1. 程序编码"></a>1. 程序编码</h1><p>本小结基于C语言到可执行文件的变化过程,   稍微深入地讲解了各个过程;   </p>
<ol>
<li><p>首先涉及Linux的一个指令</p>
<center>linux> gcc -Og -o p p1.c p2.c</center>

<p>p1.c和p2.c是要编译的文件,   -Og是一种优化策略,   .i文件被编译器编译为汇编代码时,   可以选择不同的汇编代码实现,   -O1和-O2这两种优化策略的目的是为了提高汇编代码的效率,   但这降低了汇编代码的可读性,   而-Og遵循了C源程序的整体结构,   易于阅读;   -O p是指生成的可执行文件的名字为p;   然后讲了一些基本的汇编知识,   或者说是基本常识;   </p>
</li>
<li><p>再涉及另外一个命令</p>
<center>linux> gcc -Og -S mstore.c</center>

<p>意思是在把mstore.c编译并生成mstore.s后就停下;   </p>
</li>
<li><p>最后反编译了一个C源文件和一个可执行二进制文件,   分析了一下他们有什么不同;   第一个不同在第四行,   源反汇编结果显示的是还运行到这一行代码,   所以显示的是函数名multstore加上一个偏移量,   而二反汇编的第四行是直接显示mult2的地址,   意思就是该地址已经被计算出来了;   第二个不同就是地址的不同,   二反汇编的代码表示链接器将这个程序加载到了内存里;   第三个不同在二反汇编的第8~9行,   比源反汇编多出了两个nop,   起主要作用是进行内存填充,   可能和缓存行有关,   因为CPU读取主存中的数据时的单位是缓存行,   进行16字节对齐,   可以避免CPU在读取下一个缓存行,   也就是另外的程序时,   不需要再次读取本缓存行;   </p>
<p><img src="https://s2.loli.net/2022/03/10/tmAaRYZjld7qFhr.png" width="800"></img></p>
<p><img src="https://s2.loli.net/2022/03/10/xJAonHZ9PEuSKTW.png" width="800"></img></p>
</li>
</ol>
<h1 id="2-数据格式"><a href="#2-数据格式" class="headerlink" title="2. 数据格式"></a>2. 数据格式</h1><p>Intel使用1”字”表示16比特,   汇编的操作符后面会有一个表示操作数大小的符号后缀,   注意整型和双精度使用的是同一个字母—L,   不会产生歧义的原因是,   浮点数拥有一套不同的指令,   使用的寄存器也和整型不同;   </p>
<h1 id="3-访问数据"><a href="#3-访问数据" class="headerlink" title="3. 访问数据"></a>3. 访问数据</h1><p>本小节介绍了寄存器的简单使用,   其中%rsp用于指定运行时栈的结束位置;   而其他的寄存器的使用规则则相对比较灵活;   </p>
<p>操作数,   也就是操作提示符后面的那个东西,   他有3种格式,   分别是立即数,   寄存器和内存;   立即数用$x的形式来表示,   他的值是x;   寄存器用r<sub>a</sub>来表示,   他的值是r<sub>a</sub>里面存储的值,   内存的表示方式有很多种,   其中最复杂的由4个部分组成—Imm(r<sub>b </sub> ,  r<sub>i</sub> ,  s),   分别是立即偏移量,   基址寄存器,   索引寄存器和比例因子,   计算出的地址为</p>
<center>Imm + R[r<sub>b </sub>] + R[r<sub>i</sub>] * s</center>

<p>而其他的内存表示方式只是这种表示方式的变种;   M{ Imm + R[r<sub>b </sub>] + R[r<sub>i</sub>] * s }表示取得那个地址的值;   </p>
<h2 id="3-2数据移动指令mov"><a href="#3-2数据移动指令mov" class="headerlink" title="3.2数据移动指令mov"></a>3.2数据移动指令mov</h2><p>移动指令的最常见的写法就是在mov后面添加操作数的大小,   这需要和寄存器的大小对应起来;   具体而言,   虽然x86的寄存器是64位的,   但可以用位数较低的寄存器名称去表示这些寄存器的低位部分,   比如如下代码;   另外需要注意一点,   把立即数放入寄存器中的时候,   b,   w和q都是直接赋值,   而L不一样,   因为x86规定,   往寄存器中传入32bit数据时,   需要将该寄存器的高32bit设置为0,   比如如下代码的第4行;   而L代表long = 2word = 32bit;   </p>
<p>mov操作的源操作数和目的操作数都可以是寄存器或者内存,   但是不允许同时为内存,   如果硬要把数据从一块内存复制到另一块内存,   需要先复制到寄存器,   再复制到另一块内存;   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movabsq $0x0011223344556677, %rax 	;%rax = 0011223344556677 </span><br><span class="line">movb $-1, %al 						;%rax = 00112233445566FF </span><br><span class="line">movw $-1, %ax 						;%rax = 001122334455FFFF </span><br><span class="line">movl $-1, %eax 						;%rax = 00000000FFFFFFFF </span><br><span class="line">movq $-1, %rax 						;%rax = FFFFFFFFFFFFFFFF</span><br></pre></td></tr></table></figure>

<p>而mov有两种变种,   分别是movz和movs,   用于零扩展和符号位扩展,   与mov不同的是,   这两个指令需要指明源操作数和和目标操作数的大小,   而movz操作并没有提供32位扩展为64位的指令,   也就是movzlq,   因为他可以被movl加上上面所说的movl的性质代替;   相应地,   movs也为32位扩展为64位提供了特殊的指令,   cltq,   该指令没有操作数,   他总是以eax为源操作数,   rax为目的操作数进行符号位扩展;   </p>
<h2 id="3-3-压栈和弹栈"><a href="#3-3-压栈和弹栈" class="headerlink" title="3.3 压栈和弹栈"></a>3.3 压栈和弹栈</h2><p>压栈和弹栈属于数据移动指令;   压栈和弹栈都是针对于%rsp这个寄存器而言的,   %rsp为栈顶指针,   压栈操作</p>
<center>pushq %rax</center>

<p>的意思是</p>
<center>sub $8,  %rsp<br>movq %rax,  (%rsp)</br></center>

<p>也就是将栈顶指针往上移动让其指向的地址值变小,   空出8个字节出来,   将%rax的值放入空出来的空间里,   就完成了压栈操作;   而弹栈就是将栈顶元素弹出后,   用指令pop后面的寄存器接收一下,   然后把%rsp的地址值增大8字节,   也就是向下移动8个单位,   留在内存里的%rax的值只需要等待被下一个pushq覆盖即可;   </p>
<h2 id="3-4-算术和逻辑运算"><a href="#3-4-算术和逻辑运算" class="headerlink" title="3.4 算术和逻辑运算"></a>3.4 算术和逻辑运算</h2><p><img src="https://s2.loli.net/2022/03/14/4n1xGE8ItVszvjg.png" width="600"></img></p>
<ol>
<li><p>lea(load effective address)</p>
<p>leaq其实是movq的一个变种,   他的格式如下,   </p>
<center>leaq (%rdx) %rax</center>

<p>意思是将%rdx的值扔到%rax里,   源操作数看上去是地址解引用,   但其实并没有,   他只是一个取地址的操作;   正因如此,   leaq可以进行简单的运算,   比如,   </p>
<center>leaq 6(%rax),   %rdx  等于  movq 6 + %rax,   %rdx</center></li>
<li><p>一元运算</p>
<p>只有一个操作数的运算,   也就是说他的源操作数和目的操作数都是运算符后面的那个东西,   要么是寄存器,   要么是内存地址;   而最后的结果也存于那个东西里;   </p>
<p>而这里又有取反和取补,   复习一下他们俩,   取补的意思是啥也不管直接全部位反转,   取反的意思是拿到一个有符号数字对应的负数,   他们的关系是</p>
<center>-x = ~x + 1</center></li>
<li><p>二元运算之加减乘除</p>
<p>有两个操作数的运算,   运算结果被放在目的操作数里;   注意两个操作数不能同时为内存地址,   这和mov是一样的;   </p>
</li>
<li><p>二元运算之移位</p>
<p>两个左移符号的功能是一样的;   而右移的两个符号一个是算术右移,   一个是逻辑右移;   移动的位数取决于一个特定的寄存器%cl,   由于他是8位的寄存器,   所以可以表示的移动位数为255;   </p>
</li>
</ol>
<p>之后介绍了一些特殊的运算符,   这里不做过多解释了;   </p>
<p>以上分析的都是线性代码,   C语言中还存在一些循环和选择分支,   他们并不是按照线性执行的;   </p>
<h1 id="4-控制"><a href="#4-控制" class="headerlink" title="4. 控制"></a>4. 控制</h1><h2 id="4-1-条件代码"><a href="#4-1-条件代码" class="headerlink" title="4.1 条件代码"></a>4.1 条件代码</h2><p>除了上述的整型寄存器,   CPU还维系着一些状态码寄存器,   用于存储运算过程中的进位和溢出等操作;   </p>
<p>(1)CF(Carry Flag):   判断最近一次无符号数操作是否溢出;   </p>
<p>(2)ZF(Zero Flag):     判断最近一次操作是否产生0;   </p>
<p>(3)SF(Sign Flag):     判断最近一次操作是否产生负数;   </p>
<p>(4)OF(OverFlow Flag):   判断最近一次有符号数是否产生溢出,   包括向上溢出和向下溢出;   </p>
<p>3.4所示的图中,   leap不会对状态寄存器进行操作,   而剩下所有的操作都会改变状态寄存器,   自加和自减不会改变CF…</p>
<p>另外,   还有两类只会改变状态寄存器,   而<strong>不会更新目的寄存器</strong>:   cmp和test;   他们都有1,   2,   4,   8字节的模式,   这和前面的寄存器是一样的,   cmp和sub操作是一样的,   test和and操作是一样的;  </p>
<table>
<thead>
<tr>
<th>执行顺序取决于测试的结果,   这其实说的是后面关于循环的内容,   一个while循环,   可以用类似于C语言中的goto的汇编的方式实现,   也就是先判断,   依据判断的结果来选择需要跳到哪句代码;   而测试来自于if()括号中的元素,   他被命名为test;</th>
</tr>
</thead>
</table>
<h2 id="4-2-使用条件代码"><a href="#4-2-使用条件代码" class="headerlink" title="4.2 使用条件代码"></a>4.2 使用条件代码</h2><p>条件代码可以实现数据的比较,   具体做法是,   先通过cmp对两个数进行比较,   cmp会对状态码寄存器进行更新,   通过这些寄存器的简单组合和运算后,   就可以表示出两个数的大小;   x86提供了set指令,   用于对他的操作数进行更新,   </p>
<p><img src="https://s2.loli.net/2022/03/16/4RayN8sEXzkbVYK.png" width="600"></img></p>
<p>也就是说,   先比较(cmp),   再计算,   再存储(set %al),   再返回(ret);   这样就可以完成判断;   这里要注意的是,   cmp和test语句有两个操作数,   cmp时是拿后一个去减前一个;   </p>
<p>比如说判断a&lt;b,   通过如下的推导,   可以得出这个表达式的状态寄存器的表示方式,   推导过程如下图;   </p>
<p><img src="https://s2.loli.net/2022/03/16/aLziPgW1rEAtjIX.png" width="800"></img></p>
<table>
<thead>
<tr>
<th>总结一句话,   判断两个值的大小是通过改变状态寄存器,   并加之一定的逻辑判断来实现的;</th>
</tr>
</thead>
</table>
<h2 id="4-3-跳跃指令"><a href="#4-3-跳跃指令" class="headerlink" title="4.3 跳跃指令"></a>4.3 跳跃指令</h2><table>
<thead>
<tr>
<th>跳跃指令用于实现C语句if,   以及其他的一些循环语句</th>
</tr>
</thead>
</table>
<p>跳跃指令分为条件跳跃和非条件跳跃,   非条件跳跃有两种,   直接跳跃和间接跳跃;   </p>
<p>直接跳跃    jmp  *%rax    直接把%rax的值作为目标指令的地址;   </p>
<p>间接跳跃    jmp *(%rax)  把%rax的值作为地址,   去读取这个地址对应的值,   把那个值作为目标指令的地址;   </p>
<p>而条件跳跃只能是直接的;   </p>
<h2 id="4-4-跳跃指令编码"><a href="#4-4-跳跃指令编码" class="headerlink" title="4.4 跳跃指令编码"></a>4.4 跳跃指令编码</h2><p>采用最多的跳跃指令编码的方式是”rip相关法”(PC-relative),   中文名字我乱编的;   </p>
<p>对下面的程序进行分析,   其中第二行和第五行是跳跃指令;   </p>
<p><img src="https://s2.loli.net/2022/03/17/BZb7tsVTKNjrzel.png" width="600"></img></p>
<p>发现第二行的偏移量为0x8 = 0x03 + 0x5,   0x03为第二行的指令的二进制编码的第二个十六进制数,   0x5为下一条指令的地址;   要注意的是,   0x03是一个八位补码,   比如第五行的跳跃指令</p>
<center>0x5 = 0xf8 + 0xd</center>

<p>其中0xf8为-8<sub>(10)</sub>;   </p>
<p>当程序运行到第二行时,   %rip指向下一条代码,   也就是%rip = 0x5,   这样就可以使用%rip算出该行跳跃指令的偏移量;   这样做的目的是让跳跃指令可以编码为两个十六进制数,   使得编码更加紧凑;   </p>
<p>总结下来,   跳跃指令的目的地址的计算方法为,   </p>
<center>目的地址 = 下一条指令的地址 + 跳跃指令语句的第二个十六进制数</center>

<p>目的地址也就是要跳转到的指令的地址,   下一条指令的地址指的是跳跃指令的下一条指令的地址;   另外还需要注意两点,   一是如果编码后的跳跃指令的操作符后面的数字,   也就是偏移量,   有好几个十六进制数的话,   首先需要考虑该机器使用的是大端法还是小端法,   然后再进行计算;   另外一点就是,   如果偏移量的高位全是fff,   计算其补码的快捷方法为:   找到最后一个f的最后一个位,   取其权重,   然后减去这个位后面的那些位形成的无符号数;   </p>
<h2 id="4-5-实现条件分支1"><a href="#4-5-实现条件分支1" class="headerlink" title="4.5 实现条件分支1"></a>4.5 实现条件分支1</h2><p>该方法使用条件控制来实现条件分支,   汇编里使用条件控制实现条件分支的方式类似于C语言中的goto语句,   也就是当满足某一条件时,   就goto,   在汇编里就是jmp,   而实际情况下基本都是条件跳跃和非条件跳跃一起使用的,   模板如下:   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = text_expr;   </span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">    <span class="keyword">goto</span> <span class="literal">false</span>;   </span><br><span class="line">  then-statement</span><br><span class="line">    <span class="keyword">goto</span> done;   </span><br><span class="line"><span class="literal">false</span>:   </span><br><span class="line">  <span class="keyword">else</span>-statement</span><br><span class="line">done:   </span><br><span class="line">  done-statement</span><br></pre></td></tr></table></figure>

<p>可以看到,   在跳转到then语句和false语句时使用的是条件跳跃,   而在跳转至done语句时使用的是非条件跳跃,   目的是让gcc只执行then语句和false语句中的其中一个;   </p>
<p>练习题3.18表明,   通过条件控制来实现条件分支时一般使用的是上述模板,   而且这个模板在没有else语句时效率更高;   </p>
<h2 id="4-6-实现条件分支2"><a href="#4-6-实现条件分支2" class="headerlink" title="4.6 实现条件分支2"></a>4.6 实现条件分支2</h2><p>该方法使用条件移动指令来实现条件分支,   具体而言,   现代的处理器采用了流水线的技术,   把指令拆分为一堆微指令,   以此来提高处理编码的效率,   而遇到分支的时候,   两个分支都执行,   那么在最后时刻只需要把结果放入相应的内存或寄存器或返回即可,   使得预测失败时不需要退回来选择另外一个分支再执行;   </p>
<p>第一种方式的图示如下;   </p>
<p><img src="https://s2.loli.net/2022/04/16/B389gKZYcJL4fj6.png" width="700"></img></p>
<p>而第二种方式的图示如下</p>
<p><img src="https://s2.loli.net/2022/04/16/EIbfpUvS62rae79.png" width="200"></img></p>
<p>而第一种实现里有两个全局变量lt_cnt和ge_cnt,   他们的作用是强制让gcc不使用条件移动指令来实现条件代码;   </p>
<p>下面是本人在云主机上的实验,   对象是删除了上面的两个全局变量和没有删除的absDiff_se;   需要注意的是只有写在函数里面才有效;   </p>
<p>删除了全局变量后编译出来的汇编代码如下图,   可以看到absDiff_se在最后使用了条件移动指令;   </p>
<p><img src="https://s2.loli.net/2022/04/16/xV69QjnNBC8kqa5.png" width="700"></img></p>
<p>而加上了全局变量的汇编代码如下图,   可以看到absDiff_se是老老实实地使用了条件跳跃指令;   </p>
<p><img src="https://s2.loli.net/2022/04/16/rRujfgoOb9nNCBP.png" width="700"></img></p>
<p>对于三元运算符</p>
<center>v = test-expr  ?  then-expr  :  else-expr;   </center>

<p>使用条件移动指令可以把它抽象为下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = then-expr;   </span><br><span class="line">ve = <span class="keyword">else</span>-expr;   </span><br><span class="line">t = test-expr;   </span><br><span class="line"><span class="keyword">if</span>(!t) v = ve;   </span><br></pre></td></tr></table></figure>

<p>总结:   条件语句的实现有两种,   一种通过条件控制指令,   我喜欢叫它条件跳跃因为它的汇编指令中有jmp,   一种通过条件移动指令;   条件控制指令类似于C语言中的goto语句;   条件移动指令则是将两个分支都执行,   然后在最后通过条件判断做选择;   </p>
<h1 id="5-循环"><a href="#5-循环" class="headerlink" title="5. 循环"></a>5. 循环</h1><ol>
<li><p>do-while循环</p>
<p>该循环为执行一次执行体,   再判断,   通过判断的结果来选择是否继续执行,   do-while的C语言式汇编如下图;   </p>
<p><img src="https://s2.loli.net/2022/04/17/sdqpGehYn3yJESu.png" width="300"></img></p>
</li>
<li><p>while循环</p>
<p>具体实现有两种;   </p>
<p>(1) 跳转至中间(jump to middle)</p>
<p><img src="https://s2.loli.net/2022/04/17/Jxbj6YIgOwvLQro.png" width="300"></img></p>
<p>(2) 保护do(guarded do)</p>
<p><img src="https://s2.loli.net/2022/04/17/JDIsde2bwWXfzov.png" width="300"></img></p>
<p>使用优化版本为-O1时,   编译器会进行一些在不出错情况之下的优化,   比如说</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    body-expr;   </span><br><span class="line">    n--;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被优化为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n != <span class="number">1</span>) &#123;</span><br><span class="line">    body-expr;   </span><br><span class="line">    n--;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="6-过程"><a href="#6-过程" class="headerlink" title="6. 过程"></a>6. 过程</h1><p>在不同的编程语言中,   过程的表述不尽相同,   比如函数,   方法等;   但是它们都有一些共同的特性:   传递控制,   传递数据,   分配和释放内存;   </p>
<h2 id="6-1-运行时栈"><a href="#6-1-运行时栈" class="headerlink" title="6.1 运行时栈"></a>6.1 运行时栈</h2><p>在大多数情况下,   过程中回调用其他的过程,   所以需要有一个容器去存放这些个过程以及它们的调用顺序(这里本人有些词不达意),   而栈是一个良好的选择;   举个例子,   过程P调用过程Q,   只要开始执行过程Q的代码,   那必然过程P是被挂起的,   说的抽象一点就是,   过程调用是先进先出的,   这恰好符合栈的特点;   </p>
<p>当某个过程被执行时,   寄存器也在存放参数和局部变量,   如变量的个数大于寄存器的个数,   就会在运行时栈的栈顶开辟一些空间,   用于存放这些多出来的变量,   这些额外开辟出来的空间被称为栈帧(Stack Frame),   开辟的方式为将栈顶指针rsp往上拨动到某个内存地址的位置,   就好像用老式秤来称重时,   去拨动秤砣连着的那条线一样,   rsp就是秤砣连着的挂在秤杆上的那一条线;   栈帧通常情况下是在过程调用之前就已经分配好了的,   意味着它的大小是固定的,   当然也有些过程需要可变大小的栈帧;   </p>
<table>
<thead>
<tr>
<th>注意此处本人把内存地址变大的方向设置为下,   这样的话运行时栈的口子就是朝上的,   贴切于生活中的桶子;   那这样的话,   自然而然,   将栈扩大的操作就是将rsp往内存地址比较小的地方拨动;   本人和CSAPP里的表示方法是相反的;</th>
</tr>
</thead>
</table>
<h2 id="6-2-控制权转换"><a href="#6-2-控制权转换" class="headerlink" title="6.2 控制权转换"></a>6.2 控制权转换</h2><p>这一小节研究的玩意儿是当一个过程调用另外一个过程时发生的事情;   仍然设函数P调用函数Q,   这样的话函数P就为调用函数,   而Q为被调函数;   </p>
<p>在x86-64中,   一个函数通过call指令来调用另外一个函数;   而在执行完被调用函数后,   要使得%rip指向调用函数的call指令的下一条语句,   就必须要使得调用函数在调用被调函数之前保存一些信息,   这些稍后都会谈到;   </p>
<p>下面阐述完整的函数调用过程:   调用函数使用call指令调用被调函数,   如果被调函数带有参数的话,   第一个参数存储在%rdi中,   表示参数传递;   此时,   call指令需要把call指令的下一条指令的地址压入运行时栈的栈顶(%rsp的地址减小以存放返回地址),   PC指向被调函数的第一条指令地址,   此时,   控制权转换就完成了,   控制权从调用函数转移到了被调函数;   被调函数一直执行,   当执行到了ret时,   如果被调函数有返回值的话,   返回值会被存放在%rdx中,   表示返回值传递;   而此时,   ret指令会从运行时栈的栈顶将栈顶元素弹出,   将其视作返回地址并让PC指向该地址,   这样就完成了整个call指令;   </p>
<p><img src="https://s2.loli.net/2022/04/24/yRoMjr5WQaiAZVk.png" width="800"></img></p>
<h2 id="6-2-数据传输"><a href="#6-2-数据传输" class="headerlink" title="6.2 数据传输"></a>6.2 数据传输</h2><p>函数之间的数据传输包括了调用时的参数传递和返回时的返回值传递;   在参数传递时,   如果参数的个数大于6个,   未超出的部分由寄存器传递,   而超出的那些参数由调用函数开辟栈帧来进行传递;   注意执行call指令时应该是先把参数该放哪儿放哪,   然后再把返回地址压到栈顶;   寄存器的使用顺序也容易记住:   </p>
<table>
<thead>
<tr>
<th>锅底抵(di)着灶,   烧(s)火,   倒(d)油,   锅铲去铲(c),   把酒(89)言欢;</th>
</tr>
</thead>
</table>
<p><img src="https://s2.loli.net/2022/04/25/oU7VtxlyekmRiO2.png" width="800"></img></p>
<h2 id="6-3-栈的临时存储"><a href="#6-3-栈的临时存储" class="headerlink" title="6.3 栈的临时存储"></a>6.3 栈的临时存储</h2><p>存储函数的局部变量的工作一般由寄存器来承担,   但在有些情况中,   局部变量需要被存放在内存中,   一是寄存器不够了,   二是对局部变量使用了取地址符号&amp;,   三是创建了局部的数组或结构体;  <strong>第二种情况是说,   如果往被调用函数中传递了局部变量的指针,   那么在调用函数中就一定要将该局部变量放入栈帧当中,   因为只有这样才能够给该局部变量一个地址,   使得取地址操作能够进行;</strong>   </p>
<p>本小节的第1个例子对应于上述的第二种情况,   如下两图所示;   </p>
<p><img src="https://s2.loli.net/2022/04/25/GaW5874Y2ZlRiEK.png" width="500"></img></p>
<p><img src="https://s2.loli.net/2022/04/25/BkT7HNt64vDLouA.png" width="600"></img></p>
<p>可以看到,   在C代码中,   由于对arg1和arg2使用了取地址符号&amp;并将其传入swap_add中,   使得在调用函数caller的汇编代码中,   arg1和arg2被放在了栈帧中,   对应于汇编代码的3、4行;   </p>
<p>本小结的第二个例子传参数达到了8,   而且对调用函数中传入被调函数的4个参数都使用了取地址符号,   这使得这4个参数都要靠被放入栈中来获取内存地址;   </p>
<p>注意此时调用函数call_proc的返回地址是被放在开辟的栈帧的最里边的,   我也不知道是为啥…</p>
<p><img src="https://s2.loli.net/2022/04/27/dzaTV5yB7i1Q6GE.png" width="400"></img></p>
<h2 id="6-4-寄存器的临时存储"><a href="#6-4-寄存器的临时存储" class="headerlink" title="6.4 寄存器的临时存储"></a>6.4 寄存器的临时存储</h2><p>寄存器被大致地分为两类,   一类是被调用者保存寄存器,   包含%rbx、%rbp和%r12~%r15,   而剩下的除了%rsp以外,   其他的的都是调用者保存寄存器;   对于一个被调函数B而言,   首先需要保存住被调用者保存寄存器,   因为这些寄存器有可能存放着调用该函数B的调用函数A的值,   所以需要把这些值存放在栈上;   其次,   如果说这个函数B需要调用其他的函数C,   而在调用之前已经声明了一些局部变量,   这些局部变量是暂时存放在”调用者保存寄存器”中的,   那么该函数需要自己将这些局部变量存放在栈上,   以便等到函数C返回时,   可以继续使用这些值;   </p>
<h1 id="7-数组"><a href="#7-数组" class="headerlink" title="7. 数组"></a>7. 数组</h1><h2 id="7-1-数组概念"><a href="#7-1-数组概念" class="headerlink" title="7.1 数组概念"></a>7.1 数组概念</h2><p>数组是一个以某个基本数据类型为基础的数据集合,   意思是它可以存放很多很多同类型的数据值;   在内存中,   数组所占的内存是一系列连续的内存空间,   换句话说,   它可以把很多很多同类型的数据值存放在一系列连续的内存空间中,   声明一个数组就好比在内存中划分了一个连续的地盘;<br>那如果说现在我需要寻找到这个地盘里的某一个位置i的值,   首先我需要找到这个地盘的位置,   由于数组是连续的,   我只需要找到这个数组的首地址即可;   然后,   我需要知道这个数组存放的数据类型的大小,   然后我就可以通过数组的首地址,   数据类型的大小以及偏移量去寻找到位置i的值的地址,   具体的公式为<br>$$<br>address_i = 数组首地址+i\cdot 数组的数据大小<br>$$</p>
<h2 id="7-2-嵌套数组"><a href="#7-2-嵌套数组" class="headerlink" title="7.2 嵌套数组"></a>7.2 嵌套数组</h2><p>数组定义    内存模型    寻址表达式</p>
<p>比如定义一个二维数组</p>
<center>int A[5] [3]</center>

<p>可以写作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> row[<span class="number">3</span>];   </span><br><span class="line">row[<span class="number">3</span>] A[<span class="number">5</span>];   </span><br></pre></td></tr></table></figure>

<p>也就是先使得定义row[3]为一个整型的含有3个元素的聚合体,   然后再用这样一个定义去定义数组,   也就是定义一个row[3]的聚合体;   </p>
<p>二维数组采用”行优先”的规则,   在内存中是先存放A[0]的3个元素,   然后再存放A[1]的3个元素,   以此往复;   </p>
<p>寻址表达式为<br>$$<br>&amp; D[i][j] = X_D + L\cdot (C\cdot i + j)<br>$$<br>也就是先算出在哪一列,   再算出在那一列的第几个元素,   乘以数据类型的大小后,   就得到了偏移量,   再加上首地址,   就得到了地址;   </p>
<h2 id="7-3-定长数组"><a href="#7-3-定长数组" class="headerlink" title="7.3 定长数组"></a>7.3 定长数组</h2><p>GCC会对定长数组的计算进行简化,   使得访问数组的次数尽可能的少;   比如对于下列代码,   该代码用于计算矩阵A的第i行与矩阵B的第k列的内积和;   </p>
<p><img src="https://s2.loli.net/2022/05/14/yfGECtuxVYoT9HD.png" width="700"></img></p>
<p>本来每次都需要访问数组的,   但是GCC把代码优化为了下图所示;   该代码拿到数组A第i行的首地址,   数组B第k列的首地址,   以及数组B第k列的终止地址;   每次循环都让A的指针加1,   让B的指针加N即可;   其实也可以拿到A指针的终止地址作为终止条件的判断,   都一样的;   </p>
<p><img src="https://s2.loli.net/2022/05/14/IMEwq5HzDaTlP3J.png" width="700"></img></p>
<h1 id="8-另类数据结构"><a href="#8-另类数据结构" class="headerlink" title="8. 另类数据结构"></a>8. 另类数据结构</h1><h2 id="8-1-结构体"><a href="#8-1-结构体" class="headerlink" title="8.1 结构体"></a>8.1 结构体</h2><p>结构体用于存放各种不同的数据类型的数据,   是面向对象编程中的类的前身;   在汇编层面,   结构体是存放在运行时栈上的,   当需要对结构体进行操作时,   只需要直接从栈上拿值即可;   而由于栈上的值都有对应的地址,   所以编译器可以使用偏移量对值进行操作;   </p>
<p>一个问题:   如果我创建了一个结构体,   并且在某句代码中使用了这个结构体的某个成员,   那编译器是怎么知道这个成员的偏移量的呢?在Linux内核中,   得到偏移量其实很简单,   生成一个指向0的结构体指针,   然后,   使用该指针对某个成员进行取地址即可;   而问题就变成了,   编译器是怎么知道一个结构体成员变量的地址的呢?遍历吗?</p>
<h2 id="8-2-结构体内存对齐"><a href="#8-2-结构体内存对齐" class="headerlink" title="8.2 结构体内存对齐"></a>8.2 结构体内存对齐</h2><p>CPU读取内存并不是一个字节一个字节的去读取的,   而是多字节式的去读取,   那么如果一个整型在内存中是乱放的,   比如放在了结构体的偏移量1到偏移量4的存储单元中,   假设CPU是4字节式的读取,   那么CPU为了获取这个整型,   首先会读取这个结构体偏移量0到偏移量3的字节块,   然后读取偏移量4到偏移量7的字节块,   剔除偏移量为0、5、6和7的字节后,   将偏移量为123的块和4的块结合到一起,   构成整型数字;   而如果说进行内存对齐之后,   由于假设的该整型是在偏移量1到偏移量4的存储单元中,   那就是说偏移量0处应当存放一个char型数据,   而进行了内存对齐之后,   char型数据后面应当填充3字节无效数据,   进而使得该整型数据的偏移量为4,   那么当CPU读取的时候,   先读取0123,   再读取4567,   选择4567即可;   然鹅这还是没有解释上面那个问题;   </p>
<p>结构体的内存对齐原则为任何K字节的对象的地址必须是K的倍数,   涉及到三种的对齐,   第一种对齐规则使得结构体成员的地址为该结构体成员类型大小的倍数,   比如如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">long</span> money2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span> =</span> &#123;<span class="number">17</span>, <span class="string">&quot;Fakeraaaaaaaaaa&quot;</span>, <span class="number">1000</span>, <span class="number">3000</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其在内存中的分布如下:   </p>
<p><img src="https://s2.loli.net/2022/05/28/ZHTG7IgCPYdW6Ff.png" width="400"></img></p>
<p><img src="https://s2.loli.net/2022/05/28/6ZQ2XAgGKqfUMP1.png" width="800"></img></p>
<p>可以看到age变量后面的地址为177004,   不满足8的倍数,   所以进行了填充,   而money后面的地址为177024,   满足8的倍数,   所以没有进行字节填充;   </p>
<p>第二种填充规则保证结构体的指针必须为最大结构体成员大小的倍数,   这样处理,   可以使结构体指针加上对应的偏移量之后仍然满足倍数的要求;   </p>
<p>第三种填充规则是为了保证结构体数组的地址满足倍数关系,   这需要在结构体末尾填充一些字节使得整个结构体满足倍数关系,   让结构体数组的下一个元素的起始地址满足倍数关系;   </p>
<h1 id="9-理解指针"><a href="#9-理解指针" class="headerlink" title="9. 理解指针"></a>9. 理解指针</h1><p>指针所包含的成分和存储单元类似,   指针由类型和存储的值组成,   类型为指向的那个值的类型,   存储的值为指向的那个值的首地址;   </p>
<p>指针通过符号&amp;来创建,   也就是创建一个指针,   然后将一个地址赋给它,   而符号&amp;就是用来对某个对象进行取地址的;   对应汇编的指令为lea,   lea可以把一个有效地址加载进寄存器或内存中,   保存了所指向的那个值的地址;   </p>
<p>通过符号*,   对某个指针进行解引用,   因为指针中保存的是某个值的地址,   所以只需要找到这个地址对应的内存单元即可,   也就是内存引用,   对应于x86中的小括号;   </p>
<p>指针和数组本质上是一类东西;   </p>
<p>将一种指针强制类型转换为另一种指针,   本质上是改变了编译器对该指针的解释方式,   其中一个效果是改变了该指针进行偏移量运算时的伸缩量,   也就是p + L * i 可能本来为p + 1 * i ,   现在变成了p + 4 * i ;   </p>
<h1 id="10-缓冲区溢出"><a href="#10-缓冲区溢出" class="headerlink" title="10. 缓冲区溢出"></a>10. 缓冲区溢出</h1><p>对书中的缓冲区溢出提供的例子进行深度调试，非常有意思，各种环境下的结果都不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">&quot;stdio.h&quot;</span></span><br><span class="line"><span class="keyword">char</span> *myGets(<span class="keyword">char</span> *s) &#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span> *des = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF)</span><br><span class="line">        *des++ = c;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; des == s)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    *des++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    myGets(buf);</span><br><span class="line">    puts(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    echo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子很简单,   声明了一个8字节的字符型数组,   调用myGets去获取字符串,   然后用puts将它输出出来;   就上面这个例子,   将其在windows环境中使用Clion进行运行,   发现不管输入多少个字符,   都可以成功输出;   但是对其进行调试,   myGets在最后添加’\0’的时候,   在myGets里确实是会添加,   但是如果输入字符串长度超过了8,   则一旦回到echo,   buf的最后一个字符就不为’\0’了,   puts就会不断地往下寻找’\0’,   然后很可能会越界,   不过Clion会提示无法访问越界的内存,   而在Linux环境下也会直接报错;   </p>
<p>而书上的意思是配合着get( )函数会出问题,   也就是说,   echo( )函数会通过减去%rsp的值来开辟一个属于自己的栈桢,   然后将%rsp的值赋予%rdi,   相当于把%rsp的值传到get( )中,   然后让get( )进行写操作,   而写操作是利用%rdi作为首指针,   把get( )读取到的字符存储在echo( )的栈帧里,   而一旦读取到的字符长度超过echo( )的栈帧大小,   会产生很严重的后果,   比如只超了一点点,   echo( )栈帧往上一点点就是echo( )的调用者对于echo( )的返回地址,   返回地址被修改,   那ret指令不知道要跳到哪里去;   而如果超的更多,   那就更麻烦了;   </p>
<p>缓冲区溢出攻击的其中一种形式为,   往某一个函数中通过缓冲区写入一个可执行文件,   并把这个函数的返回地址修改为那个可执行文件的首地址,   这样,   该函数返回时,   就会直接执行那个可执行文件,   黑客搞完事情后,   对被破坏的栈进行修复,   再次执行那个函数,   就不会被发现了;   </p>
<h1 id="11-抵御缓冲区溢出攻击"><a href="#11-抵御缓冲区溢出攻击" class="headerlink" title="11. 抵御缓冲区溢出攻击"></a>11. 抵御缓冲区溢出攻击</h1><h2 id="11-1-栈随机化"><a href="#11-1-栈随机化" class="headerlink" title="11.1 栈随机化"></a>11.1 栈随机化</h2><p>黑客要进行缓冲区溢出攻击,   就需要让被黑的电脑执行黑客提供的可执行文件,   而方法为让一个函数的返回地址直接跳到那个可执行文件的首地址;   因此,   知晓可执行文件的首地址就尤为重要,   而以前的栈地址是固定的,   很容易预测,   所以增添了栈随机化,   通过alloc在栈上随机分配一些无用字节进行填充,   使其随机化;   </p>
<h1 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h1><p>上述的汇编代码是用编译器在x86上对C语言进行编译而得到的,   也就是说,   把这些汇编代码拿到其他的机器上运行,   是会出问题的;   而Java语言在一开始就希望创建一个统一的规则,   使得Java可以在任意的机器上运行,   也就是Java的跨平台性,   所以Java才有了自己的虚拟机,   所有东西在虚拟机上运行,   很好地实现跨平台功能;   </p>
<p>第三章总算是告一段落了,   </p>
<h1 id="N-不认识的单词"><a href="#N-不认识的单词" class="headerlink" title="N. 不认识的单词"></a>N. 不认识的单词</h1><p>convention    [kənˈvenʃn]    <strong>规则</strong></p>
<p>annotation     [ænəˈteɪʃ(ə)n]    注释</p>
<p>denote 表示</p>
<p>ambiguity    [æmbɪˈɡjuːɪti]    歧义</p>
<p>scale    [skeɪl] 比例</p>
<p>notation    标记法,   表示法</p>
<p>arbitrary 任意的</p>
<p>reference    引用</p>
<p>syntax    [ˈsɪntæks]    语法</p>
<p>‘ indicated 指定的</p>
<p>perform    执行</p>
<p>respectively    分别地</p>
<p>illustrate    [ˈɪləstreɪt]    说明,   阐释</p>
<p>sign-extending    位扩展</p>
<p>specific    专门</p>
<p>property    特性</p>
<p>designate    [ˈdezɪɡneɪt]    指定</p>
<p>syntax    语法</p>
<p>con’tingent on    [kənˈtɪndʒənt]    取决于</p>
<p>attribute    属性</p>
<p>rendition    n.表示,   呈现</p>
<p>demonstrate    v.演示</p>
<p>robust    [roʊˈbʌst]    a.健壮的</p>
<p>mimic    vt.模仿</p>
<p>overlap    v. 把…叠在一起</p>
<p>successive    a. 连续的</p>
<p>sophisticated    [səˈfɪstɪkeɪtɪd]    a.复杂的</p>
<p>reliably    ad.可靠地</p>
<p>discard    扔掉,   放弃</p>
<p>incur    招致,   引发</p>
<p>penalty    [ˈpenəlti]    处罚</p>
<p>degradation    [ˌdeɡrəˈdeɪʃn]    下降,   退化</p>
<p>counterpart    对应物</p>
<p>progression    [prəˈɡreʃn]    进程,   发展</p>
<p>factorial    [fækˈtɔːriəl]    阶乘</p>
<p>invocation [ˌɪnvəˈkeɪʃn] 调用</p>
<h1 id="N-1-翻译"><a href="#N-1-翻译" class="headerlink" title="N + 1. 翻译"></a>N + 1. 翻译</h1><h2 id="3-7-1-The-Run-Time-Stack"><a href="#3-7-1-The-Run-Time-Stack" class="headerlink" title="3.7.1 The Run-Time Stack"></a>3.7.1 The Run-Time Stack</h2><p>运行时栈</p>
<p>(1) When procedure P calls procedure Q , it will push the return address onto the stack, indicating where within P the program should resume execution once Q returns.</p>
<p>当过程P调用过程Q时,   它会将(Q的返回地址)压到栈上,   指示一旦Q返回,   过程P应当在哪里恢复执行.</p>
<p>(2) We consider the return address to be part of P ‘s stack frame, since it holds state relevant to P. The code for Q allocates the space required for its stack frame by extending the current stack boundary. Within that space, it can save the values of registers, allocate space for local variables, and set up arguments for the procedures it calls. The stack frames for most procedures are of fixed size, allocated at the beginning of the procedure.Some procedures, however, require variable-size frames. This issue is discussed in Section 3.10.5. </p>
<p>我们把(Q的)返回地址当作P栈帧的一部分,   因为它持有着与P相关的状态;   Q的代码可以通过扩展当前栈的边界来为它的栈帧分配空间;   在该空间内,   它可以保存寄存器的值,   为局部变量分配空间,   以及为它所要调用的过程设置参数;   对于大多数过程而言,   栈帧的大小都是固定的,   在过程一开始就已经分配好了;   而有一些过程则需要大小可变的栈帧;   我们会在3.10.5讨论这个话题;   </p>
<p>(3) Procedure P can pass up to six integral values (i.e., pointers and integers) on the stack, but if Q requires more arguments, these can be stored by P within its stack frame prior to the call.</p>
<p>过程P可以为Q在栈上放置6个整型值,   但是如果Q需要更多的参数,   这些参数可以由P在调用之前存放在它的栈帧中;   </p>
<p>(4) In the interest of space and time efficiency, x86-64 procedures allocate only the portions of stack frames they require. For example, many procedures have six or fewer arguments, and so all of their parameters can be passed in registers. Thus, parts of the stack frame diagrammed in Figure 3.25 may be omitted. Indeed, many functions do not even require as tack frame. This occurs when all of the local variables can be held in registers and the function does not call any other functions (sometimes referred to as a leaf procedure, in reference to the tree structure of procedure calls). For example, none of the functions we have examined thus far required stack frames.</p>
<p>出于对时间和空间效率的考虑,   x86的过程只分配它们需要的那一部分栈帧;   例如,   由于许多的过程所需的参数都少于6个,   导致这些参数完全可以用寄存器来传递,   所以这些过程的栈帧可以被省略;   事实也确实如此,   许多过程都不需要栈帧,   尤其是当使用寄存器就可以存放所有局部变量,   并且该过程不会调用任何其他过程的时候(当主调用过程被看作树结构时,   该过程被称为叶子过程);   比如,   我们所涉及到的所有过程都不需要栈帧;   </p>
<h2 id="3-7-2-Control-Transfer"><a href="#3-7-2-Control-Transfer" class="headerlink" title="3.7.2 Control Transfer"></a>3.7.2 Control Transfer</h2><p>(1) Passing control from function P to function Q involves simply setting the program counter (PC) to the starting address of the code for Q. However, when it later comes time for Q to return, the processor must have some record of the code location where it should resume the execution of P. This information is recorded in x86-64 machines by invoking procedure Q with the instruction call Q. This instruction pushes an address A onto the stack and sets the PC to the beginning of Q. The pushed address A is referred to as the return address and is computed as the address of the instruction immediately following the call instruction. The counterpart instruction ret pops an address A off the stack and sets the PC to A.</p>
<p>将控制权由过程P传递给过程Q只需简单地把程序计数器PC设置为Q的代码块的首地址即可;   然而,   当Q返回时,   处理器必须拥有一些P应当从哪个位置恢复执行的记录;   在x86中,   该信息是通过指令”call Q”来记录的;   该指令把A地址压入栈中,   并设置PC为Q的起始地址;   被压入的A地址为返回地址,   也是紧跟在call指令后面的那一条指令地址;   call后面的语句ret(过程P的返回语句)负责把地址A从栈中弹出并且把PC设置为A;   </p>
<p>(2) (These instructions are referred to as callq and retq in the disassembly outputs generated by the program OBJDUMP . The added suffix ` q ‘ simply emphasizes that these are x86-64 versions of call and return instructions, not IA32. In x86-64 assembly code, both versions can be used interchangeably.)</p>
<p>这些指令(指call和ret)以callq和retq的形式被反汇编程序生成出来;   附加的后缀q表明这是x86-64版本的调用和反汇指令,   而不是IA32;   在x86汇编中,   这两个版本的指令(指两个call指令)没什么区别;   </p>
<p>(3) The call instruction has a target indicating the address of the instruction where the called procedure starts. Like jumps, a call can be either direct or indirect. In assembly code, the target of a direct call is given as a label, while the target of an indirect call is given by `*’ followed by an operand specifier using one of the formats described in Figure 3.3 .</p>
<p>call指令的一个目的为标明被调用的过程开始的位置;   和跳跃指令类似,   call语句可以是直接和非直接的;   在汇编指令中,   直接型call指令的目标是一个标签(类似于jmp),   而非直接型call指令的目标由后跟一个操作数的’*’符号给出,   其格式如图3.3所示;   </p>
<p>(4) Figure 3.26 illustrates the execution of the call and ret instructions for the multstore and main functions introduced in Section 3.2.2 . The following are excerpts of the disassembled code for the two functions:</p>
<p>图3.26展示了3.2.2里介绍的multstore和主函数之间的调用和返回指令;   下面的代码节选自这两个函数的反汇编代码:   </p>
<p>(5) In this code, we can see that the call instruction with address 0x400563 in main calls function multstore . This status is shown in Figure 3.26(a) , with the indicated values for the stack pointer %rsp and the program counter %rip . The effect of the call is to push the return address 0x400568 onto the stack and to jump to the first instruction in function multstore , at address 0x0400540 (3.26(b)). The execution of function multstore continues until it hits the ret instruction at address 0x40054d . This instruction pops the value 0x400568 from the stack and jumps to this address, resuming the execution of main just after the call instruction (3.26(c)).</p>
<p>在该代码内,   可以观察到,   主函数中地址为0x400563的call指令调用multstore函数;   如图3.26(a)所示,   其中包括%rsp所指向的值以及%rip所指向的值;   call指令把返回地址0x400568压到了栈上,   并且(让%rip)跳到函数multstore的第一条指令上,   函数multstore一直执行到碰上地址为0x40054d 的ret指令为止;   该指令把0x400568(%主函数中call指令的下一条指令)从栈中弹出,   然后以它为地址,   跳到它对应的语句处,   使其可以在call指令执行完毕后立刻执行call后面的指令;   </p>
<p>(6) As a more detailed example of passing control to and from procedures, Figure 3.27(a) shows the disassembled code for two functions, top and leaf , as well as the portion of code in function main where top gets called. Each instruction is identified by labels L1–L2 (in leaf ), T1–T4 (in top), and M1–M2 in main. Part (b) of the figure shows a detailed trace of the code execution, in which main calls top(100) , causing top to call leaf(95) . Function leaf returns 97 to top , which Using the stack to store return addresses makes it possible to return to the right point in the procedures.</p>
<p>图3.27展示了控制转换更为详细的汇编代码,   其中包含函数leaf和函数top,   以及调用函数top的函数main的部分代码;   每条指令都由标签L1–L2, T1–T4, 和M1–M2所标记;   该图的b部分展示了代码执行的详细路径,   其中main调用top,   并传入参数100,   这会使得top调用leaf,   并传入参数95;   leaf向top返回97,   返回的过程使用了栈中存储的返回地址,   使得rip可以回到函数top的正确返回位置;   </p>
<p>(7) then returns 194 to main . The first three columns describe the instruction being executed, including the instruction label, the address, and the instruction type. The next four columns show the state of the program before the instruction is executed, including the contents of registers %rdi, %rax , and %rsp , as well as the value at the top of the stack. The contents of this table should be studied carefully, as they demonstrate the important role of the run-time stack in managing the storage needed to support procedure calls and returns.</p>
<p>然后函数top返回194给main;   图3.27的b部分的前3列展示了被执行指令的指令标签,   地址以及指令提示符;   接下来的4列展示了在该行程序执行之前,   %rdi,   %rdx,   %rsp以及运行时栈栈顶的值;   大家应该谨慎地学习这部分内容,   因为它们展示了运行时栈在管理调用指令和返回指令所使用的存储空间方面的重要性;   </p>
<p>(8) Instruction L1 of leaf sets %rax to 97, the value to be returned. Instruction L2 then returns. It pops 0x400054e from the stack. In setting the PC to this popped value, control transfers back to instruction T3 of top . The program has successfully completed the call to leaf and returned to top .</p>
<p>leaf的L1指令设置97为%rax的值,   L2指令将其作为返回值返回;   它从栈中弹出0x400054e;   当PC指向弹出的值时,   控制权交回给函数top的指令T3;   至此,   程序成功地完成了调用leaf并返回到了函数top;   </p>
<p>(9) Instruction T3 sets %rax to 194, the value to be returned from top .Instruction T4 then returns. It pops 0x4000560 from the stack, thereby setting the PC to instruction M2 of main . The program has successfully completed the call to top and returned to main . We see that the stack pointer has also been restored to 0x7fffffffe820 , the value it had before the call to top .<br>We can see that this simple mechanism of pushing the return address onto the stack makes it possible for the function to later return to the proper point in the program. The standard call/return mechanism of C (and of most programming languages) conveniently matches the last-in, first-out memory management discipline provided by a stack.</p>
<p>函数top的指令T3设置%rax的值为194,   指令T4将其作为函数top的返回值返回;   指令T4(ret)将0x4000560从栈上弹出,   从而让PC指向函数main的指令M2;   至此程序完成了对函数top的调用并返回到main;   可以发现,   栈顶指针%rsp再次指向了地址0x7fffffffe820,   这个值是函数main在调用函数top之前%rsp的值;   通过上述分析,   把返回地址压入栈中的这一举措使得被调用函数在执行完毕之后能够让PC指向正确的位置,   也就是它该返回的位置;   C语言(以及大部分编程语言)的标准调用和返回指令完美契合于栈的先进后出的存储空间管理特性;   </p>
<h2 id="3-7-3-Data-Transfer"><a href="#3-7-3-Data-Transfer" class="headerlink" title="3.7.3 Data Transfer"></a>3.7.3 Data Transfer</h2><p>(1) In addition to passing control to a procedure when called, and then back again when the procedure returns, procedure calls may involve passing data as arguments, and returning from a procedure may also involve returning a value. With x86-64, most of these data passing to and from procedures take place via registers. For example, we have already seen numerous examples of functions where arguments are passed in registers %rdi, %rsi , and others, and where values are returned in register %rax . When procedure P calls procedure Q , the code for P must first copy the arguments into the proper registers. Similarly, when Q returns back to P , the code for P can access the returned value in register %rax . In this section, we explore these conventions in greater detail.</p>
<p>函数调用时除了把控制权传递给被调函数,   以及它返回时收回控制权这些事儿以外,   调用函数还可能会把数据传递给被调函数,   也就是传递形参,   也可能会在返回时返回一个返回值;   在x86-64中,   这些在函数调用之间的数据传输工作由寄存器来承担;   例如,   我们已经见识过了很多例子函数,   它们用%rdi,   %rsi以及其他的一些寄存器来进行参数传递,   并使用%rdx来返回返回值;   当函数P调用函数Q时,   P的代码必须把要传递的值复制到相应的寄存器中;   类似地,   当Q返回到P时,   P的代码可以通过%rdx获取返回值;   这一节中我们中深入探讨这些规则;   </p>
<p>(2) With x86-64, up to six integral (i.e., integer and pointer) arguments can be passed via registers. The registers are used in a specified order, with the name used for a register depending on the size of the data type being passed. These are shown in Figure 3.28 . Arguments are allocated to these registers according to their ordering in the argument list. Arguments smaller than 64 bits can be accessed using the appropriate subsection of the 64-bit register. For example, if the first argument is 32 bits, it can be accessed as %edi .</p>
<p>在x86中,   最多可以通过寄存器传递6个整型或指针参数;   寄存器的使用顺序取决于要传递的数据类型的大小,   如图3.28所示;   被分配到这些寄存器中的参数取决于它们在参数列表中的顺序;   </p>
<p>(3) When a function has more than six integral arguments, the other ones are passed on the stack. Assume that procedure P calls procedure Q with n integral arguments, such that n &gt; 6. Then the code for P must allocate a stack frame with enough storage for arguments 7 through n, as illustrated in Figure 3.25 . It copies arguments 1–6 into the appropriate registers, and it puts arguments 7 through n onto the stack, with argument 7 at the top of the stack. When passing parameters on the stack, all data sizes are rounded up to be multiples of eight. With the arguments in place, the program can then execute a call instruction to transfer control to procedure Q . Procedure Q can access its arguments via registers and possibly from the stack. If Q , in turn, calls some function that has more than six arguments, it can allocate space within its stack frame for these, as is illustrated by the area labeled “Argument build area” in Figure 3.25 .</p>
<p>当一个函数要传递的参数数目大于6时,   超过6的那些参数会被传到栈上;   假设函数P调用函数Q时传递的参数n &gt; 6;   P的代码必须为7到n的参数分配足够栈帧,   如图3.25所示;   在该图中,   它把参数1<del>6都分配到了对应的寄存器中,   然后把7</del>n的参数放在了栈上,   第7个参数在栈顶;   当使用栈去传递参数时,   所有的数据大小都被舍入为8的倍数;   当这些参数就位时,   程序就可以去执行call指令,   然后把控制权传递给被调函数Q;   被调函数Q可以通过寄存器和运行时栈获取参数;   而当被调函数Q也需要调用其他的一些函数并传递的参数也为6个以上时,   Q也可以申请栈帧,   如图3.25中被标记为”参数构建区域”的地方;   </p>
<p>(4) As an example of argument passing, consider the C function proc shown in Figure 3.29(a) . This function has eight arguments, including integers with different numbers of bytes (8, 4, 2, and 1), as well as different types of pointers, each of which is 8 bytes. The assembly code generated for proc is shown in Figure 3.29(b) .<br>The first six arguments are passed in registers. The last two are passed on the stack, as documented by the diagram of Figure 3.30 . This diagram shows the state of the stack during the execution of proc . We can see that the return address was pushed onto the stack as part of the procedure call. The two arguments, therefore, are at positions 8 and 16 relative to the stack pointer. Within the code, we can see that different versions of the ADD instruction are used according to the sizes of the operands: addq for a1 (long), addl for a2 (int), addw for a3 (short) , and addb for a4 (char). Observe that the movl instruction of line 6 reads 4 bytes from memory; the following addb instruction only makes use of the low-order byte.</p>
<p>考虑图3.29(a)所示的参数传递的例子函数proc;   该函数有8个参数,   包括不同大小的数据类型,   以及不同类型的8字节指针;   它的汇编代码如图3.29(b)所示;   </p>
<p>前6个参数由寄存器传递,   后面两个被传递到了栈上,   如表3.30所示,   该表展示了运行函数proc时运行时栈的状态;   可以观察到,   返回地址被扔到栈上的操作被当作call的一部分;   因此,   那两个参数分别处于距离栈顶指针8和16bit的位置;   从代码中可以观察到由于操作数不同而使用的不同版本的add指令:   q-long,   l-int,   w-short,   b-char;   也可以观察到第6行的movl指令从内存中读取了4字节的数据,   紧跟的那个addb指利用了(%rax的)低位的1字节;   </p>
<h2 id="3-7-4-Local-Storage-on-the-stack"><a href="#3-7-4-Local-Storage-on-the-stack" class="headerlink" title="3.7.4 Local Storage on the stack"></a>3.7.4 Local Storage on the stack</h2><p>(1) Most of the procedure examples we have seen so far did not require any local storage beyond what could be held in registers. At times, however, local data must be stored in memory. Common cases of this include these: </p>
<ul>
<li>There are not enough registers to hold all of the local data.</li>
<li>The address operator ‘ &amp; ‘ is applied to a local variable, and hence we must be able to generate an address for it.</li>
<li>Some of the local variables are arrays or structures and hence must be accessed by array or structure references. We will discuss this possibility when we describe how arrays and structures are allocated.</li>
</ul>
<p>我们已经见过的大多数示例函数所需要的局部存储不会超过寄存器的承受范围;   然鹅有时局部变量需要存储在内存中;   比如以下这些例子:   </p>
<ul>
<li>没有足够的寄存器去存储局部数据;   </li>
<li>如果地址操作符&amp;应用于了一个局部变量,   那么就必须给这个局部变量分配一个地址;   </li>
<li>一些局部变量是数组或结构体,   访问它们是需要数组引用或结构体引用的;   我们会讨论数组和结构体分配时讨论这个例子;   </li>
</ul>
<p>(2) Typically, a procedure allocates space on the stack frame by decrementing the stack pointer. This results in the portion of the stack frame labeled “Local variables” in Figure 3.25 .<br>As an example of the handling of the address operator, consider the two functions shown in Figure 3.31(a) . The function swap_add swaps the two values designated by pointers xp and yp and also returns the sum of the two values. The function caller creates pointers to local variables arg1 and arg2 and passes these to swap_add . Figure 3.31(b) shows how caller uses a stack frame to implement these local variables. The code for caller starts by decrementing the stack pointer by 16; this effectively allocates 16 bytes on the stack. Letting S denote the value of the stack pointer, we can see that the code computes &amp;arg2 as S + 8 (line 5), &amp;arg1 as S (line 6). We can therefore infer that local variables arg1 and arg2 are stored within the stack frame at offsets 0 and 8 relative to the stack pointer. When the call to swap_add completes, the code for caller then retrieves the two values from the stack (lines 8–9), computes their difference, and multiplies this by the value returned by swap_add in register %rax (line 10). Finally, the function deallocates its stack frame by incrementing the stack pointer by 16 (line 11.) We can see with this example that the run-time stack provides a simple mechanism for allocating local storage when it is required and deallocating it when the function completes.</p>
<p>通常,   函数通过减小%rsp的地址的方式在栈帧上分配空间,   这导致了栈帧里边有一部分被标记为局部变量,   如图3.25所示;<br>考虑图3.31(a)所示的两个用于处理地址操作符函数;   函数swap_add交换两个由指针xp和yp所指向的值,   并返回两个值的和;   函数caller为局部变量arg1和arg2创建了指针并将它们传入swap_add;   图3.31(b)展示了函数caller是怎样使用栈帧去实现这些局部变量的存储的;   函数caller首先把%rsp减小16,   以此来获得16字节的空间;   设S为%rsp内存储的地址,   可以发现代码在第5行计算了S + 8,   也就是arg2的地址—&amp;arg2,   并且计算了S,   也就是arg1的地址;   因此可以猜测局部变量arg1和arg2在栈帧中分别被存放在了离%rsp距离0和8的位置;   当对函数swap_add的调用完成之后,   函数caller再次从栈上拿取到这两个值,   相减之后乘以swap_add的返回值,   这个返回值(说了很多遍了)是被存放在%rax中的;   最后该函数把栈顶指针的值变大16(以此来将函数caller使用的栈帧进行逻辑清除;   从这个例子中可以看到运行时栈为分配和释放所需要的临时存储空间提供了一种非常简单的管理机制;   </p>
<p>(3) As a more complex example, the function call_proc , shown in Figure 3.32 , illustrates many aspects of the x86-64 stack discipline. Despite the length of this example, it is worth studying carefully. It shows a function that must allocate storage on the stack for local variables, as well as to pass values to the 8-argument function proc (Figure 3.29 ). The function creates a stack frame, diagrammed in Figure 3.33 .<br>Looking at the assembly code for call_proc (Figure 3.32(b) ), we can see that a large portion of the code (lines 2–15) involves preparing to call function proc . This includes setting up the stack frame for the local variables and function parameters, and for loading function arguments into registers. As Figure 3.33 shows, local variables x1–x4 are allocated on the stack and have different sizes. Expressing their locations as offsets relative to the stack pointer, they occupy bytes 24–31 ( x1 ), 20–23 ( x2 ), 18–19 ( x3 ), and 17 ( s3 ). Pointers to these locations are generated by leaq instructions (lines 7, 10, 12, and 14). Arguments 7 (with value 4) and 8 (a pointer to the location of x4 ) are stored on the stack at offsets 0 and 8 relative to the stack pointer.</p>
<p>图3.32展示的函数call_proc是一个更为复杂的例子,   它展示了x86-64的运行时栈的很多特性;   尽管这个例子很长,   但它仍然值得细细学习;   该函数必须为局部变量分配栈帧里的空间,   同时也需要向函数proc传递8个参数;   该函数创建的栈帧如图3.33;<br>观察3.32(b)的汇编代码可以发现,   这段代码的很大一部分都在为即将调用proc做准备,   包括为局部变量和传递的参数设置栈帧,   以及把传递的参数扔进寄存器中;   如图3.33所示,   不同大小的局部变量x1-x4被扔到了栈上;   这些变量如果用距离%rsp的偏移量来表示的话,   它们会分别占据24-31字节(x1),   20–23字节( x2 ), 18–19字节( x3 ), 和 17字节( s3 );   指向这些位置的指针由leaq指令生成;   第7和第8个参数分别存放在距离%rsp 0和8位置的地方;   </p>
<p>(4) When procedure proc is called, the program will begin executing the code shown in Figure 3.29(b) . As shown in Figure 3.30 , arguments 7 and 8 are now at offsets 8 and 16 relative to the stack pointer, because the return address was pushed onto the stack.<br>When the program returns to call_proc , the code retrieves the values of the four local variables (lines 17–20) and performs the final computations. It finishes by incrementing the stack pointer by 32 to deallocate the stack frame.</p>
<p>如图3.30所示,   第7和第8个参数相对于%rsp的偏移量为8和16,   因为返回地址也被放在了栈上;   当程序返回到函数call_proc时,   该函数将第17和20行的值拽回,   并完成最终的计算;   最后,   它让%rsp指向的地址值加32,   来回收栈帧;   </p>
<h2 id="3-7-5-Local-Storage-in-Registers"><a href="#3-7-5-Local-Storage-in-Registers" class="headerlink" title="3.7.5 Local Storage in Registers"></a>3.7.5 Local Storage in Registers</h2><p>(1) The set of program registers acts as a single resource shared by all of the procedures. Although only one procedure can be active at a given time, we must make sure that when one procedure (the caller) calls another (the callee), the callee does not overwrite some register value that the caller planned to use later. For this reason, x86-64 adopts a uniform set of conventions for register usage that must be respected by all procedures, including those in program libraries.<br>By convention, registers %rbx, %rbp , and %r12–%r15 are classified as callee-saved registers. When procedure P calls procedure Q , Q must preserve the values of these registers, ensuring that they have the same values when Q returns to P as they did when Q was called. Procedure Q can preserve a register value by either not changing it at all or by pushing the original value on the stack, altering it, and then popping the old value from the stack before returning. The pushing of register values has the effect of creating the portion of the stack frame labeled “Saved registers” in Figure 3.25 . With this convention, the code for P can safely store a value in a callee-saved register (after saving the previous value on the stack, of course), call Q , and then use the value in the register without risk of it having been corrupted.</p>
<p>程序使用寄存器,   (在一些规则的帮助下)看上去就好像每一个函数都单独地有一套自己的寄存器一样;   尽管在给定的时间点只会有一个函数在执行,   我们也需要确保被调用函数不会覆盖重写调用函数稍后会用到的寄存器;   基于这个原因,   x86采用了一套统一的寄存器使用规则,   包括程序库函数在内地所有函数都必须遵循这套规则;<br>这套规则将%rbx、%rbp和%r12~%r15设置为被调用函数保存寄存器;   当函数P调用函数Q时,   Q必须维持这些寄存器的值,   使得在返回到函数P时这些寄存器中的值仍然是调用之前的值,   所以要么是先把值放到栈帧上暂时存储,   返回时再把值原样赋给,   要么就不碰那个寄存器;   把寄存器的值扔到栈帧上的操作会创建图3.25中所示的栈帧中被称为”保存寄存器”的一块区域;   在这种规则的加持下,   函数P可以无忧无虑地使用上述的寄存器去存储需要存储的值,   在调用完Q之后仍然可以不必考虑冲突的风险,   安全地使用寄存器的值;   </p>
<p>(2) All other registers, except for the stack pointer %rsp , are classified as caller-saved registers. This means that they can be modified by any function. The name “caller saved” can be understood in the context of a procedure P having some local data in such a register and calling procedure Q . Since Q is free to alter this register, it is incumbent upon P (the caller) to first save the data before it makes the call.<br>As an example, consider the function P shown in Figure 3.34(a) . It calls Q twice. During the first call, it must retain the value of x for use later. Similarly, during the second call, it must retain the value computed for Q ( y ). In Figure 3.34(b), we can see that the code generated by GCC uses two callee-saved registers: %rbp to hold x , and %rbx to hold the computed value of Q ( y ).<br>At the beginning of the function, it saves the values of these two registers on the stack (lines 2–3). It copies argument x to %rbp before the first call to Q (line 5). It copies the result of this call to %rbx before the second call to Q (line 8). At the end of the function (lines 13–14), it restores the values of the two callee-saved registers by popping them off the stack.<br>Note how they are popped in the reverse order from how they were pushed, to account for the last-in, first-out discipline of a stack.</p>
<p>除了%rsp和上述寄存器之外的其他寄存器都被归为”调用函数保存寄存器”一类;   这意味着它们可以被任何函数调用;   “调用者保存”指的是,   函数P在这些寄存器中保存着值,   然后去调用函数Q;   因为Q可以随意地选择寄存器,   所以P有义务在调用之前先存储那些寄存器中的数据;<br>函数P的例子如图3.34(a),   它调用了Q两次;   第一次调用的时候,   它必须保持住x的值以便待会儿使用;   同样的,   第二次调用的时候,   它必须保持住Q(y)的计算结果;   在图3.34(b)中,   可以看到,   GCC生成的汇编代码使用了两个”被调用者保存”寄存器,   其中%rbp用来保存x,   %rbx用来保存Q(y)的计算结果;   在函数的开头,   代码使用pushq语句把%rbp和%rbx的值保存在了栈上;   在调用Q(y)之前先使用%rbp保存了x的值,   而在调用Q(x)之前也使用了%rbx保存了Q(y)的计算结果;   在函数的末尾,   它重新从栈上拿到”被调用者保存”寄存器在函数开始时的值,   并将其存进了对应寄存器中;   注意它们是以与压入顺序相反的顺序进行弹出的,   与栈的先进后出的规则相对应;   </p>
<h2 id="3-7-6-Recursive-Procedures"><a href="#3-7-6-Recursive-Procedures" class="headerlink" title="3.7.6 Recursive Procedures"></a>3.7.6 Recursive Procedures</h2><p>(3) The conventions we have described for using the registers and the stack allow x86-64 procedures to call themselves recursively. Each procedure call has its own private space on the stack, and so the local variables of the multiple outstanding calls do not interfere with one another.<br>Furthermore, the stack discipline naturally provides the proper policy for allocating local storage when the procedure is called and deallocating it before returning.<br>Figure 3.35 shows both the C code and the generated assembly code for a recursive factorial function. We can see that the assembly code uses register %rbx to hold the parameter n , after first saving the existing value on the stack (line 2) and later restoring the value before returning (line 11). Due to the stack discipline, and the register-saving conventions, we can be assured that when the recursive call to rfact(n-1) returns (line 9) that (1) the result of the call will be held in register %rax , and (2) the value of argument n will held in register %rbx .<br>Multiplying these two values then computes the desired result.<br>We can see from this example that calling a function recursively proceeds just like any other function call. Our stack discipline provides a mechanism where each invocation of a function has its own private storage for state information (saved values of the return location and callee-saved registers). If need be, it can also provide storage for local variables. The stack discipline of allocation and deallocation naturally matches the call-return ordering of functions. This method of implementing function calls and returns even works for more complex patterns, including mutual recursion (e.g., when procedure P calls Q , which in turn calls P ).</p>
<p>我们刚才所描述的使用寄存器和栈的规则允许x86函数进行递归调用;   每个函数在栈上都有自己特定的存储区域,   因此多个未完成调用的局部变量不会相互干扰;<br>进一步说,   栈规则天然地提供了一种合适的规则,   这种规则包含当函数被调用时进行的本地存储分配,   以及函数返回时的内存释放;<br>图3.35展示了递归方式实现的阶乘函数的C程序和汇编程序;   可以看到,   在第2行保存了%rbx的值之后,   在第11行将原先的值再次赋给%rbx之前,   汇编代码使用了%rbx去存储参数n;   由于我们的栈规则和寄存器使用规则,   我们可以确定,   当第9行的call语句返回时,   返回值被存放在了%rax中,   并且,   该函数的参数n的值被保存在了%rbx中;   将这两个值相乘便得到了想要的结果;<br>从这个例子中我们可以看见,   调用一个递归函数就好像调用一个其他的函数一样;   栈规则提供了一套机制,   该机制保证了函数的每一次调用的函数都拥有他自己特定的用于存储状态信息的区域;   如果有需要,   它也可以存储局部变量;   </p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/12/pai-dui-lun/pai-dui-lun-shi-zhan-di-1-zhang/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">排队论实战第1章</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/19/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-018-dong-tai-gui-hua-1/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法体系结构018_动态规划1</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81"><span class="toc-text">1. 程序编码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-text">2. 数据格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE"><span class="toc-text">3. 访问数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8%E6%8C%87%E4%BB%A4mov"><span class="toc-text">3.2数据移动指令mov</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%8E%8B%E6%A0%88%E5%92%8C%E5%BC%B9%E6%A0%88"><span class="toc-text">3.3 压栈和弹栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-text">3.4 算术和逻辑运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%8E%A7%E5%88%B6"><span class="toc-text">4. 控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%9D%A1%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="toc-text">4.1 条件代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="toc-text">4.2 使用条件代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%B7%B3%E8%B7%83%E6%8C%87%E4%BB%A4"><span class="toc-text">4.3 跳跃指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E8%B7%B3%E8%B7%83%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81"><span class="toc-text">4.4 跳跃指令编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF1"><span class="toc-text">4.5 实现条件分支1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF2"><span class="toc-text">4.6 实现条件分支2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%BE%AA%E7%8E%AF"><span class="toc-text">5. 循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%BF%87%E7%A8%8B"><span class="toc-text">6. 过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88"><span class="toc-text">6.1 运行时栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%8E%A7%E5%88%B6%E6%9D%83%E8%BD%AC%E6%8D%A2"><span class="toc-text">6.2 控制权转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-text">6.2 数据传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%A0%88%E7%9A%84%E4%B8%B4%E6%97%B6%E5%AD%98%E5%82%A8"><span class="toc-text">6.3 栈的临时存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%B8%B4%E6%97%B6%E5%AD%98%E5%82%A8"><span class="toc-text">6.4 寄存器的临时存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84"><span class="toc-text">7. 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%95%B0%E7%BB%84%E6%A6%82%E5%BF%B5"><span class="toc-text">7.1 数组概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84"><span class="toc-text">7.2 嵌套数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-text">7.3 定长数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%8F%A6%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">8. 另类数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">8.1 结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-text">8.2 结构体内存对齐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88"><span class="toc-text">9. 理解指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-text">10. 缓冲区溢出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%8A%B5%E5%BE%A1%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB"><span class="toc-text">11. 抵御缓冲区溢出攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E6%A0%88%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="toc-text">11.1 栈随机化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E6%80%BB%E7%BB%93"><span class="toc-text">12. 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#N-%E4%B8%8D%E8%AE%A4%E8%AF%86%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-text">N. 不认识的单词</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#N-1-%E7%BF%BB%E8%AF%91"><span class="toc-text">N + 1. 翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-1-The-Run-Time-Stack"><span class="toc-text">3.7.1 The Run-Time Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-2-Control-Transfer"><span class="toc-text">3.7.2 Control Transfer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-3-Data-Transfer"><span class="toc-text">3.7.3 Data Transfer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-4-Local-Storage-on-the-stack"><span class="toc-text">3.7.4 Local Storage on the stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-5-Local-Storage-in-Registers"><span class="toc-text">3.7.5 Local Storage in Registers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-6-Recursive-Procedures"><span class="toc-text">3.7.6 Recursive Procedures</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>