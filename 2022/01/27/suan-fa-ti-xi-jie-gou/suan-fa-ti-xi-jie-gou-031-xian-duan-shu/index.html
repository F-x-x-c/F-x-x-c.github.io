<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法体系结构031_线段树 | Aegis</title><meta name="author" content="Deng"><meta name="copyright" content="Deng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 线段树提出一种数据结构,   负责对连续数据进行批处理,   比如修改某个数组的一个连续区域的数据,   对某个数组的一个连续区域进行求和,   也就是写数据和读数据;   设要上述操作的连续区域的数据量为N,   如果用普通的数组处理的话,   时间复杂度为O(N),   但是线段树能够将这些操作变为O(logN);    结构类似于堆,   线段树可以用数组来实现;   对于一个数">
<meta property="og:type" content="article">
<meta property="og:title" content="算法体系结构031_线段树">
<meta property="og:url" content="http://example.com/2022/01/27/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-031-xian-duan-shu/index.html">
<meta property="og:site_name" content="Aegis">
<meta property="og:description" content="[TOC] 线段树提出一种数据结构,   负责对连续数据进行批处理,   比如修改某个数组的一个连续区域的数据,   对某个数组的一个连续区域进行求和,   也就是写数据和读数据;   设要上述操作的连续区域的数据量为N,   如果用普通的数组处理的话,   时间复杂度为O(N),   但是线段树能够将这些操作变为O(logN);    结构类似于堆,   线段树可以用数组来实现;   对于一个数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RWLNb9?ver=6f2d">
<meta property="article:published_time" content="2022-01-27T07:10:44.000Z">
<meta property="article:modified_time" content="2023-03-07T08:47:49.490Z">
<meta property="article:author" content="Deng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RWLNb9?ver=6f2d"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/01/27/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-031-xian-duan-shu/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法体系结构031_线段树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-07 16:47:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Aegis" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.picsum.photos/id/145/4288/2848.jpg?hmac=UkhcwQUE-vRBFXzDN1trCwWigpm7MXG5Bl5Ji103QG4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">168</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RWLNb9?ver=6f2d')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aegis</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法体系结构031_线段树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-created" datetime="2022-01-27T07:10:44.000Z" title=" 2022-01-27 15:10:44">2022-01-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-updated" datetime="2023-03-07T08:47:49.490Z" title=" 2023-03-07 16:47:49">2023-03-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">算法体系结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法体系结构031_线段树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p>一种数据结构,   负责对连续数据进行批处理,   比如修改某个数组的一个连续区域的数据,   对某个数组的一个连续区域进行求和,   也就是写数据和读数据;   设要上述操作的连续区域的数据量为N,   如果用普通的数组处理的话,   时间复杂度为O(N),   但是线段树能够将这些操作变为O(logN);   </p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>类似于堆,   线段树可以用数组来实现;   对于一个数组,   把它转化为线段树,   线段树的头节点为整个数组的和,   头节点的左孩子为整个数组的前半部分之和,   右孩子为整个数组的右半部分之和,   相当于左右孩子把数组切成两半,   各自求和,   左右孩子的左右孩子采取相同的操作;   例如数组arr[3,   4,   6,   7],   可以转化为如下的线段树:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221012144931176.png" alt="image-20221012144931176" style="zoom:67%;" />

<center>图1</center>

<p>像堆那样,   准备一个长数组,   线段树的头位置放在数组的开始,   然后通过下标运算,   可以算出头位置的左右孩子在数组中的下标,   左右孩子也可以通过下标运算找到父节点;   这样的话,   数组下标就应该从1开始算起,   线段树数组的0位置也应该舍弃,   举例,   对于数组arr2[3,   2,   1,   2,   6],   线段树是这样的:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221012151030255.png" alt="image-20221012151030255" style="zoom:67%;" />

<center>图2</center>

<p>对应的线段树数组应该是这样的:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221012153126422.png" alt="image-20221012153126422" style="zoom:67%;" />

<center>图3</center>

<p>如果某节点的下标为i,   则它的左孩子的下标为2 * i,   右孩子为2 * i + 1;   该节点的父节点为i / 2,   这和手写堆是一样的;   </p>
<p>怎么通过原数组得到线段树数组大小捏? 设原数组大小为N,   则最省空间的取值是N为2的幂次方,   因为当N为2的幂次方时,   每个线段树节点都均摊父节点的一半,   这样就是一棵满二叉树,   线段树数组的空间被完全利用,   而如果N为2的幂次方加1,   则最浪费空间,   因为这样相当于要开辟一层新的二叉树叶子节点,   而且还只使用了该层的两个节点,   如图2;   </p>
<p>所以最后算上不用的位置,   线段树数组长度申请为为4N,   一定够用;   当N为2的幂次方,   所申请的线段树数组大小为2N,   而二叉树的叶子节点数等于总节点数减去叶子节点数,   所以当遇到最坏情况时,   按照上面的推导,   只需要多申请一层即可,   所以要多申请2N,   所以最多最多4N;   </p>
<h2 id="构建线段树数组"><a href="#构建线段树数组" class="headerlink" title="构建线段树数组"></a>构建线段树数组</h2><p>设原数组为origin,   长度为N,   因为不使用0位置,   所以要重新构建一个数组,   长度为原数组加1:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span>[] origin)</span> </span>&#123;</span><br><span class="line">	MAXN = origin.length + <span class="number">1</span>;</span><br><span class="line">	arr = <span class="keyword">new</span> <span class="keyword">int</span>[MAXN];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">		arr[i] = origin[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>构建完成之后,   再创建其他数组,   长度为4MAXN:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="keyword">new</span> <span class="keyword">int</span>[MAXN &lt;&lt; <span class="number">2</span>]; </span><br><span class="line">lazy = <span class="keyword">new</span> <span class="keyword">int</span>[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">change = <span class="keyword">new</span> <span class="keyword">int</span>[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">update = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAXN &lt;&lt; <span class="number">2</span>];</span><br></pre></td></tr></table></figure>



<p>填写sum数组的函数,   左孩子的值加右孩子的值;   注意右孩子的下标运算,   rt往左移动之后,   最低位一定为0,   所以或1一定等于加1:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后是构建函数:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		sum[rt] = arr[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	build(mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传参含义:   在sum数组中,   sum[rt]表示arr[l,   r]这个区间上的累加和;   </p>
<p>如果l=r,   意味着在线段树中,   该节点为叶子节点,   所以此时,   arr[l,   r]上的累加和,    或者说是arr[r,   r]上的累加和,   就是arr[r],   那么直接填写即可;   </p>
<p>如果l!=r,   则分为两段构建,   先取数组arr的两个下标的中间值,   构建左孩子的值,   再构建右孩子的值,   当两个递归分支走完之后,   意味着左右孩子的值都已经填完了,   这样就可以直接调用pushUp函数对sum[rt]进行填写了;   </p>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>要实现的功能:   在[L,   R]这个范围上的数组arr的值全部加上一个整型数x;   </p>
<p>参数含义:   L、R、C表示任务,   表示要在[L,   R]这个范围上的所有值都加上整型数C,   而小写的l和r表示当前来到的sum数组的范围,   rt表示当前来到的sum数组的下标:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>懒加载:   与sum数组对应的lazy数组用于存放懒信息,   也就是当某一个添加任务下发给某一个线段树节点时,   如果该节点对应的arr数组的下标范围[l,   r]完全包住了任务范围[L,   R],   则lazy数组缓存起这次的添加任务,   不让该任务继续下发到下层的节点;   </p>
<p>举例:   对于数组arr[0,   0,   0,   0],   对应下标为1,   2,   3,   4;   累加和数组为:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221018164902252.png" alt="image-20221018164902252" style="zoom:67%;" />

<p>对应的懒加载数组为:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221018164931750.png" alt="image-20221018164931750" style="zoom:67%;" />

<p>对应的线段树为:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221018165710190.png" alt="image-20221018165710190" style="zoom:67%;" />

<p>现在传入一个任务,   要求在1-4范围上的每一个数都添加3,   则头节点领到任务,   它就懒住! 不下发给它的孩子们,   只对懒加载数组进行更新即可:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221018165915536.png" alt="image-20221018165915536" style="zoom:67%;" />

<p>当再来到一个添加任务,   要求在1-2范围上的每一个数都添加4;   则头节点领到任务,   自己上一个任务还没做呢,   就将上一个任务进行分发,   但是只发一层;   2位置和3位置的节点都收到了任务,   这样就可以清空头节点的懒信息,   懒加载数组变为:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221018170335940.png" alt="image-20221018170335940" style="zoom:67%;" />

<p>这时再加载该任务,   头节点发现这个任务只需要传给左孩子执行即可,   所以就直接交给左孩子;   而左孩子发现自己已经有懒信息了,   所以要将懒信息发给孩子们,   然后接收该任务,   lazy数组变为:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221018201603576.png" alt="image-20221018201603576" style="zoom:67%;" />

<p>当然可以进行另外一种操作,   由于该任务是被lazy[2]全包的,   所以也可以不下发,   lazy[2]变为7即可;   </p>
</blockquote>
<p>注意L、R、C不管发到谁身上,   都是不变的;   </p>
<p>当任务把当前的边界全包了,   如下图:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221018204907336.png" alt="image-20221018204907336" style="zoom:67%;" />

<p>说明此时应该懒住;   先更新当前节点的sum数组的值,   然后因为不下发,   所以对应的lazy数组上的值加上C,   直接返回:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">	sum[rt] += C * (r - l + <span class="number">1</span>);</span><br><span class="line">	lazy[rt] += C;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果当前任务没有被[l,   r]全包,   如下图:   </p>
<img src="D:/Program%20Files/Typora/img/image-20221018205106634.png" alt="image-20221018205106634" style="zoom:67%;" />

<p>则说明懒不住了,   也就是说,   将[l,   r]上全加上C的话,   才可以懒住,   但是[l,   L]上的数就加不了C,   所以懒不了;   所以此时,   需要将之前收集到的懒任务分发一层,   再让孩子们去懒:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">pushDown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br></pre></td></tr></table></figure>

<p>pushDown函数用于将懒任务发给rt的孩子们,   具体做法是,   两个孩子都接收一下rt的懒任务,   然后两个孩子各自更新自己的sum对应的值,   这里需要知道两棵子树的节点数量才可以继续更新,   其实也就是[l,   mid]和[mid+1,   r]两个区间各自的元素个数;   </p>
<p>然后,   如果左边需要添加值,   那就去添加左边,   如果右边需要添加值,   那就去添加右边:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">	add(L, R, C, l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) &#123;</span><br><span class="line">	add(L, R, C, mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后,   左边和右边都添加对了之后,   也就是左右两个孩子的值都更新对了,   就通过pushUp更新rt的值;   </p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>需要两个与lazy同样长度的数组,   布尔类型的update和整型的change,   同样有懒加载的思想;   change表示在某个位置上要变换的数字,   update表示对应着change的位置的值是否要更新,   也就是说,   如果update[x]=1,   那么就要把sum[x]及其子节点更新为change[x];   </p>
<p>L、R和C分别表示任务的范围和要更新成为的值:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br></pre></td></tr></table></figure>



<p>如果说当前来到的位置被任务包住了,   那么直接懒更新:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">	update[rt] = <span class="keyword">true</span>;</span><br><span class="line">	change[rt] = C;</span><br><span class="line">	sum[rt] = C * (r - l + <span class="number">1</span>);</span><br><span class="line">	lazy[rt] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说,   先更新update[rt]为true,   并且更新change[rt]为C,   表示该位置缓存着懒更;   因为懒更新,   所以不下发,   但是要更新当前位置的值,   也就是第4行的那句;   </p>
<p>最后将rt位置的懒添加信息清空,   可以理解为,   前面发了很多个懒添加任务,   我都做完了,   突然来了一个懒更新,   叫我把我的值更新为某个值,   那我还不如不做前面的懒添加,   直接懒更新就完事了,   而我确实没做,   所以就直接懒更新呗;   </p>
<p>如果没有包住,   无法懒更新,   那么就像懒添加那样处理即可,   一模一样的:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">pushDown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">	update(L, R, C, l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) &#123;</span><br><span class="line">	update(L, R, C, mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pushUp(rt);</span><br></pre></td></tr></table></figure>



<p>左老师的代码是可以将add和update函数交替使用的,   这两个函数的配合代码,   有一句刚刚讲过,   就是在懒更新时,   将懒添加清零;   另外的配合代码就在pushDown中;   </p>
<p>当要pushDown时,   如果懒更新和懒添加都存在的话,   一定只有一种情况,   就是懒更新之后又来了几个懒添加,   否则懒添加一定会被后来的懒更新给清除掉,   所以要先考虑懒更新:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (update[rt]) &#123;</span><br><span class="line">	update[rt &lt;&lt; <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">	update[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">	change[rt &lt;&lt; <span class="number">1</span>] = change[rt];</span><br><span class="line">	change[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = change[rt];</span><br><span class="line">	lazy[rt &lt;&lt; <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	lazy[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	sum[rt &lt;&lt; <span class="number">1</span>] = change[rt] * ln;</span><br><span class="line">	sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = change[rt] * rn;</span><br><span class="line">	update[rt] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>懒更新那一套先打起来,   然后再考虑懒添加:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lazy[rt] != <span class="number">0</span>) &#123;</span><br><span class="line">	lazy[rt &lt;&lt; <span class="number">1</span>] += lazy[rt];</span><br><span class="line">	sum[rt &lt;&lt; <span class="number">1</span>] += lazy[rt] * ln;</span><br><span class="line">	lazy[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[rt];</span><br><span class="line">	sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[rt] * rn;</span><br><span class="line">	lazy[rt] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询某个连续区间的累加和,   这跟添加和更新是类似的;   </p>
<p>还是有L和R这两个任务参量,   如果当前来到的位置被任务全包,   那么直接返回sum[rt];   </p>
<p>剩下的就和添加一样一样的,   只不过结果是累加而已:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">	<span class="keyword">return</span> sum[rt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">pushDown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line"><span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">	ans += query(L, R, l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) &#123;</span><br><span class="line">	ans += query(L, R, mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>题目:   俄罗斯方块问题,   有一个横轴,   下标从1开始,   一个方块沿着[x,   y]的区间往下落,   高度为z,   当它往下落时,   如果碰到某个已经落在地上的方块,   就停住,   当很多的方块落下之后,   返回这些方块累成的最大高度;   </p>
<p>思路:   一个方块沿着[x,   y]落下,   高度为z,   则[x,   y-1]这个区间上的值统一加z;   不是[x,   y]这个区间上的值统一加z的原因是,   当这块方块落到地面上的时候,   另外一块方块也可以沿着[y,   q]落在地上,   所以增加高度应该增加[x,   y-1]这个区间上的值;   </p>
<p>​            而整个线段树变为提供查询和更新功能的max线段树,   也就是不提供懒添加功能,   累加和策略变为最大值策略;   </p>
<p>​            当某一个方块从[x,   y]这个区间往下落的时候,   查询[x,   y-1]上的最大值,   将这个区间上的最大值更新为原最大值加该方块的高度;   </p>
<p>代码实现:   线段树的总区间为要增加值的区间, 而不是给定的数组的长度! 如果老老实实的采用线段树的定义的话, 就需要知道要增加的数值的最大值和最小值;   并且还要准备长度为(max - min + 1) * 4的数组来存放值,   所以需要抖机灵:   传递过来一个数组,   直接遍历数组,   将左右边界存入TreeSet中进行去重,   然后将得到的排好了序的TreeSet中的值拿出来,   作为Key值装入HashMap中,对应的value值为从1开始的递增整型数;   这样,   就把可能增加的值映射到了从1开始的数轴上,   而且不重复;   </p>
<blockquote>
<p>2022.11.02更新</p>
<p>为什么要做这样的映射? 因为如果不进行映射,   当方块掉落的区间处于一个”高频”范围时,   开辟的数组大小就需要与这个高频范围的最大值相等,   而且”低频”的空间还用不上,   所以要进行映射;   </p>
<p>在leetCode中提交这种方法,   会因为内存空间限制而通不过;   </p>
<p>因为将给定的二维数组处理好,   将每次的结果收集起来并返回,   就可以结束了,   所以并不需要查询提供的二维数组中的元素之外的下标值;   </p>
</blockquote>
<h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p>题目:   有很多房子,   从1~N编号,   有x种颜色,   提供update方法,   把[L,   R]内的房子全部刷成一种颜色的漆;   提供query方法,   返回[L,   R]上的房子的颜色种数;   </p>
<p>思路:   使用长整型的位信息,   某一种颜色出现了,   对应的位就是1,   没出现就是0;   而某个位置的值,   某个位置有多少种颜色,   应该如何填捏? 左边的值或上右边的值,   即可;   </p>
<blockquote>
<p>线段树的使用范围:   当某个位置的信息只需要对左右信息进行O(1)的简单操作,   而不需要调研具体的左右节点的数据时,   即可使用线段树;   </p>
</blockquote>
<h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><ol>
<li><p>pushDown</p>
<p>首先进行懒更新,   要注意它的逻辑,   懒更新的目的是将懒更新的任务下发,   所以要让左右孩子都正确更新,   </p>
<p>(1) 而正确更新,   首先要更新sum的值,   如果sum数组代表的是经典的区间和,   那么要记得各自乘以左右子树的节点个数;   </p>
<p>(2) 然后更新懒更新数组,   也就是设置change数组对应位置的值为change[rt],   设置update数组对应的位置为true;   </p>
<p>(3) 然后才是懒更新和懒增加的配合代码,   也就是让懒增加数组对应的位置清零;   </p>
<p>(4) 最后,   因为下发完成,   所以将懒更新数组对应的位置设为false;   </p>
<p>以上只是懒更新,   后面还有懒增加;   </p>
<p>(1) 先将左右子节点的sum值更新好,   注意各自要乘以左右子树的数量;   </p>
<p>(2) 然后设置懒增加数组的值为lazy[rt];   </p>
<p>(3) 最后清空lazy[rt];   </p>
</li>
<li><p>只有在写入数据的时候才需要在递归之前pushDown,   在最后pushUp;   查询的时候只需要pushDown即可,   不需要pushUp;   </p>
</li>
<li><p>左右边界非常多,   一定要注意L、R、l、r、mid的相对位置！</p>
</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/27/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-016-bing-cha-ji/"><img class="prev-cover" src="https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RWLNb9?ver=6f2d" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法体系结构014_并查集</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/27/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-032-indextree-yu-ac-zi-dong-ji/"><img class="next-cover" src="https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RWLNb9?ver=6f2d" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法体系结构032_IndexTree</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%87%BA"><span class="toc-text">提出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-text">结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%95%B0%E7%BB%84"><span class="toc-text">构建线段树数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0"><span class="toc-text">添加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-text">更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1"><span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2"><span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-text">易错点</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RWLNb9?ver=6f2d')"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>