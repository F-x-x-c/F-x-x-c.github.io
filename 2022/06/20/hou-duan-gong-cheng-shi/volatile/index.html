<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Volatile | Aegis</title><meta name="author" content="Deng"><meta name="copyright" content="Deng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="当今中国，信息技术如火如荼地发展着，通信技术在慢慢地由最高点往下落的时候碰巧遇上了计算机技术的发展热潮，于是顺利与之结合，形成ICT行业，继续发光发热。在计算机技术的影响下，通信行业的各个领域似乎都有了编程的影子，像核心网开始了自己的NFV（网元功能虚拟化），又比如可编程网络SDN。不仅是高新技术方面，在通信行业的工作当中，各个公司可能会搭建自己的notes平台，它支撑了很多工作流程，同时编程是一">
<meta property="og:type" content="article">
<meta property="og:title" content="Volatile">
<meta property="og:url" content="http://example.com/2022/06/20/hou-duan-gong-cheng-shi/volatile/index.html">
<meta property="og:site_name" content="Aegis">
<meta property="og:description" content="当今中国，信息技术如火如荼地发展着，通信技术在慢慢地由最高点往下落的时候碰巧遇上了计算机技术的发展热潮，于是顺利与之结合，形成ICT行业，继续发光发热。在计算机技术的影响下，通信行业的各个领域似乎都有了编程的影子，像核心网开始了自己的NFV（网元功能虚拟化），又比如可编程网络SDN。不仅是高新技术方面，在通信行业的工作当中，各个公司可能会搭建自己的notes平台，它支撑了很多工作流程，同时编程是一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-06-20T01:45:01.000Z">
<meta property="article:modified_time" content="2022-06-21T14:33:52.023Z">
<meta property="article:author" content="Deng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/06/20/hou-duan-gong-cheng-shi/volatile/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Volatile',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-06-21 22:33:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Aegis" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.picsum.photos/id/145/4288/2848.jpg?hmac=UkhcwQUE-vRBFXzDN1trCwWigpm7MXG5Bl5Ji103QG4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aegis</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Volatile</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-created" datetime="2022-06-20T01:45:01.000Z" title=" 2022-06-20 09:45:01">2022-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-updated" datetime="2022-06-21T14:33:52.023Z" title=" 2022-06-21 22:33:52">2022-06-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Volatile"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>当今中国，信息技术如火如荼地发展着，通信技术在慢慢地由最高点往下落的时候碰巧遇上了计算机技术的发展热潮，于是顺利与之结合，形成ICT行业，继续发光发热。在计算机技术的影响下，通信行业的各个领域似乎都有了编程的影子，像核心网开始了自己的NFV（网元功能虚拟化），又比如可编程网络SDN。不仅是高新技术方面，在通信行业的工作当中，各个公司可能会搭建自己的notes平台，它支撑了很多工作流程，同时编程是一个效率工具，通过自己写的脚本可以很好地提高工作效率。各个大学也意识到这一点，开始往传统的通信专业中增加编程相关的课程，同时，大学之中通信专业的工具很多是由Java语言编写的，像Matlab、以及SDN中的floodlight控制器。</p>
<p>其实学习编程语言并不算难，因为学习语言是人类的天赋，但是要想学好一门编程语言，就一定得下功夫去了解这门语言的各种各样的细节。由于传统的C语言和C++语言相当于是通过编译器建立在汇编语言之上的，为了使得高级语言足够抽象化，C语言在设计上屏蔽了许多的汇编层面的细节，这造成了没有学习过汇编的C程序员很难发现其中的问题。其实不仅是C语言，像其他高级语言，比如Java，建立在一套更加抽象的虚拟机之上，想要彻底搞懂Java就更难了。由于Java语言需要兼顾代码简洁性与高并发的效率，所以Java在实现上难免涉及到深层次的一些内容，比如处理器架构、使用内联汇编提升效率等等，而计算机发展这么多年，底层、源码设计早已成为汪洋大海，这导致了市面上一些解析Java语言的书籍或课程因为不够了解底层而造成一些谬误。而网络上经常被讨论的Java关键字volatile和缓存一致性协议MESI之间的关系就被写入了《Java并发编程的艺术》当中，该书认为volatile在一定程度上是用MESI协议实现的，这其实是对底层不够了解而造成的谬误。本篇文章将从最原始的volatile实现说起，结合处理器架构和Linux源码对volatile进行剖析，阐述volatile和MESI之间的关系。</p>
<p>volatile的最初实现是在C语言当中，可以从Linux源码提供的文件volatile-consider-hrmful.txt中看到，”The key point to understand with regard to volatile is that its purpose is to suppress optimization, which is almost never what one really wants to do. “，我们知道了volatile在C语言当中是为了抑制编译器优化的，抑制编译器优化的原因有几点，一是对于学者而言，像CSAPP中阐述的那样去研究汇编代码，这需要让生成的汇编代码遵循程序员编写的C代码的整体结构，但是在Linux中这完全可以用命令“gcc -Og”来实现，二是对于开发者而言，汇编器优化时不时地会产生一些意料之外的漏洞。再者，volatile禁止的是编译器的所有优化，但是由于存在各种各样的局部限制策略，例如自旋锁、互斥锁和内存屏障，能够完成工作，而不管是程序还是程序员都希望内核代码运行的很快，所以在内核中，volatile并没有太多存在的必要，比如对一把锁使用volatile，这会使得程序的运行速度变得很慢。就像这个文档之后谈到的，“If volatile is still necessary, there is almost certainly a bug in the code somewhere.  In properly-written kernel code, volatile can only serve to slow things down.”</p>
<p>而在Java语言当中，volatile关键字用于保证内存可见性，也可以防止指令重排序。而在这之前需要补充几个知识点。首先，现代的处理器架构多数采用微指令的方式来实现高性能，我们知道C和C++文件被编译器编译为汇编代码，而CPU所执行的就是这些汇编代码对应的机器代码，但是由于为了提高执行的效率，现代CPU将所需要执行的汇编代码拆分为几条更小的指令，就是所谓的微指令。这些微指令在CPU的流水线中乱序执行，微指令通过一些策略有效地防止了数据之间的依赖冲突。</p>
<p>MESI协议规定，当流水线要把一个值写到缓存行中去的时候，有一个必要条件：这个数据必须已经存在于缓存行中，如果没有在缓存行中，则必须等待CPU将该数据从CPU中将该数据加载到缓存行中，再把该值写到缓存行中覆盖它。如果没有store buffer的存在，CPU需要等待内存中的数据加载到缓存行中才会继续工作</p>
<p>由于CPU访问内存的速度太慢，所以引入了缓存，在多核CPU架构中，由于每个CPU都有自己的缓存，所以会出现可见性的问题，即共享数据不一致；CPU设计者引入了MESI协议来解决这个问题，但是由于缓存一致性协议中同步共享变量的步骤会造成CPU空转，所以引入了store buffer和Invalidate Queues将该步骤由同步改为异步，但是在某些情况之下，异步也可能会导致可见性的问题，所以引入了内存屏障，程序员可以通过内存屏障，在某些关键的时刻通过牺牲CPU性能来获取数据可见性。</p>
<p>而在Java中，对一个变量使用volatile，会引发两方面的结果，一是如同C语言中的volatile，会禁止编译器对该变量进行优化，二是对与这个变量相关的读写指令增添内存屏障。由于不同的CPU架构会产生重排序，JVM虚拟机通过一定的抽象，屏蔽了CPU架构的这些差异，为Java程序员提供了简单明了的接口，方便他们使用内存屏障。而具体的JVM中对于内存屏障的实现需要深入JVM源码中去，首先对Java程序通过Javap -verbose进行反编译，可查看到具体的一些信息如堆栈信息，通过对变量增加volatile前后进行对比，可以得到，加了volatile的变量在字节码层面其实并不会有所改变，但是字节码中的access_flag变为了ACC_VOLATILE，而在JVM源码的字节码解释器的cpp文件中，有具体的代码去访问该位，如果满足条件，则会调用OrderAccess : : load_acquire、OrderAccess : : release_store、OrderAccess : : storeload等函数，内存屏障具体就是用这些函数实现的，而这些函数的具体实现是在Linux源码里：如果是多核处理器，使用内联汇编调用lock前缀修饰一条空指令。</p>
<p><img src="C:/Users/14593/Desktop/64d4b17eca80653872ee4d7680dda144ac348293.png" alt="64d4b17eca80653872ee4d7680dda144ac348293"></p>
<p>从上图中可以看到，当多条流水线乱序执行后，会将结果放入CPU内部的Store Buffer中，然后再缓冲区写满后，批量刷入缓存中。多个CPU之间的缓存通过MESI来保证一致性。对于这个模型，由于没有采取任何优化手段，所有的加载都是顺序执行的，所以在多线程之间并不存在Load Load乱序。Intel拥有Store Buffer，再写入缓存中时，由于满足先进先出的队列特性，自然保证了Store Store的顺序性。当变量被写入Store Buffer中时，由于MESI并不能保证CPU内部缓冲区的可见性，其他CPU将会读到一个旧值，这就产生了一个错觉：其他线程明明已经写了值，但是由于读不到最新的值，发生了后面的读操作重排序到了写操作前面。为了避免这种现象，可以使用lock指令来保证当前指令执行完毕后将会把Store Buffer的数据刷新到缓存中，然后由MESI来保证可见性，从而避免了Store Load现象。这种模型称为TSO模型。TSO模型虽然保证了程序的写入顺序，但是唯一的缺点是，Store Buffer的出现导致了写滞留，降低了处理器的性能。而PSO模型，也叫部分有序模型，可以不管写入顺序，直接处理。换句话说，Store Buffer中的数据只要发现指令流水线执行完毕，马上就会被写入缓存中，不管其中是否还有其他未执行完成的变量。这种模型虽然提高了性能，但是出现了Store Store乱序现象。</p>
<p>As can be seen from the above figure, when multiple pipelines are executed out of order, the results will be put into the StoreBuffer inside the CPU, and then after the buffer is full, they will be flushed into the cache in batches. Caches between multiple CPUs use MESI to ensure coherency. For this model, since no optimization measures are taken, all loads are executed sequentially, so there is no LoadLoad out-of-order between multiple threads. Intel owns the StoreBuffer, and when writing to the cache, the order of the StoreStore is naturally guaranteed due to the first-in, first-out queue characteristics. When the variable is written to the StoreBuffer, since MESI does not guarantee the visibility of the CPU&#39;s internal buffer, other CPUs will read an old value, which creates an illusion: other threads have clearly written the value, but due to the read Before the latest value, a subsequent read operation has been reordered to the front of the write operation. In order to avoid this phenomenon, the lock instruction can be used to ensure that the StoreBuffer data will be flushed to the cache after the execution of the current instruction, and then MESI will ensure the visibility, thus avoiding the StoreLoad phenomenon. This model is called the TSO model. Although the TSO model guarantees the write order of the program, the only disadvantage is that the appearance of StoreBuffer causes write retention and reduces the performance of the processor. The PSO model, also known as the partially ordered model, can be processed directly regardless of the order of writing. In other words, the data in the StoreBuffer will be written to the cache as soon as it is found that the execution of the instruction pipeline is completed, regardless of whether there are other unexecuted variables in it. Although this model improves performance, the phenomenon of StoreStore disorder appears.</p>
<p>Store Buffer的阻塞导致了流水线的阻塞。Invalid Queue被用于减轻这种效果，不需要再等待其他CPU将缓存置为无效状态，只需要将Invalidate信号放入其他CPU缓存相关的Invalid Queue队列中，然后立即返回ACK，就避免了Store Buffer的阻塞导致的性能损耗。但同时又引出了新的问题—这样会造成Load Load、Load Store重排序现象。举个例子，CPU1写出了一个变量a，这时置为无效的信息还存在于CPU2的Invalid Queue中，CPU2的缓存中的变量a依旧是旧数据，CPU1认为变量a的刷出已经造成CPU2的变量失效，但事实上却没有，这就造成了CPU2在加载变量a时加载的依旧是旧数据，从而导致了Load Load重排序的假象。同理，Load Store也是，对于CPU2而言，后面对于其他变量的写也因为缓存行中的变量a是旧数据，而造成了写其他变量重排序到读变量a之前。</p>
<p>The blocking of the StoreBuffer causes the blocking of the pipeline. InvalidQueue is used to alleviate this effect. There is no need to wait for other CPUs to invalidate the cache. It is only necessary to put the Invalidate signal into the InvalidQueue queue related to other CPU caches, and then return ACK immediately, avoiding the blocking of StoreBuffer. performance loss. But at the same time, it brings up new problems—this will cause LoadLoad and LoadStore reordering. For example, CPU1 writes a variable a. At this time, the invalid information still exists in the InvalidQueue of CPU2. The variable a in the cache of CPU2 is still the old data. CPU1 thinks that the flushing of variable a has caused CPU2’s variable is invalid, but in fact it is not, which causes the CPU2 to load the old data when loading the variable a, which leads to the illusion of LoadLoad reordering. Similarly, LoadStore is also. For CPU2, the subsequent writing of other variables is also because the variable a in the cache line is old data, which causes the writing of other variables to be reordered before the reading of variable a.</p>
<p>当CPU在执行时,如果数据没有依赖性，那么就有可能将这些指令一起加载多个放到CPU指令流水线中执行，这就导致了指令在执行前就已经乱序。那么如果有些特殊需求，如操作IO端口时，由于某些特殊情况不允许多条指令流水线同时执行，必须强制读写操作严格不能乱序，也就是不能同时执行，那么怎么做?这时intel就提供了lfence、sfence、mfence 来保证前面的指令完全在流水线中完成后才能执行。但是如果只在一条流水线上产生这种指令执行乱序现象，并不会造成多线程之间的可见性问题，因为在切换线程执行后，在单CPU上，上一个线程执行的结果都将刷入内存中。所以，我们在聊可见性、乱序问题时通常不考虑CPU乱序执行的情况。而JVM为何不用lfence、sfence、mfence屏障也容易说得通了。可以让它们乱序执行，但是需要保证内存写入可见和顺序问题，那么这时我们就需要详细解释内存写乱序原理了。</p>
<p>我们知道CPU多级流水线可以让指令乱序执行增加指令的吞吐量，充分利用CPU的硬件资源。而乱序执行后，为了保证执行顺序，我们需要在指令结果写回缓存前进行重排序，也称之为指令reorder.而在intel中就采用了这样一个指令结果写回队列，称之为Store Buffer，当指令写回缓存时，写入操作发生cache missing,即变量保存在内存中,并不在缓存中,这时就会暂时先将结果在Store Buffer 中重排序因为MESI 协议规定了，当数据不再缓存中时，需要先加载到缓存中。而后续的所有写入操作（不管是否发生 cache missing)为了保证写入顺序，都会放置在Store Buffer中(直到 Store Buffer 中屏障前的数据处理完)。因此，Store Buffer很容易会满，当Store Buffer满了之后，CPU还是会卡在MESI 规定的Invalidate ACK(MESI规定数据从 Store Buffer中刷出时，需要先发送一条Invalidate的信号将其他CPU缓存中的数据设置为无效状态，并且等待 ACK到达后才能写出Store Buffer)以处理Store Buffer中的条目，然后批量写回缓存中，这时可能导致写回的结果暂时不可见且降低性能。</p>
<p>When the CPU is executing, if the data has no dependencies, it is possible to load these instructions together into the CPU instruction pipeline for execution, which causes the instructions to be out of order before execution. Then if there are some special requirements, such as when operating the IO port, due to some special circumstances, multiple instruction pipelines are not allowed to be executed at the same time, and the read and write operations must be strictly not out of order, that is, they cannot be executed at the same time, then what should we do? At this time, intel will lfence, sfence, and mfence are provided to ensure that the preceding instructions can only be executed after they are completely completed in the pipeline. However, if this kind of out-of-order execution of instructions occurs on only one pipeline, it will not cause visibility problems between multiple threads, because after switching the execution of threads, on a single CPU, the results of the execution of the previous thread will be flushed. into memory. Therefore, when we talk about visibility and out-of-order issues, we usually do not consider the situation of CPU out-of-order execution. And why the JVM does not use lfence, sfence, and mfence barriers is easy to reason. They can be executed out of order, but we need to ensure the visibility and order of memory writes. Then we need to explain the principle of out-of-order memory writes in detail. We know that the CPU multi-stage pipeline can make instructions execute out of order to increase the throughput of instructions and make full use of the hardware resources of the CPU. After out-of-order execution, in order to ensure the execution order, we need to reorder the instruction results before writing them back to the cache, which is also called instruction reorder. In Intel, such an instruction result is written back to the queue, which is called StoreBuffer , When the instruction is written back to the cache, the write operation occurs cachemissing, that is, the variable is stored in the memory, not in the cache. At this time, the result will be temporarily reordered in the StoreBuffer because the MESI protocol stipulates that when the data is no longer cached , it needs to be loaded into the cache first. All subsequent write operations (regardless of whether cachemissing occurs) will be placed in the StoreBuffer in order to ensure the write order (until the data before the barrier in the StoreBuffer is processed). Therefore, the StoreBuffer can easily become full. When the StoreBuffer is full, the CPU will still be stuck in the InvalidateACK specified by MESI (MESI stipulates that when data is flushed from the StoreBuffer, an Invalidate signal needs to be sent first to set the data in other CPU caches to Invalid state, and wait for the ACK to arrive before writing out the StoreBuffer) to process the entries in the StoreBuffer, and then write back to the cache in batches, which may cause the results of the write back to be temporarily invisible and reduce performance.</p>
<p>Provide a simple and clear programming paradigm for the upper layer for programmers to use, the memory model is simple and easy to understand, and the volatile modifier programming is simple and convenient. For the bottom layer, shield the differences between different bottom layer implementations, and try to limit the compiler and processor as little as possible.</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/21/excalidraw/test/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2022/06/18/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-024-hua-dong-chuang-kou-geng-xin-jie-gou/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法体系结构024-滑动窗口更新结构</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.picsum.photos/id/145/4288/2848.jpg?hmac=UkhcwQUE-vRBFXzDN1trCwWigpm7MXG5Bl5Ji103QG4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Deng</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><div class="sticky_layout"></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>