<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法体系结构025-单调栈 | Aegis</title><meta name="author" content="Deng"><meta name="copyright" content="Deng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 单调栈1.1 概念对于一个数组的每一个元素,   都获取到该元素左边比它小的第一个值和右边比他小的第一个值,   大的也可以,   传统的方法为对每一个元素的左边和右边都进行遍历,   那这样整体的时间复杂度为O(N2),   单调栈提供对这个流程的O(N)算法;    1.2 流程有几个规则共同作用:     栈中存放数组的索引,   如果是要获取第一较小值,   则这个栈的顺序从栈底到栈">
<meta property="og:type" content="article">
<meta property="og:title" content="算法体系结构025-单调栈">
<meta property="og:url" content="http://example.com/2022/06/26/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-025-dan-diao-zhan/index.html">
<meta property="og:site_name" content="Aegis">
<meta property="og:description" content="1. 单调栈1.1 概念对于一个数组的每一个元素,   都获取到该元素左边比它小的第一个值和右边比他小的第一个值,   大的也可以,   传统的方法为对每一个元素的左边和右边都进行遍历,   那这样整体的时间复杂度为O(N2),   单调栈提供对这个流程的O(N)算法;    1.2 流程有几个规则共同作用:     栈中存放数组的索引,   如果是要获取第一较小值,   则这个栈的顺序从栈底到栈">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-06-26T11:03:06.000Z">
<meta property="article:modified_time" content="2022-07-02T10:32:40.565Z">
<meta property="article:author" content="Deng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/06/26/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-025-dan-diao-zhan/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法体系结构025-单调栈',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-02 18:32:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Aegis" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.picsum.photos/id/145/4288/2848.jpg?hmac=UkhcwQUE-vRBFXzDN1trCwWigpm7MXG5Bl5Ji103QG4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aegis</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法体系结构025-单调栈</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-created" datetime="2022-06-26T11:03:06.000Z" title=" 2022-06-26 19:03:06">2022-06-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-updated" datetime="2022-07-02T10:32:40.565Z" title=" 2022-07-02 18:32:40">2022-07-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法体系结构025-单调栈"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1. 单调栈"></a>1. 单调栈</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>对于一个数组的每一个元素,   都获取到该元素左边比它小的第一个值和右边比他小的第一个值,   大的也可以,   传统的方法为对每一个元素的左边和右边都进行遍历,   那这样整体的时间复杂度为O(N<sup>2</sup>),   单调栈提供对这个流程的O(N)算法;   </p>
<h2 id="1-2-流程"><a href="#1-2-流程" class="headerlink" title="1.2 流程"></a>1.2 流程</h2><p>有几个规则共同作用:   </p>
<ol>
<li>栈中存放数组的索引,   如果是要获取第一较小值,   则这个栈的顺序从栈底到栈顶采用索引对应的值从小到大的顺序存放索引;   </li>
<li>当一个想要加入栈中的元素X比栈顶元素要小,   也就是如果加了进来会不满足栈底到栈顶从小到大的顺序,   那么栈中比X元素大的值依次弹出,   弹出时收集信息,   弹出的元素左边第一较小值为弹出后的栈顶元素,   也就是该元素未弹出时压着的元素,   右边第一较小值为引起该元素弹出的想要加入栈的元素X;   收集信息时如果有值就用值,   没有值的话,   比如栈底元素弹出时,   用-1代表没有值;   </li>
<li>当栈中已经没有元素或者没有元素比X大了,   那么X就可以入栈了;   </li>
</ol>
<p>为什么当一个值被弹出的时候,   左边压着的数是左边第一较小值,   想要进栈的数是右边第一较小值?</p>
<p>证明:   在没有重复值的前提下,   首先证明右边,   也就是想要加入栈中的元素为因为这个元素想要加进来而被弹出的栈顶元素的右边第一较小值;   首先,   想要加入栈中的元素X在数组中的位置一定是被弹出的栈顶元素S<sub>1</sub>的右边,   那么如果说在数组中这两个数之间,   也就是[S<sub>1</sub>,   X]这个区间上,   存在一个比S<sub>1</sub>小的数,   那么在遍历到这个数的时候S<sub>1</sub>就已经被弹出并收集信息了,   根本轮不到X来弹出它,   所以X就一定S<sub>1</sub>的右边第一较小值<font color='blue'>(类似于自旋锁的原理)</font>;<br>然后证明左边,   设S<sub>1</sub>在栈中压着的那个值为S<sub>2</sub>,   在数组中,   S<sub>2</sub>一定在S<sub>1</sub>的左边,   而对于[S<sub>2</sub>,   S<sub>1</sub>]这个区间上的数,   如果有一个数比S<sub>2</sub>小,   那么S<sub>2</sub>就会被这个数弹出;   如果这个区间上有一个数比S<sub>2</sub>大但是比S<sub>1</sub>小,   那么这个数一定会在栈中,   要么就是被另一个比这个数大但是比S<sub>1</sub>小的数弹出,   但是这样这个数又会被卡在S<sub>2</sub>和S<sub>1</sub>之间,   这样S<sub>1</sub>不可能压在S<sub>2</sub>的上面,   所以[S<sub>2</sub>,   S<sub>1</sub>]这个区间上的数一定大于S<sub>1</sub>,   那么S<sub>1</sub>的左边第一较小值就一定是S<sub>2</sub>;   证毕;   </p>
<p>如果是有重复值的话,   那对于每一个元素都建立一个小链表,   值弹出的时候就把小链表弹出,   加入小链表的时候就加到小链表的末尾,   获取到左边第一较小值时也是获取的压着的链表的末尾的值;   </p>
<h2 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h2><p>下面是有重复值的实现:   遍历整个数组,   有三种情况,   栈顶元素大于等于小于遍历到的元素(想要入栈的元素);   如果是栈顶元素小于想入栈的元素的话,   就自己生成一个链表加进来就好;   如果是等于的话,   就直接添加到栈顶链表里面就好;   如果栈顶元素大于想入栈的元素,   直观来讲,   想要入栈的元素累加不上去了,   那就应该依次弹出比想入栈的元素大的链表并收集信息;   但是! 可能弹出了栈顶链表后,   想要入栈的元素恰好和新当上栈顶元素的链表的值一样,   这样就有一个技巧,   也就是先判断栈顶元素小于想入栈的元素,   等到把该弹出的弹出之后,   再进行是否相等的判断;   不要忘了遍历结束之后,   栈中依然会有值,   所以在最末尾需要单独用一个循环把这些值弹出,   而对于单调栈,   遍历结束之后栈中一定会有值,   一种极端的情况就是倒序,   {5,   4,   3,   2,   1},   加进去一个就弹出一个,   加进去一个就弹出一个,   而在最后,   1把2弹出,   自己进了栈,   遍历结束,   再也没有值可以把末尾的元素弹出了,   所以单调栈遍历结束之后一定会有值留在栈中;   </p>
<h1 id="2-子数组最大指标"><a href="#2-子数组最大指标" class="headerlink" title="2. 子数组最大指标"></a>2. 子数组最大指标</h1><ol>
<li><p>题目</p>
<p>给定一个数组,   它的每一个子数组都有一个指标—子数组的累加和 * 子数组的最小值,   找到最大指标并返回;   </p>
</li>
<li><p>思路</p>
<p>客观来讲,   每一个子数组都会以这个子数组中的某一个位置的元素为最小值,   所以那个有着最大指标的子数组一定也是以某个位置的元素为最小值,   那我不妨遍历数组,   寻找以某一个元素为最小值,   但是数组累加和最大的子数组<font color='red'>(这里其实是控制变量法的思想,   由于题设所要寻找的子数组的指标有两个,   那不妨就固定其中一个,   然后想方法寻找另外一个)</font>;   具体来讲,   单调栈提供了每一个数组元素X的左右第一较小值,   假设下标为L和R,   那么说明在(L,   R)上的值都是比X对应的值要大的,   所以粗略来讲,   以这个数组元素为最小值的众多子数组中,   子数组累加和最大的一定就是[L+1,   R-1];   但是如果L,   则它要变为0,   因为这代表左边找不到比这个值更小的值了,   所以累加和最大的子数组的范围就延伸到了数组边缘;   </p>
</li>
<li><p>实现<br>严格按照单调栈的兼容重复值版本,   提前获取到所有元素的信息,   然后挨个检查,   这是没有问题的,   对于这种实现有一种优化,   由于获得了每一个位置的左右第一较小值,   处理完左右边界之后需要对这个区间进行求和,   该过程可以用前缀和进行处理;   </p>
<p>而左老师的做法有另外的优化,   即不考虑重复值,   这样做很可能是因为兼容重复值的单调栈比不兼容的实现起来要复杂一些,   包括对等于和大于的处理、弹出栈时无需遍历链表等等;   大体的流程为,   从栈中弹出一个元素,   得到了信息就开始处理,   得到了信息就开始处理;   具体来说,   如果不兼容重复值,   就会存在一种情况,   想要进栈的值和栈顶的值相同,   相当于进栈的值把栈顶的值弹出,   但此时被弹出的值所搜集到的信息是错误的,   也就是按照单调栈的规则,   弹出的值把想要进栈的元素作为右边界,   但是还需要往右边多找几个值,   但是这样的错误只会导致所求的累加和更小,   而且这个错误在后面的过程中会得到更正;   如果一个栈顶值被相同的入栈值弹出,   那说明要么他俩挨着,   要么他俩中间的元素比他俩大,   如果他俩中间的元素比他俩小,   那么就轮不到入栈值来弹出栈顶值了;   而入栈值把栈顶值弹出之后,   他俩的左边界都不会改变,   当入栈值被弹出的时候,   如果是被同样的值弹出,   那在这个同样的值被弹出之后就会得到正确的右边界;   如果是被更小的值弹出,   那说明右边界找到了,   而左边界和一开始被相同的值弹出的元素一摸一样,   这样就得到了正确的结果;   </p>
</li>
<li><p>左老师的方法的实现细节<br>出栈规则不是栈顶元素严格大于入栈元素,   而是大于等于入栈元素,   这样,   在遇到相同的元素时,   栈顶元素就可以出栈了;   另一个细节就是,   每弹出一个元素就进行一次答案的判断;   栈顶元素如果是在便利的过程中弹出的,   那么它的右边第一较小值可以设定为入栈元素,   而左边第一较小值是否存在就取决于栈是否为空,   如果为空,   意味着数组中左边已经没有元素比它小了,   所以在算上以这个元素为最小值的子数组累加和时必然就会延展到arr[0],   但是入栈元素i为数组中弹出元素的右边第一较小值,   也就是说元素i比弹出元素要小,   所以不能取到元素i,   这种情况为如果使用前缀和,   就为preSum[i-1];   如果栈不为空,   那么这个子数组的左右边界都确定了,   但是如同上面说的那样,   边界对应的元素不可取,   所以子数组的累加和为preSum[i-1]-preSum[stack.peek( )],   这样操作,   可以简化掉左右边界指针;   而在遍历过程之外的栈顶元素的弹出,   由于已经没有元素逼迫它们弹出了,   所以右边界就为arr.Len-1,   其他的同上面类似;   </p>
<p>一定注意,   收集答案的时候是累加和乘弹出的那个值 !</p>
</li>
</ol>
<h1 id="3-直方图面积"><a href="#3-直方图面积" class="headerlink" title="3. 直方图面积"></a>3. 直方图面积</h1><ol>
<li><p>题目<br>给定一个非负数组,   每一个元素代表了一张直方图中的一根柱子,   返回直方图最大长方形面积;   </p>
</li>
<li><p>思路<br>我一开始也是想着往单调栈上靠,   但是想错了长方形的判定标准;   正确的思路:   长方形必须以某一个元素的数值为高,   向两边扩;   </p>
</li>
</ol>
<h1 id="4-全1最大子矩阵的’1’个数"><a href="#4-全1最大子矩阵的’1’个数" class="headerlink" title="4. 全1最大子矩阵的’1’个数"></a>4. 全1最大子矩阵的’1’个数</h1><p>[[子矩阵]]</p>
<ol>
<li><p>题目<br>给定一个二维数组,   这数组里面不是0就是1,   返回这个数组的全1最大子矩阵中1的个数;   </p>
<img src="https://s2.loli.net/2022/07/02/2y4T7BsG5cCpX9O.png" style="zoom:80%;" /></li>
<li><p>遍历N * N矩阵<br>(1) 我的方法:   对于子矩阵中的第一个元素,   以它为左上角的子矩阵,   横着有N个,   每一个横着的子矩阵可以竖着往下N个再形成一个矩阵,   这样第一个元素就有N * N个子矩阵,   而其他位置的元素的子矩阵不一定严格以它为左上角,   但同样是N * N个,   而矩阵中又有N * N个元素,   所以有O(N<sup>4</sup>)个子数组;   </p>
<p>(2) 左老师的方法:   在矩阵中随意点一个元素,   有O(N<sup>2</sup>)种可能性,   再随意点一个元素,   又有O(N<sup>2</sup>)种可能性,   任意像这样的两个元素都可以组成一个子矩阵,   所以有O(N<sup>4</sup>)个子矩阵;   </p>
<p>而有O(N<sup>4</sup>)个子数组,   暴力解还需要对其进行遍历,   所以时间复杂度是O(N<sup>6</sup>);   </p>
</li>
<li><p>思路<br>以每一行作为地基,   每个元素往上寻找最大的直方图高度,   所以每一行都形成一个像第三题一样的数组,   然后求这个直方图的最大长方形面积;   每一个数组都用单调栈过一遍,   所以每一个数组都为O(N),   有N行,   就是N个数组,   所以时间复杂度为O(N<sup>2</sup>);   </p>
</li>
</ol>
<h1 id="5-全1子矩阵的数量"><a href="#5-全1子矩阵的数量" class="headerlink" title="5. 全1子矩阵的数量"></a>5. 全1子矩阵的数量</h1><ol>
<li><p>题目<br>给定一个矩阵不是0就是1,   返回这个矩阵全为1的子矩阵的数量;   </p>
</li>
<li><p>思路<br>像上一道题一样,   以每一个横着的数组为地基,   判断必须以这个地基的元素为底的子矩阵,  有多少个;   实际上是像上一道题一样,   压缩数组之后,   视作一个直方图,   来求这个直方图的矩阵个数;   具体来讲,   求直方图的时候,   使用单调栈遍历每一个元素,   在弹出元素的时候,   统计必须以这个元素为高的子矩阵内部的矩阵的数量,   注意必须以这个元素为高的子矩阵的范围,   举例说明,   如下图;   </p>
<p><img src="https://s2.loli.net/2022/06/28/x2zRMYTjnmbZGwW.png" alt="image-20220628135706923"></p>
<p>如果统计必须以height[3]=6为高的子矩阵内部的矩阵的数量,   由于左边为7,   所以可以往左扩,   但是height[1]=2,   所以不能扩到下标为1的位置,   右边也一样;   所以以height[3]=6为高的子矩阵有(Right-Left+1) * 6 = 2 * 6 = 12个,   但是如果把这12个全部加到结果中去的话,   在统计以height[1]=2为高的子矩阵内部的矩阵的数量的时候,   实际上和统计6为高的子矩阵时的一些低高度子矩阵冲突了,   所以在统计以6为高的矩阵内部的子矩阵时,   不能统计完全,   需要找到左右第一较小值中较大的那个,   高度相减,   也就是统计了高度为6、5、4、3的子矩阵的个数,   而剩下的高度为2和1的子矩阵就留给height[1]=2去统计,   而height[1]=2又会把高度为1的子矩阵留给height[4]=1去统计;   这样就避免了重复统计;   </p>
</li>
<li><p>实现<br>遍历每一行,   用另一个数组curArray进行数组压缩,   也就是遇到0就置为0,   遇到1就加上curArray的值,   也就是上一轮统计的上一行的数组压缩的值,   然后扔到一个函数中去,   把它视为直方图,   去统计它的子矩阵个数;   而统计子矩阵个数的流程:   使用单调栈遍历每一个元素,   在每一个元素弹出之时,   统计以这个元素为高的矩阵的子矩阵的数量,   看看它是否可以往左右扩展,   统计它的长度L,   然后再用高度减去左右第一较小值之中大的那个,   让低高度的矩阵由它们去统计,   总结下来公式就为(Right-Left+1) * L * (L+1) / 2;   最后再考虑边界问题,   首先声明Left和Right都是取不到的位置;   如果Left=-1,   说明这个元素左边全部都是比它大的值,   可以延伸到height[0]位置,   也就是如果栈为空,   要比较的height_left就为0,   否则就为height[Left],   而在便利的过程中,   height[i]是一定存在的;   所以这个比较是很容易的;   然后就是遍历完毕,   只从栈中弹出值的过程,   这个时候右边界全是N-1,   而且是可以取得到的,   要比较的height_right直接为0,   所以不需要比较了,   直接用该元素的高度减去height_left就可以了;   </p>
</li>
<li><p>优化<br>有两个地方优化,   一个是用自己写的栈,   一个是对于相同的元素的处理,   左老师讲,   如果说入栈元素和栈顶元素的值相同,   也就是后一个X去释放前一个X,   如果栈顶的X被弹出之后进行了子矩阵的统计,   那么当后一个X被弹出的时候,   又会把之前的那个X所统计的子矩阵的数量再算一遍,   造成重复,   所以在遇到相同值把栈顶元素弹出的时候,   直接不算结果,   让后面那个相同值去算;   但是如果不加的话,   起始也可以跑过呀;   举例说明,   如下图;   </p>
<p><img src="https://s2.loli.net/2022/06/28/gevHkWnCbpa8rhO.png" alt="image-20220628152504719"></p>
<p>height={3,   7,   7,   6,   7,   7,   6,   8,   6,   2};   </p>
<p>每一个重复值都算上的时候,   当第二个6把第一个6弹出时,   各个值如下图;   </p>
<p><img src="https://s2.loli.net/2022/06/28/vI7hCkuqOPV2Q6M.png" width="500"></img></p>
<p>由于被弹出的值认为它的右边第一较小值为第二个6,   所以down必定为6,   那当算子矩阵数量的时候,   弹出元素的值减去相等的元素的值,   直接为0,   相当于没有计算答案,   所以逻辑上不需要加那一行代码,   但是如果加上,   就可以少运行4行代码;   </p>
<p>第二个优化采用自己写的栈;   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line"><span class="keyword">int</span> si = -<span class="number">1</span>; <span class="comment">//si表示栈顶元素,也就是栈顶指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">    <span class="comment">//si==-1代表栈中没有值了</span></span><br><span class="line">    <span class="keyword">while</span> (si != -<span class="number">1</span> &amp;&amp; height[stack[si]] &gt;= height[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = stack[si--]; <span class="comment">//从栈中拿到元素, 再栈顶指针减1, 出栈</span></span><br><span class="line">        <span class="keyword">if</span> (height[cur] &gt; height[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = si == -<span class="number">1</span> ? -<span class="number">1</span> : stack[si];</span><br><span class="line">            <span class="keyword">int</span> n = i - left - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> down = Math.max(left == -<span class="number">1</span> ? <span class="number">0</span> : height[left], height[i]);</span><br><span class="line">            nums += (height[cur] - down) * num(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stack[++si] = i; <span class="comment">//让栈顶指针加1之后,再把索引值填进去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="6-子数组最小值累加和"><a href="#6-子数组最小值累加和" class="headerlink" title="6. 子数组最小值累加和"></a>6. 子数组最小值累加和</h1><ol>
<li><p>题目</p>
<p>给定一个数组,   返回这个数组的所有子数组的最小值的累加和;   </p>
</li>
<li><p>思路</p>
<p>每一个子数组必以某个位置为最小值,   那认定某个位置X为最小值,   需要找到这个位置左右第一较小值L和R,   在[L+1,   R-1]这个区间上的值一定以X为最小值,   那么这个区间上只要包含了X的子数组就一定以X为最小值,   计算个数的公式为:   从L+1出发,   到X算一个,   从L+1出发,   到X+1算第二个,   所以从L+1出发一共有R-1-X+1=R-X个,   这样的东东有</p>
<center>X-(L+1)+1=X-L个</center>

<p>没有忘记乘最后的arr[X]的公式就为</p>
<center>(R-X) * (X-L) * arr[X]</center></li>
<li><p>实现</p>
<p>其实本来不难,   但是leetCode上面有好几个测试用例的数据都贼勾八多,   所以在每次结果收集之后都要对10<sup>9</sup>+7取模的前提下,   还需要用long类型进行存储数据;   </p>
</li>
</ol>
<h1 id="7-对于可视化模型的改进"><a href="#7-对于可视化模型的改进" class="headerlink" title="7. 对于可视化模型的改进"></a>7. 对于可视化模型的改进</h1><p>理解了代码不代表记住,   所以需要不断地敲不断的敲,   记笔记看上去是一种输出,   其实好像没有什么效能,   我写了这么多的笔记,   甚至记不清楚上一次课的题目(我确实没有复习),   我还是觉得应该对算法使用记忆宫殿,   但是不应该像以前那样毫无目的的全盘记忆,   而是应该在理解的基础之上挑重点进行记忆,   如果不能够与原意匹配就不要太强求了;   现在总结一下以前对于算法运用的记忆术:   对于某一句易弄错的实际代码的一个小点点、整个算法流程;   但是由于宁老师的技巧基本没有扩展到记代码,   他也不会写代码,   所以记代码的难点还需要我自己来寻找,   由于之前瞎搞过一阵,   难点也琢磨出来一些:   </p>
<p>由于代码的重复性是很高的,   加减乘除的符号就那几个,   常用的变量名就那几个,   常用的数据结构也是那几个,   数据结构的变化性还是体现在应用方面,   比如像单调栈一样将栈与其他的规则结合起来以达到某个目的;   而且变一个地方代码可能会大不相同(比如归并排序的等号),   所以记代码还是应当从理解入手比如<font color='red'>流程</font>,   先理解了,   再记忆;   对于算法题而言,   很多题的解题思路可能是类似的,   但是我不相信同一份代码能够AC两道题,   也就是说代码之间一定是有互异性的;   其实不妨想想,   如果靠不断地敲代码去记,   即使把大多数流程都记住了,   一些<font color='red'>细节</font>一定还是会敲错、漏敲或者压根没有记起来有这个细节要多加小心,   就好像《爆裂鼓手》中说到的一样,   鼓手会因为自己敲错鼓点而咒骂自己,   主角也会在谱子上做好标记,   尽量减少自己的失误;   那为什么我不可以把这些<font color='red'>易错点</font>作为记忆重点呢? 我认为是可以的;   </p>
<p>其实初步总结下来应该就两点—流程和细节,   或者更准确地叫做,   易错点;   如果以后在记忆的过程中还有什么难点,   可以随时加入;   </p>
<p>文字是固定写在之上的,   有具体的纸面映像,   人脑具有发散功能,   提字然后抽象是传统的记忆术的基础,   一个抽象出来的字对应一个小的信息点,   比如口诀、桩子,   这应用于代码记忆似乎是不太妥当的,   比如入栈,   确实是很容易出图,   但是入栈操作血妈多,   都出图一定不可取;   而宁老师挖掘的比较深入的费曼类比似乎是将一句抽象的话转变为现实映像而实现的可视化,   但如果深究本质,   其实是动词的活用,   名词的类比,   或二者都有,   这对于代码记忆有没有好处呢? 是否需要把算法流程固定为一些串联的词语来符合记忆术的记忆对象呢? 我的建议是先尝试,   再下结论,   不然这样凭空意淫太痛苦了;   </p>
<p>补充:<br>(1) 注意到有一些细节是推导出来的,   那么不妨用记忆术在一个结果到另一个结果之间采用桩子进行连接;   </p>
<p>(2)不断地将思路敲出来,   也可以与类似的题目进行对比,   这个过程会将真正有价值的东西磨砺出来,   就好像反复过滤沙子从中洗出黄金一样,   那些东西就是真正需要记忆的;   </p>
<p>(3) 不断地将代码实现敲出来,   这个过程会将易错点磨砺出来;   </p>
<p><img src="https://s2.loli.net/2022/06/28/5rRJ4lVhmwsHzfd.png" width="600"></img></p>
<p>比如上文的第六题,   求子数组的最小值累加和,   先进行题目描述,   求得每个子数组的最小值,   加起来并返回;   然后描述流程,   以某一个元素X为最小值的子数组有多少个,   那既然这个元素为这个子数组的最小值,   说明这个区间的左右边界要么是数组的边界,   要么是比这个最小值大的数,   所以只需要求出这个最小值的左右第一较小值Left和Right,   那么在[Left+1,   Right-1]这个区间上的值一定比X的值要大,   然鹅还需要求得这个区间上所有以X为最小值的区间的个数,   也就是要跨过X的区间的个数,   因为Right取不到,   X取得到,   所以以Left+1开头的跨越X的子数组就有Right-X个,   也可以认为是Right-1-X+1,   也就是闭区间[L…R]的个数为R-L+1;   </p>
<p>流程:   也就是说遍历到某一个位置,   <font color='red'>找到以这个元素为最小值的子区间—</font>获得他的左右第一较小值,   然后统计个数;   而遍历的过程和寻找第一较小值的过程可以是绑定的,   也可以获得了全部的第一较小值信息后再进行最小值累加和统计;   但是即使认为这两个过程是绑定的,   在记忆的时候也可以将他们分开;   </p>
<p>第二题也是以某个元素为最小值,   但是不同点在于它是求那个区间的累加和,   但似乎有一种更统一的说法;   第六题为了求数组中某个以元素X为最小值的子区间个数,   我需要知道以元素X为最小值的最大子区间,   在这个最大的子区间里,   仍然会有许多的小区间不以元素X为最小值,   但是只要是包含X的区间,   都以X为最小值;   而第二题是需要知道以某个元素X为最小值的最大子区间,   然后对这个子区间进行求和;   而求最小值的最大子区间就是单调栈的应用,   为什么说明白了单调栈的原理还是做不了题目,   一部分原因是不清楚单调栈的应用;   </p>
<p>那其实只需要记住一句话:   <font color='red'>获得以某个元素为最小值的最大子区间</font> (,   需要使用单调栈 );   </p>
<p>然后就是单调栈的基础实现流程,   如果要获得以元素X为最小值的最大子区间,   就需要寻找到元素X往左往右第一个比它小的值,   由于是在元素弹出的时候收集信息,   所以导致栈顶元素被弹出的元素X需要比栈顶元素小,   压在栈顶元素之下的元素也需要比栈顶元素小,   那这个过程可以出一幅图,   <font color='blue'>垃圾桶中垃圾从小到大,   如果小垃圾想要入桶,   就需要把大垃圾先搬出来,</font>   如图;   </p>
<img src="C:/Users/14593/AppData/Roaming/Typora/typora-user-images/image-20220629230105723.png" alt="image-20220629230105723"  />



<p>然后是一些细节:   单调栈的相同值处理、遍历结束后要把值全部弹出以及手写栈的优化;   (<font color='blue'>相同体积的垃圾的处理,   用手来清理垃圾桶,   最后清空垃圾桶</font>);   (除了垃圾桶,   栈的现实映像还有做粽子,   做竹筒饭,   往洗衣机塞衣服,   邮箱)</p>
<p>相同值的处理,   对于第二个问题,   如果遇到了入栈元素和栈顶元素是相同的,   那么如何对他们进行处理? 遍历到入栈元素X,   而如果入栈元素X和栈顶元素一样,   那就只有一种情况,   就是在数组中,   这两个元素之间的值一定全部都比X的值要大,   这是因为如果出现了这种情况,   说明此前的遍历将栈顶元素压入栈,   然后栈顶元素迟迟没有被弹出,   说明都是一些比X的值要大的值入栈,   然后遇到了入栈元素X,   它把比X大的值全部弹出了,   才碰到了和自己一样大的栈顶元素,   换个思路,   如果说此时的入栈元素X和栈顶元素之间有比栈顶元素更小的值,   那么那个较小值就会把栈顶元素弹出,   而入栈元素和栈顶元素就不会相遇了,   所以这俩兄弟之间的值一定都比这俩兄弟大;   那么也就是说,   这两个兄弟的左边第一较小值是一样的,   那么想要求得以这个元素为最小值的最长子区间间,   由于这俩兄弟的左边界是一样的,   这俩中间又是全部比他们大的数,   那么实际上以栈顶元素为最小值的最长子区间一定真包含于以入栈元素X为最小值的最长子区间,   那我的目的是为了求得以X为最小值的最长子区间,   所以可以直接求以入栈元素为最小值的最长子区间,   换句话说,   以X为最小值的最长子区间,   以最后一个入栈的元素为准;   再来,   由于题设存在的都是正数,   所以最后一个入栈的相同元素的最长子区间的累加和就一定大于前面的任意以X为最小值的累加和,   那么,   在遇到入栈元素试图把相等的栈顶元素弹出的情况的时候,   对于本题有两种解决方法,   一种是直接不管,   也就是说反正会以后一个为基准,   所以可以直接不算,   等到最后一个连通前面的X弹出的时候,   再进行计算;   第二种处理方案是算就嗯算,   反正你前面的X不可能大于我后面的连通着的X,   所以你算也没用,   后一个的值一定会把前一个的值覆盖掉;   进行费曼类比就是,   <font color='blue'>在遇到相等体积的垃圾时,   可以直接扔掉;   </font> </p>
<p>手写栈的优化有几个点,   手写栈需要模拟栈的压入、弹出和peek,   这倒是没什么难点,   因为手写栈只需要一个栈顶指针;   压入是stack[++si],   就是嫌脏嘛,   缩在后面;   弹出stack[si–],   还是嫌脏嘛,   比正常速度快一点;   peek不需要记;   </p>
<p>还有就是边界的考察,   主要是左边界,   这个倒也不是什么难点,   就是如果是-1,   说明左边界会到达-1位置,   也可以是0位置,   这个和右边界一样,   -1或者0其实影响的是后面的计算;   </p>
<p>总结一下:<br>相同体积的垃圾处理(直接扔掉),   用手来处理垃圾(缩手和伸手,   伸手就是压栈,   把垃圾压进去,   畏畏缩缩的),   最后清空垃圾桶;<br>以某个元素为最小值的最长子区间,   用垃圾桶口的大垃圾记住,   因为它两边都是小垃圾;   </p>
<p>就这样;   还挺好;   </p>
<table>
<thead>
<tr>
<th>对于费曼类比的思考:   正如同宁老师说的那样,   含义行为是最强大的转化武器,   但是我认为除了含义行为行为之外,   还有含义状态,   比方说前面的对于手写栈的类比,   伸入栈中,   手伸入的速度之间的对比对应着si到底是在前还是在后;</th>
</tr>
</thead>
</table>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/29/sui-bi/zhu-guan-de-jin-tou-shi-ke-guan/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">主观的尽头是客观</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/22/hou-duan-gong-cheng-shi/duo-xian-cheng-1/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多线程1</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">1. 单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%B5%81%E7%A8%8B"><span class="toc-text">1.2 流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3 实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E6%8C%87%E6%A0%87"><span class="toc-text">2. 子数组最大指标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%9B%B4%E6%96%B9%E5%9B%BE%E9%9D%A2%E7%A7%AF"><span class="toc-text">3. 直方图面积</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%85%A81%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E2%80%991%E2%80%99%E4%B8%AA%E6%95%B0"><span class="toc-text">4. 全1最大子矩阵的’1’个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%85%A81%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">5. 全1子矩阵的数量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E5%80%BC%E7%B4%AF%E5%8A%A0%E5%92%8C"><span class="toc-text">6. 子数组最小值累加和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%AF%B9%E4%BA%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-text">7. 对于可视化模型的改进</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>