<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法体系结构021_动态规划4 | Aegis</title><meta name="author" content="Deng"><meta name="copyright" content="Deng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 货币组成 题目有一堆货币,   用一个数组来表示,   每个货币都是不一样的,   给定一个目标钱数aim,   要求返回组成目标钱数的方案数;     解法1这道题目有一个隐含的条件,   每一种可能都需要遍历到数组的末尾,   当遍历到数组末尾时,   去判断剩余的钱数是否刚好为0,   如果刚好为0,   则这条路行得通,   那么可能性就加1;       如果到达末尾钱数不为0,">
<meta property="og:type" content="article">
<meta property="og:title" content="算法体系结构021_动态规划4">
<meta property="og:url" content="http://example.com/2022/04/09/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-021-dong-tai-gui-hua-4/index.html">
<meta property="og:site_name" content="Aegis">
<meta property="og:description" content="1. 货币组成 题目有一堆货币,   用一个数组来表示,   每个货币都是不一样的,   给定一个目标钱数aim,   要求返回组成目标钱数的方案数;     解法1这道题目有一个隐含的条件,   每一种可能都需要遍历到数组的末尾,   当遍历到数组末尾时,   去判断剩余的钱数是否刚好为0,   如果刚好为0,   则这条路行得通,   那么可能性就加1;       如果到达末尾钱数不为0,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-04-09T14:22:41.000Z">
<meta property="article:modified_time" content="2023-01-23T03:07:23.393Z">
<meta property="article:author" content="Deng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/04/09/suan-fa-ti-xi-jie-gou/suan-fa-ti-xi-jie-gou-021-dong-tai-gui-hua-4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法体系结构021_动态规划4',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-23 11:07:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Aegis" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.picsum.photos/id/145/4288/2848.jpg?hmac=UkhcwQUE-vRBFXzDN1trCwWigpm7MXG5Bl5Ji103QG4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">168</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aegis</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法体系结构021_动态规划4</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-created" datetime="2022-04-09T14:22:41.000Z" title=" 2022-04-09 22:22:41">2022-04-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-updated" datetime="2023-01-23T03:07:23.393Z" title=" 2023-01-23 11:07:23">2023-01-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">算法体系结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法体系结构021_动态规划4"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-货币组成"><a href="#1-货币组成" class="headerlink" title="1. 货币组成"></a>1. 货币组成</h1><ol>
<li><p>题目<br>有一堆货币,   用一个数组来表示,   每个货币都是不一样的,   给定一个目标钱数aim,   要求返回组成目标钱数的方案数;   </p>
</li>
<li><p>解法1<br>这道题目有一个隐含的条件,   每一种可能都需要遍历到数组的末尾,   当遍历到数组末尾时,   去判断剩余的钱数是否刚好为0,   如果刚好为0,   则这条路行得通,   那么可能性就加1;   </p>
<table>
<thead>
<tr>
<th align="left">如果到达末尾钱数不为0, 则可能钱多了,   可能钱少了,   反正都不行;   如果没达到末尾时钱就已经为0了,   则只有一种行得通的可能,   就是剩下的货币全都不选,   如果没达到末尾时钱已经小于0了,   则直接返回0;   但是不管怎么样,   就这样大条地遍历,   结果是没有问题的;</th>
</tr>
</thead>
</table>
</li>
<li><p>解法2:   采用空间压缩的动态规划</p>
<p>按照解法1进行dp数组的填写,   可变参数有操作的货币index和剩余钱数rest,   由于二维数组的方式太简陋了,   所以这里采用一维数组填写,   也就是以rest为变量,   通过技巧省略可变参数index,   首先要进行rest的越界,   如果rest - arr[index] &lt; 0则返回0,   否则返回dp[rest - arr[index]],   而在填写的时候,   如果rest从左往右填写,   那么到达某个中间位置时,   本来期待的是</p>
<center>dp[index] [rest] = dp[index+1] [rest] + dp[index+1] [rest - arr[index]] </center>

<p>也就是下图</p>
<p><img src="https://s2.loli.net/2022/04/13/CQ9ILRKsFPuVqH3.png" width="700"></img></p>
<p>采用一维数组就变成了</p>
<center>dp[rest]  = dp[rest] + dp[rest - arr[index]] </center>

<p>也就是下图</p>
<p><img src="https://s2.loli.net/2022/04/13/S4AUDdWitFy2owN.png" width="800"></img></p>
<p>而由于从左往右填写,   dp[rest - arr[index]]的值在使用之前就已经改变,   变成了</p>
<center>dp[index] [rest - arr[index]]</center>

<p>依赖关系就变成了下图</p>
<p><img src="https://s2.loli.net/2022/04/13/Wdol48KnTVxtHsI.png" width="800"></img></p>
<p>所以比较重要的一个细节是将rest从右往左遍历,   这样可以避免rest - arr[index]对应的值在使用之前发生改变 !</p>
</li>
</ol>
<h1 id="2-货币组成-无限钱内购版"><a href="#2-货币组成-无限钱内购版" class="headerlink" title="2. 货币组成.无限钱内购版"></a>2. 货币组成.无限钱内购版</h1><ol>
<li><p>题目</p>
<p>还是用一个数组arr存放货币,   但是arr放的货币代表可以用的面值,   也就是只要有它,   就可以用无数张,   举例{1,   2},   目标钱数为5,   则有{1,   1,   1,   1,   1},   {1,   1,   1,   2},   {1,   2,   2}共3种组成方法;   </p>
</li>
<li><p>解法1:   递归</p>
<p>大循环遍历整个数组,   对于每一个数组元素,   选择0张,   跳到下一个元素进行选择,   拿到方法数,   然后选择1张,   再跳到下一个元素进行选择,   选择2张…最后返回总的方法数即可;  </p>
<p>而动态规划的解法可以从二维动态规划到二维动态规划优化版本,   也可以由二维动态规划到一维动态规划,   再到一维动态规划优化版本,   所以本题会阐述4种动态规划解法;   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> rest, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rest / arr[index]; i++) &#123;</span><br><span class="line">        ways += process1(arr, rest - i * arr[index], index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>解法2:   二维动态规划</p>
<p>和上一道题目一样,   变量有两个,   (index,   rest),   首先要初始化,   也就是<br>$$<br>index == arr.length \space\space\space&amp;&amp;\space\space\space  rest == 0<br>$$<br>则dp[N] [0] = 0;   这时最底层就填完了,   然后再填上一层,   这种方法的每一层中的填写顺序是任意的,   因为每一个元素都只依赖下一行的元素,   也就是可以从左往右填,   也可以从右往左填,   而这题与上一题不同的地方是,   这题的每一个元素依赖的是下一层的好几个元素;   最后返回dp[0] [aim]即可;   </p>
</li>
<li><p>解法3:   一维动态规划</p>
<p>像上述解法说的那样,   每一层的元素都只依赖于下一层的元素所以有二维数组降为一维的希望;   下面具体分析,   由于每个元素依赖的是dp[index + 1] [rest - num * arr[index]],   在一维就是dp[rest - num * arr[index]],   也就是dp[rest]之前的那些元素,   所以在遍历到rest的时候,   rest之前的元素必定不能改变,   所以rest的遍历顺序必定是从右往左;   而其他的和二维动态规划没太大区别;   </p>
</li>
<li><p>解法4:   二维动态规划优化</p>
<p>进行更加严格的位置依赖分析之后可以发现一些进阶优化的策略,   对于位置(index,   rest)的元素,   依赖关系为<br>$$<br>dp[index][rest] = \ dp[index + 1][rest] + \dp[index + 1][rest - arr[index]] + \dp[index+ 1][rest - 2*arr[index]] + …<br>$$<br><img src="https://s2.loli.net/2022/04/15/jbgQkz5NnAa3H6J.png" width="800"></img></p>
<p>而<br>$$<br>dp[index][rest - arr[index]] = \dp[index+1][rest - arr[index]]+\<br>dp[index + 1][rest - 2 * arr[index]]<br>$$<br>所以<br>$$<br>dp[index][rest] =dp[index + 1][rest] + dp[index][rest-1]<br>$$<br>所以对于每个元素的操作都可以从”遍历”优化到一句代码,   如果rest - arr[index]合法,   则有如下代码:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt; aim + <span class="number">1</span>; rest++) &#123;</span><br><span class="line"><span class="comment">//		int ways = 0;</span></span><br><span class="line"><span class="comment">//		for (int num = 0; num &lt;= rest / arr[index]; num++) &#123;</span></span><br><span class="line"><span class="comment">//		ways += dp[index + 1][rest - num * arr[index]];</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">        dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line">        <span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            dp[index][rest] += dp[index][rest - arr[index]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/04/15/WtnTSRF5fMdh71Y.png" width="800"></img></p>
</li>
<li><p>解法4:   一维动态规划优化版本</p>
<p>在这个版本中,   每一个元素都依赖于其本身和它同一行的往左边数arr[index]位置的元素,   所以这自然需要从左往右遍历;   而其他的则和二维动态规划一样;   </p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">第一次复习发现一些坑点, 实差不多属于凭着记忆去写代码暴露的问题, 在写递归版本时, num的位置老师写错; 在写一维优化版本时, 由于rest - 0是不会越界的, 所以它自己就已经加上了它下面位置的元素了, 所以num应该从1开始;</th>
</tr>
</thead>
</table>
<h1 id="3-货币组成-开挂被罚版"><a href="#3-货币组成-开挂被罚版" class="headerlink" title="3. 货币组成.开挂被罚版"></a>3. 货币组成.开挂被罚版</h1><ol>
<li><p>题目</p>
<p>还是给定一个货币数组和目标钱数,   货币数组代表钱,   但是认为相同的货币没有什么不同,   问有多少种方法;   </p>
</li>
<li><p>思路</p>
<p>搞出两个数组,   一个用于存放面值,   一个用于存放面值有多少张,   就和上面那一题样嘛,   只不过上面那一题的第二个数组全部都为无穷而已;   而有一点变化的是,   遍历时,   上一题中张数的范围必须小于剩余目标钱数 / 该位置的面值,   而这道题为<br>$$<br>num &lt;= rest / values[index] \quad&amp;&amp;\quad num&lt;= counts[index]<br>$$<br>其他的东西和上一题的解法1是一样的;   </p>
</li>
<li><p>解法1:   递归</p>
<p>略;   </p>
</li>
<li><p>解法2:   动态规划初始版本</p>
<p>设好dp数组,   设好初始值,   遍历的时候从下往上,   从右往左;   遍历张数时记得加上上述的那个张数的判决条件;   </p>
</li>
<li><p>解法3:   动态规划高阶版本</p>
<p>此版本去除遍历张数的过程,   把该过程优化为1句代码;   下面具体分析,   我仍然想<br>$$<br>dp[index][rest] =dp[index + 1][rest] + dp[index][rest-1]<br>$$<br>但是由于限定了张数,   思路就必须重新回到递归上进行分析;   该二维dp数组的每个位置(index,   rest)的含义为:   在选取index这个位置的货币时,   还需要再凑rest这么多钱的凑法,   这时这个位置的货币的张数是限定了的;   而该位置的下面一个位置的含义为该位置的货币选取的张数为0时的凑法,   而标星号的位置( * )下面的那个位置( * - 1 )相对于(index,   rest)的含义为,   (index,   rest)位置的货币选取了1张时的凑法;   而( * - 1 )位置相对于( * )位置的含义为,   ( * )位置选取0张货币时的凑法,   如下图:   </p>
<p><img src="https://s2.loli.net/2022/04/15/vIoUMefGjAmlg2F.png" width="800"></img></p>
<p>总结下来,   rest位置要加的元素为[0,   y],   而( * )位置要加的位置为[1,   y + 1],   也就是说如果想要达成以下式子的话,   则必须考虑最远端的位置,   也就是标红的那个位置是否越界,   如果没有越界则要减去那个位置,   才可以满足下面的式子;<br>$$<br>dp[index][rest] =dp[index + 1][rest] + dp[index][rest-1]<br>$$<br>如果( * )位置也越界了,   那自然就不需要考虑标红的那个位置了,   所以具体的代码如下;   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="keyword">if</span> (rest - values[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    dp[index][rest] += dp[index][rest - values[index]];</span><br><span class="line">    <span class="keyword">if</span> (rest - values[index] * (counts[index] + <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dp[index][rest] -= dp[index + <span class="number">1</span>][rest - (counts[index] + <span class="number">1</span>)*values[index]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思想是我想要干某件事,   但是受到条件的约束,   那我就希望通过某种方式去消除该条件带来的约束,   让那件事可以办成;       </p>
<table>
<thead>
<tr>
<th>该问题需要注意的点:   统计去重,   期望越界,   干扰越界;</th>
</tr>
</thead>
</table>
</li>
</ol>
<table>
<thead>
<tr>
<th>去重的方法:   该题对方法数进行了去重,   去重的思路打破了提供的数据的限制,   不再拘泥于提供的数据;   具体来说,   把每一个重复的元素进行了统计,   当选择了某元素的个数为两个时,   代表在原数据中选取了任意两个相同的该元素,   达到了去重的效果;   总结下来就一句话,   统计个数以消除数据的差异性;</th>
</tr>
</thead>
</table>
<h1 id="4-坠落的爆爆"><a href="#4-坠落的爆爆" class="headerlink" title="4. 坠落的爆爆"></a>4. 坠落的爆爆</h1><ol>
<li><p>题目</p>
<p>爆爆在一个N* M的区域内乱逛,   向上下左右迈步的概率都是相同的,   当她迈出了N* M区域就会掉下去,   求k步之后她没有掉下去的概率;   </p>
</li>
<li><p>解法1:   递归</p>
<p>当走出去时,   返回0,   如果步数为0,   表示已经走完了还没掉下去,   就返回1;   如果还没有走完,   就上下左右都走,   返回各自的方法数之和即可;   </p>
</li>
<li><p>解法2:   动态规划</p>
<p>类似于马走日那道题,   是一道3维动态规划;   而且还不可以优化维度,   因为一个元素总时上下左右去依赖;   </p>
</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/12/lan-qiu/tou-lan/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">投篮</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/06/ying-ping/bian-fu-xia-hei-an-qi-shi-ying-ping/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《蝙蝠侠: 黑暗骑士》影评</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%B4%A7%E5%B8%81%E7%BB%84%E6%88%90"><span class="toc-text">1. 货币组成</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%B4%A7%E5%B8%81%E7%BB%84%E6%88%90-%E6%97%A0%E9%99%90%E9%92%B1%E5%86%85%E8%B4%AD%E7%89%88"><span class="toc-text">2. 货币组成.无限钱内购版</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%B4%A7%E5%B8%81%E7%BB%84%E6%88%90-%E5%BC%80%E6%8C%82%E8%A2%AB%E7%BD%9A%E7%89%88"><span class="toc-text">3. 货币组成.开挂被罚版</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%9D%A0%E8%90%BD%E7%9A%84%E7%88%86%E7%88%86"><span class="toc-text">4. 坠落的爆爆</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>