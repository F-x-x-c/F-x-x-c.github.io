<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>PCA | Aegis</title><meta name="author" content="Deng"><meta name="copyright" content="Deng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="PCAPCA解析1有许多只小白鼠,   每只小白鼠的DNA中都有各种各样的基因,   视频中给出了这些小白鼠的两种基因;   这里可以做一个抽象,   如何表示这些小白鼠? 可以用颜色啊,   瞳孔大小啊,   爪子的大小等等来描述一只小白鼠,   这些东西就是小白鼠的特征,   每一只小白鼠的这些特征都是不一样的,   而小白鼠的每一个特征都可以与一个数值挂钩;   因此,   当拿到一只小白鼠">
<meta property="og:type" content="article">
<meta property="og:title" content="PCA">
<meta property="og:url" content="http://example.com/2023/04/26/bi-ye-lun-wen/f013-pca/index.html">
<meta property="og:site_name" content="Aegis">
<meta property="og:description" content="PCAPCA解析1有许多只小白鼠,   每只小白鼠的DNA中都有各种各样的基因,   视频中给出了这些小白鼠的两种基因;   这里可以做一个抽象,   如何表示这些小白鼠? 可以用颜色啊,   瞳孔大小啊,   爪子的大小等等来描述一只小白鼠,   这些东西就是小白鼠的特征,   每一只小白鼠的这些特征都是不一样的,   而小白鼠的每一个特征都可以与一个数值挂钩;   因此,   当拿到一只小白鼠">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-04-26T07:30:17.000Z">
<meta property="article:modified_time" content="2023-04-26T07:30:33.831Z">
<meta property="article:author" content="Deng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/26/bi-ye-lun-wen/f013-pca/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PCA',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 15:30:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Aegis" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.picsum.photos/id/145/4288/2848.jpg?hmac=UkhcwQUE-vRBFXzDN1trCwWigpm7MXG5Bl5Ji103QG4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aegis</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PCA</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-created" datetime="2023-04-26T07:30:17.000Z" title=" 2023-04-26 15:30:17">2023-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-updated" datetime="2023-04-26T07:30:33.831Z" title=" 2023-04-26 15:30:33">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PCA"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h1><h2 id="PCA解析1"><a href="#PCA解析1" class="headerlink" title="PCA解析1"></a>PCA解析1</h2><p>有许多只小白鼠,   每只小白鼠的DNA中都有各种各样的基因,   视频中给出了这些小白鼠的两种基因;   这里可以做一个抽象,   如何表示这些小白鼠? 可以用颜色啊,   瞳孔大小啊,   爪子的大小等等来描述一只小白鼠,   这些东西就是小白鼠的特征,   每一只小白鼠的这些特征都是不一样的,   而小白鼠的每一个特征都可以与一个数值挂钩;   因此,   当拿到一只小白鼠的时候,   只需要测量这只小白鼠的上述特征,   然后与提前测好的数据进行对比,   就可以判断它是哪一只了;   </p>
<p>而视频中,   相当于使用”基因1”和”基因2”这两个特征来描述一只小白鼠;   </p>
<p>然后跟着视频走,   如果只用”基因1”来描述小白鼠的话,   那么这些小白鼠就可以被画到一条横轴上;   </p>
<img src="D:/Program%20Files/Typora/img/image-20230228221429091.png" alt="image-20230228221429091" style="zoom:80%;" />



<p>如果用两个基因来描述小白鼠的话,   那么这些小白鼠就可以被画到一个二维坐标系当中;   </p>
<img src="D:/Program%20Files/Typora/img/image-20230228221743565.png" alt="image-20230228221743565" style="zoom:80%;" />

<p>三个基因同理;   而因为人类是三微生物,   无法想象四维空间,   所以四维及其更高维度无法被人类画出;   而PCA可以对高维度的数据进行处理,   并将其降到低维度,   而且也能够告诉我们哪些基因(或者说维度)更有价值;   </p>
<blockquote>
<p>换句话说,   PCA能够对高维度的数据进行排序,   然后告诉我们,   有些维度的数据是很重要的,   有些不是很重要,   所以它们可以忽略;   换到基因这个例子中来,   PCA会告诉我们,   哪些基因是很重要的,   哪些基因不是很重要(或者说可省略);   而我们知道了哪些维度的数据可以省略之后,   就省略他们就好了,   这就达到了降维的效果;   </p>
</blockquote>
<p>然后跟着视频走;   算出两个基因各自的平均值,   就可以找到这些数据在二维空间中的中心点,   然后把坐标轴移动到中心点的位置,   这样就可以用一条线将这些数据拟合到一起;   </p>
<img src="D:/Program%20Files/Typora/img/image-20230228223930528.png" alt="image-20230228223930528" style="zoom:80%;" />

<p>那怎么才能找到这个所谓的拟合度最好的线呢? 首先我们任意画出一条过圆点的直线,   然后将这些数据映射到这条线上,   也就是说二维空间中的每一个数据点都对应于拟合线上的一个点,   而这些点到原点的距离是重要的衡量拟合度的指标;   在PCA中,   这些距离越长,   拟合度越好;   </p>
<blockquote>
<p>视频使用勾股定理来描述投影点到原点的距离可谓是及其详细了,   这里就不再谈了;   只需要记住一点,   拟合线到数据点的垂直距离越小,   数据点对应的映射点到原点的距离就越大;   所以PCA寻找最佳拟合度的方式就是—最大化映射点到原点的距离的平方和;   </p>
<p>然后小总结一下PCA最佳拟合线的步骤:   </p>
<ol>
<li>求得数据在各个维度上的均值,   找到其中心点,   将坐标轴移动到中心点,   使中心点变为坐标轴的原点</li>
<li>画一条通过原点的直线,   将数据点投影到这条直线上,   然后求得所有投影点到原点的距离的平方和,   最后求得这个平方和的最大值,   即找到最佳拟合线;   </li>
</ol>
</blockquote>
<p>大费周章找到的这一条最佳拟合线就是PCA的主成分1;   有主成分1,   肯定就有主成分2和主成分3;   </p>
<p>这一条最佳拟合线可以表示一些讯息,   比如视频中谈到的,   因为这一条线是往x轴倾斜的,   所以”基因1”的重要程度大于”基因2”;   还有,   像视频中说的那样,   为得到1份PC1,   需要4份的”基因1”和1份的”基因2”,   但是这样说其实并不严谨,   应该说4份”基因1”和1份”基因2”可以组成4.12份PC1;   </p>
<img src="D:/Program%20Files/Typora/img/image-20230228230342429.png" alt="image-20230228230342429" style="zoom:80%;" />

<p>所以为了知道1份PC1的组成,   我们需要对上述份数进行归一化;   最终得到的结果为0.97份”基因1”和0.242份”基因2”可以组成1份PC1;   </p>
<p>这样就得到了PC1的单位向量啦! 设PC1的单位向量为<strong>e</strong>,   则<strong>e</strong>=[0.97Gene1,   0.242Gene2];   这玩意儿就是PC1的特征向量 !!</p>
<p>而每个基因前面的系数就被称为载荷得分,   直观理解就是贡献度啦,   再直观理解就是重要程度啦;   </p>
<p>而前面提到的寻找最佳拟合度所使用的投影点的距离平方和就是PC1的特征值 ! (这些个距离平方和除以数据点的数量,   得到的就是方差,   也就是描述数据相对于中心点的离散程度的一个量)</p>
<p>然后求得PC1的垂直线,   就得到了PC2;   而对于PC2,   “基因2”的影响程度是”基因1”的4倍;   同样可以求得PC2的特征向量啦,   特征值啦,   载荷得分啦;   </p>
<p>在得到PC1和PC2的方差之后,   就可以进行主成分的贡献度的比较;   在这个例子中,   PC1的贡献度大于PC2;   </p>
<img src="D:/Program%20Files/Typora/img/image-20230228232407102.png" alt="image-20230228232407102" style="zoom:80%;" />

<p>然后我们就可以对上述过程进行抽象啦!!!</p>
<p>一个m * n规模的矩阵(m行n列)可以这么表示:   </p>
<p>$$<br>M=\left[ \begin{array}{cc|r}<br>X_1\<br>X_2\<br>…\<br>X_m<br>\end{array} \right]<br>$$<br>其中每一个X<sub>i</sub>,   都是一个n列的向量:<br>$$<br>X_i=[a_1,   a_2,   a_3…,   a_n]<br>$$<br>也就是说,   X<sub>i</sub>就是样本,   a<sub>i</sub>就是特征;   </p>
<p>竖着求得每一个特征的平均值,   得到一个平均向量<br>$$<br>\overline{X}=[\overline{a_1},   \overline{a_2},   …,   \overline{a_n}]<br>$$<br>每一个样本减去这一个平均向量(相当于上面将中点移动到坐标轴原点),   得到一个新的矩阵<strong>M’</strong>:<br>$$<br>M’=\left[ \begin{array}{cc|r}<br>X_1’\<br>X_2’\<br>…\<br>X_m’<br>\end{array} \right]<br>$$<br>然后就是求主成分;   </p>
<p>将每个X<sub>i</sub>‘投影到PCA子空间中;   </p>
<blockquote>
<p>这里要注意,   刚才在二维空间中,   是将数据点投影到一条直线上,   也就是说二维空间的两个维度对应直线的一个维度,   所以这个PCA子空间的维度比变量的维度小1;   </p>
</blockquote>
<p>求得每个X<sub>i</sub>‘在PCA子空间中的投影点到原点的距离,   将这些距离平方并相加,   找到其最大值,   除以样本量,   即得到该主成分的特征值;   将这一主成分用向量形式表示出来,   然后归一化,   即得到特征向量;   </p>
<p>像这样找出所有的主成分,   将他们按照方差从大到小进行排列,   取前几个,   即可得到降维后的矩阵,   对上述所说的矩阵进行降维的话,   得到的矩阵就是一个m * r规模的矩阵,   其中r &lt; n;   </p>
<h2 id="PCA解析2"><a href="#PCA解析2" class="headerlink" title="PCA解析2"></a>PCA解析2</h2><p>一组n个变量，这个n可能非常大，可能随随便便就上万，甚至十万百万。想要直接比较两个或多个数据，显然就十分困难。而经过主成分分析，这样一组包含n个变量的数据经过转换变成了一组包含r个变量的数据，其中r&lt;n，这样的过程即是降维，得到即是r个主成分。这r个主成分会依据方差的大小进行排序，称作主成分（PC）1、主成分2、……主成分r。而每个主成分的方差在这一组变量中的总方差中所占的比例，即是主成分的贡献度。通常来说，我们仅考察贡献度前2或者前3的主成分，经过可视化后，即得到了二维或三维PCA散点图。</p>
<p>主成分分析法将变量之间根据相关性进行分解、合并和降维，类似于从n维空间到r维空间的投影。</p>
<p>在分析过程中，PCA可以让我们非常直观地看出各个样本之间的相似性。例如在一张PCA散点图中，数个样本的点聚在一起，那么就说明这几个样本之间的相似性非常高；反之，如果几个样本的点非常分散，则说明这几个样本之间的相似性比较低。例如下图，几个组的样本对应的散点在组内呈现相互聚集的情况，说明组内的重复性比较好，样本数据非常相似，而组间则有较好的区分度。有的时候为了说明组内样本的相似程度，还会用一个椭圆将同一组的样本对应的散点全部囊括起来。</p>
<img src="D:/Program%20Files/Typora/img/image-20230227232415689.png" alt="image-20230227232415689" style="zoom: 50%;" />



<h2 id="OpenCV中的PCA案例"><a href="#OpenCV中的PCA案例" class="headerlink" title="OpenCV中的PCA案例"></a>OpenCV中的PCA案例</h2><p>下面是OpenCV提供的一个pca的使用例子,   是对图像的轮廓使用的PCA,   而其核心就是getOrientation函数,   传入找到的轮廓点集合和图像,   getOrientation函数能够找到轮廓的方向,   并在图像中将其画出;   </p>
<p>PCA算法可以算出其均值,   特征向量和特征值;   在这个例子中,   由于传入getOrientation函数的集合为点集,   转换为矩阵之后的规模,   行数为点集的大小,   列数为2,   也就是横纵坐标;   把这玩意传入PCA中后,   获取该矩阵的均值,   特征值和特征向量,   由于矩阵的规模为(sz,   2),   所以特征值和特征向量只各有两个;   然后该函数通过一系列我看不懂的运算,   使用drawAxis函数将图像的轮廓的方向在图像上画出;   </p>
<p>所以这个例子展示了OpenCV提供的PCA接口应该如何使用,   也展示PCA的用途—降维;   在该例子中,   PCA将传入的规模为(sz,   2)的矩阵降至…额,   总共有两个特征向量,   每个特征向量的只有两个分量,   所以降至(2,   2)的规模,   所以这样看的话,   似乎前面说错了,   PCA算出的特征向量按照行向量来表示的话,   还是有sz个,   但是只取到了前两个,   根据前文的描述,   行向量是通过方差的大小来排列的,   也就是说,   前两个向量的所提供的贡献度是最大的;   </p>
<p>尽管如此,   PCA的具体实现还是要深入pca.cpp才能一探究竟;   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file introduction_to_pca.cpp</span></span><br><span class="line"><span class="comment"> * @brief This program demonstrates how to use OpenCV PCA to extract the orientation of an object</span></span><br><span class="line"><span class="comment"> * @author OpenCV team</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/core.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function declarations</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawAxis</span><span class="params">(Mat&amp;, Point, Point, Scalar, <span class="keyword">const</span> <span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getOrientation</span><span class="params">(<span class="keyword">const</span> vector&lt;Point&gt; &amp;, Mat&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function drawAxis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawAxis</span><span class="params">(Mat&amp; img, Point p, Point q, Scalar colour, <span class="keyword">const</span> <span class="keyword">float</span> scale = <span class="number">0.2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//! [visualization1]</span></span><br><span class="line">    <span class="keyword">double</span> angle = <span class="built_in">atan2</span>( (<span class="keyword">double</span>) p.y - q.y, (<span class="keyword">double</span>) p.x - q.x ); <span class="comment">// angle in radians</span></span><br><span class="line">    <span class="keyword">double</span> hypotenuse = <span class="built_in">sqrt</span>( (<span class="keyword">double</span>) (p.y - q.y) * (p.y - q.y) + (p.x - q.x) * (p.x - q.x));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here we lengthen the arrow by a factor of scale</span></span><br><span class="line">    q.x = (<span class="keyword">int</span>) (p.x - scale * hypotenuse * <span class="built_in">cos</span>(angle));</span><br><span class="line">    q.y = (<span class="keyword">int</span>) (p.y - scale * hypotenuse * <span class="built_in">sin</span>(angle));</span><br><span class="line">    <span class="built_in">line</span>(img, p, q, colour, <span class="number">1</span>, LINE_AA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the arrow hooks</span></span><br><span class="line">    p.x = (<span class="keyword">int</span>) (q.x + <span class="number">9</span> * <span class="built_in">cos</span>(angle + CV_PI / <span class="number">4</span>));</span><br><span class="line">    p.y = (<span class="keyword">int</span>) (q.y + <span class="number">9</span> * <span class="built_in">sin</span>(angle + CV_PI / <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">line</span>(img, p, q, colour, <span class="number">1</span>, LINE_AA);</span><br><span class="line"></span><br><span class="line">    p.x = (<span class="keyword">int</span>) (q.x + <span class="number">9</span> * <span class="built_in">cos</span>(angle - CV_PI / <span class="number">4</span>));</span><br><span class="line">    p.y = (<span class="keyword">int</span>) (q.y + <span class="number">9</span> * <span class="built_in">sin</span>(angle - CV_PI / <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">line</span>(img, p, q, colour, <span class="number">1</span>, LINE_AA);</span><br><span class="line">    <span class="comment">//! [visualization1]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function getOrientation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getOrientation</span><span class="params">(<span class="keyword">const</span> vector&lt;Point&gt; &amp;pts, Mat &amp;img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//! [pca]</span></span><br><span class="line">    <span class="comment">//Construct a buffer used by the pca analysis</span></span><br><span class="line">    <span class="comment">// 生成用于pca分析的矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵大小为轮廓集合的大小</span></span><br><span class="line">    <span class="keyword">int</span> sz = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pts.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成矩阵, 行数为sz, 列数为2</span></span><br><span class="line">    Mat data_pts = <span class="built_in">Mat</span>(sz, <span class="number">2</span>, CV_64F);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置data_pts的具体的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data_pts.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data_pts.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">0</span>) = pts[i].x;</span><br><span class="line">        data_pts.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">1</span>) = pts[i].y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Perform PCA analysis</span></span><br><span class="line">    <span class="comment">// 进行PCA分析, 输出为行矩阵</span></span><br><span class="line">    <span class="comment">// 此项的第二个参数用于协方差矩阵相应值的获取</span></span><br><span class="line">    <span class="function">PCA <span class="title">pca_analysis</span><span class="params">(data_pts, Mat(), PCA::DATA_AS_ROW)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Store the center of the object</span></span><br><span class="line">    <span class="comment">// 存储对象的中心</span></span><br><span class="line">    <span class="comment">// 该点为使用PCA算法算出的平均值的坐标</span></span><br><span class="line">    Point cntr = <span class="built_in">Point</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pca_analysis.mean.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>)),</span><br><span class="line">                      <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pca_analysis.mean.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Store the eigenvalues and eigenvectors</span></span><br><span class="line">    <span class="comment">// 存储使用PCA算法算出的特征向量和特征值</span></span><br><span class="line">    <span class="function">vector&lt;Point2d&gt; <span class="title">eigen_vecs</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">eigen_val</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        eigen_vecs[i] = <span class="built_in">Point2d</span>(pca_analysis.eigenvectors.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">0</span>),</span><br><span class="line">                                pca_analysis.eigenvectors.at&lt;<span class="keyword">double</span>&gt;(i, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        eigen_val[i] = pca_analysis.eigenvalues.at&lt;<span class="keyword">double</span>&gt;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! [pca]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! [visualization]</span></span><br><span class="line">    <span class="comment">// Draw the principal components</span></span><br><span class="line">    <span class="comment">// 画出主成分图</span></span><br><span class="line">    <span class="built_in">circle</span>(img, cntr, <span class="number">3</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">    Point p1 = cntr + <span class="number">0.02</span> * <span class="built_in">Point</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(eigen_vecs[<span class="number">0</span>].x * eigen_val[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(eigen_vecs[<span class="number">0</span>].y * eigen_val[<span class="number">0</span>]));</span><br><span class="line">    Point p2 = cntr - <span class="number">0.02</span> * <span class="built_in">Point</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(eigen_vecs[<span class="number">1</span>].x * eigen_val[<span class="number">1</span>]), <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(eigen_vecs[<span class="number">1</span>].y * eigen_val[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">drawAxis</span>(img, cntr, p1, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">drawAxis</span>(img, cntr, p2, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> angle = <span class="built_in">atan2</span>(eigen_vecs[<span class="number">0</span>].y, eigen_vecs[<span class="number">0</span>].x); <span class="comment">// orientation in radians</span></span><br><span class="line">    <span class="comment">//! [visualization]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> angle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function main</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//! [pre-process]</span></span><br><span class="line">    <span class="comment">// Load image</span></span><br><span class="line">    <span class="comment">//打印提示信息</span></span><br><span class="line">    <span class="function">CommandLineParser <span class="title">parser</span><span class="params">(argc, argv, <span class="string">&quot;&#123;@input | pca_test1.jpg | input image&#125;&quot;</span>)</span></span>;</span><br><span class="line">    parser.<span class="built_in">about</span>( <span class="string">&quot;This program demonstrates how to use OpenCV PCA to extract the orientation of an object.\n&quot;</span> );</span><br><span class="line">    parser.<span class="built_in">printMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取要处理的图像</span></span><br><span class="line">    Mat src = <span class="built_in">imread</span>( samples::<span class="built_in">findFile</span>( parser.get&lt;String&gt;(<span class="string">&quot;@input&quot;</span>) ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if image is loaded successfully</span></span><br><span class="line">    <span class="comment">// 检查图像是否成功获取</span></span><br><span class="line">    <span class="keyword">if</span>(src.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Problem loading image!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示原图像</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;src&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert image to grayscale</span></span><br><span class="line">    <span class="comment">// 将原图像转为灰度图</span></span><br><span class="line">    Mat gray;</span><br><span class="line">    <span class="built_in">cvtColor</span>(src, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert image to binary</span></span><br><span class="line">    <span class="comment">// 通过threshold函数将灰度图转为二值图像! 二值图像保存在bw中</span></span><br><span class="line">    Mat bw;</span><br><span class="line">    <span class="built_in">threshold</span>(gray, bw, <span class="number">50</span>, <span class="number">255</span>, THRESH_BINARY | THRESH_OTSU);</span><br><span class="line">    <span class="comment">//! [pre-process]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! [contours]</span></span><br><span class="line">    <span class="comment">// Find all the contours in the thresholded image</span></span><br><span class="line">    <span class="comment">// 通过findContours函数找到二值图像中的所有轮廓,</span></span><br><span class="line">    <span class="comment">// 获取到的轮廓存入contours中</span></span><br><span class="line">    vector&lt;vector&lt;Point&gt; &gt; contours;</span><br><span class="line">    <span class="built_in">findContours</span>(bw, contours, RETR_LIST, CHAIN_APPROX_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Calculate the area of each contour</span></span><br><span class="line">        <span class="comment">// 计算每条轮廓的轮廓面积</span></span><br><span class="line">        <span class="keyword">double</span> area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ignore contours that are too small or too large</span></span><br><span class="line">        <span class="comment">// 舍弃掉太小和太大的面积</span></span><br><span class="line">        <span class="keyword">if</span> (area &lt; <span class="number">1e2</span> || <span class="number">1e5</span> &lt; area) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw each contour only for visualisation purposes</span></span><br><span class="line">        <span class="comment">// 绘制轮廓, 没有其他目的, 仅为可视化</span></span><br><span class="line">        <span class="built_in">drawContours</span>(src, contours, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the orientation of each shape</span></span><br><span class="line">        <span class="comment">// 查找每个轮廓的方向</span></span><br><span class="line">        <span class="built_in">getOrientation</span>(contours[i], src);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! [contours]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;output&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>剩下还有pca.cpp,   lbph.cpp,   fisherface.cpp,   lda.cpp;   </p>
<h1 id="PCA源码分析"><a href="#PCA源码分析" class="headerlink" title="PCA源码分析"></a>PCA源码分析</h1><p>其实就是设置了一堆的变量,   然后调用别的函数算出协方差矩阵,   再求出特征值和特征向量;   只不过在主成分数量的选取上,   进行了些许甄别;   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据矩阵, 均值矩阵, 行列向量标识, 保留的最大主成分数</span></span><br><span class="line">    PCA &amp;PCA::operator()(InputArray _data, InputArray __mean, <span class="keyword">int</span> flags, <span class="keyword">int</span> maxComponents) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据矩阵与均值矩阵</span></span><br><span class="line">        Mat data = _data.getMat(), _mean = __mean.getMat();</span><br><span class="line">        <span class="keyword">int</span> covar_flags = CV_COVAR_SCALE;</span><br><span class="line">        <span class="keyword">int</span> len, in_count;</span><br><span class="line">        Size mean_sz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断通道是否为1个</span></span><br><span class="line">        CV_Assert(data.channels() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果输入的矩阵为列矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; CV_PCA_DATA_AS_COL) &#123;</span><br><span class="line">            len = data.rows;</span><br><span class="line">            in_count = data.cols;</span><br><span class="line">            covar_flags |= CV_COVAR_COLS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 均值向量规模为(1, len)</span></span><br><span class="line">            mean_sz = Size(<span class="number">1</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果数据矩阵为行矩阵(一般都为行矩阵)</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取数据维度</span></span><br><span class="line">            len = data.cols;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取样本量</span></span><br><span class="line">            in_count = data.rows;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置数据矩阵为行向量形式</span></span><br><span class="line">            covar_flags |= CV_COVAR_ROWS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 均值向量的规模为(len, 1), 也就是len行1列, len为数据维度</span></span><br><span class="line">            mean_sz = Size(len, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据维度和样本量之间的较小值, 其实下面这几行都是为了确定主成分数</span></span><br><span class="line">        <span class="keyword">int</span> count = std::min(len, in_count), out_count = count;</span><br><span class="line">        <span class="comment">// 防止最大主成分数超过maxComponents</span></span><br><span class="line">        <span class="keyword">if</span> (maxComponents &gt; <span class="number">0</span>)</span><br><span class="line">            out_count = std::min(count, maxComponents);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &quot;scrambled&quot; way to compute PCA (when cols(A)&gt;rows(A)):</span></span><br><span class="line">        <span class="comment">// B = A&#x27;A; B*x=b*x; C = AA&#x27;; C*y=c*y -&gt; AA&#x27;*y=c*y -&gt; A&#x27;A*(A&#x27;*y)=c*(A&#x27;*y) -&gt; c = b, x=A&#x27;*y</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据维度len超过样本量in_count, 则使用CV_COVAR_NORMAL, 否则则使用CV_COVAR_SCRAMBLED</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= in_count)</span><br><span class="line">            covar_flags |= CV_COVAR_NORMAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置显示范围的精度, 如果大于浮点数精度, 则使用原数据矩阵的精度</span></span><br><span class="line">        <span class="comment">// 实际上比CV_32F大的就只有CV_64F了; 所以这里应该是如果数据矩阵使用64位精度, 则ctype保留原精度</span></span><br><span class="line">        <span class="comment">// 否则统一使用CV_32F;</span></span><br><span class="line">        <span class="keyword">int</span> ctype = std::max(CV_32F, data.depth());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建均值数组</span></span><br><span class="line">        mean.create(mean_sz, ctype);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建协方差数组, 规模为(count, count) count为数据维度与样本量中的较小值</span></span><br><span class="line">        <span class="comment">// 精度类型与数据矩阵的精度一致</span></span><br><span class="line">        <span class="function">Mat <span class="title">covar</span><span class="params">(count, count, ctype)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果_mean不为空, 则使用_mean作为均值向量, 并设置其标志位;</span></span><br><span class="line">        <span class="keyword">if</span> (!_mean.empty()) &#123;</span><br><span class="line">            CV_Assert(_mean.size() == mean_sz);</span><br><span class="line">            _mean.convertTo(mean, ctype);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cv::CalcCovarMatrix的标志，不计算即均值向量, 改用输入向量(用于按部分计算协方差矩阵)</span></span><br><span class="line">            covar_flags |= CV_COVAR_USE_AVG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算协方差矩阵</span></span><br><span class="line">        <span class="comment">// 结果保存在covar中, 写OpenCV就喜欢这么搞, 就是不喜欢函数有返回值捏</span></span><br><span class="line">        calcCovarMatrix(data, covar, mean, covar_flags, ctype);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算协方差矩阵的特征值和特征向量</span></span><br><span class="line">        eigen(covar, eigenvalues, eigenvectors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有采用CV_COVAR_NORMAL形式来计算的协方差(就是采用CV_COVAR_SCRAMBLED形式)</span></span><br><span class="line">        <span class="keyword">if</span> (!(covar_flags &amp; CV_COVAR_NORMAL)) &#123;</span><br><span class="line">            <span class="comment">// CV_PCA_DATA_AS_ROW: cols(A)&gt;rows(A). x=A&#x27;*y -&gt; x&#x27;=y&#x27;*A</span></span><br><span class="line">            <span class="comment">// CV_PCA_DATA_AS_COL: rows(A)&gt;cols(A). x=A&#x27;&#x27;*y -&gt; x&#x27;=y&#x27;*A&#x27;</span></span><br><span class="line">            Mat tmp_data, tmp_mean = repeat(mean, data.rows / mean.rows, data.cols / mean.cols);</span><br><span class="line">            <span class="keyword">if</span> (data.type() != ctype || tmp_mean.data == mean.data) &#123;</span><br><span class="line">                data.convertTo(tmp_data, ctype);</span><br><span class="line">                subtract(tmp_data, tmp_mean, tmp_data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                subtract(data, tmp_mean, tmp_mean);</span><br><span class="line">                tmp_data = tmp_mean;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">Mat <span class="title">evects1</span><span class="params">(count, len, ctype)</span></span>;</span><br><span class="line">            gemm(eigenvectors, tmp_data, <span class="number">1</span>, Mat(), <span class="number">0</span>, evects1,</span><br><span class="line">                 (flags &amp; CV_PCA_DATA_AS_COL) ? CV_GEMM_B_T : <span class="number">0</span>);</span><br><span class="line">            eigenvectors = evects1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// normalize eigenvectors</span></span><br><span class="line">            <span class="comment">// 特征向量的归一化</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; out_count; i++) &#123;</span><br><span class="line">                Mat vec = eigenvectors.row(i);</span><br><span class="line">                normalize(vec, vec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据维度count超过主成分数量out_count, 则取前out_count个特征向量和特征值</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; out_count) &#123;</span><br><span class="line">            <span class="comment">// use clone() to physically copy the data and thus deallocate the original matrices</span></span><br><span class="line">            eigenvalues = eigenvalues.rowRange(<span class="number">0</span>, out_count).clone();</span><br><span class="line">            eigenvectors = eigenvectors.rowRange(<span class="number">0</span>, out_count).clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>在PCA中,   协方差矩阵的计算公式如下。注意在这个计算公式中，矩阵的转置运算符被放到了第一个矩阵之上，对于同样的n * m矩阵，计算得到的是尺寸为m * m协方差矩阵。在一些特定场景下，如对向量元素较长的样本数据计算快速主成分分析(PCA)时会使用这种技术，一个应用实例就是人脸识别的特征脸算法。</p>
<img src="D:/Program%20Files/Typora/img/image-20230301212821018.png" alt="image-20230301212821018" style="zoom:80%;" />

<img src="D:/Program%20Files/Typora/img/webp.webp" alt="img" style="zoom: 67%;" />

<p>在core.cpp中,   在对于n行 * m列的输入样本矩阵而言，当设置<code>cv::COVAR_SCALE</code>时，计算的协方差矩阵会被缩放，缩放系数等于1.0/m，但是当<code>cv::COVAR_SCRAMBLED</code>被启用时，缩放系数则等于1.0/n，可以理解为1/单组随机变量个长度。</p>
<p>该函数的输入输出函数中元素的基本数据类型都应该是相同的浮点数类型，协方差矩阵的尺寸根据选择的是标准<code>cv::COVAR_NORMAL</code>还是反转<code>cv::COVAR_SCRAMBLED</code>的计算策略相应为n * n和m * m。</p>
<p>而cv::calcCovarMatrix函数中的flags,   其实是一种类似于位图的用法,   flags为int类型,   而其他的枚举类像CV_COVAR_ROWS、CV_COVAR_USE_AVG等等,   应该都是int类型;   当需要某一个参数的时候,   只需要让flags同对应的枚举类相与,   即可保留这一信息,   而传递到cv::calcCovarMatrix函数中后,   就可以通过将flags的对应位同相应的枚举类相与,   即可获取对应的信息;   </p>
<p>在matmul.dispatch.cpp中包含cv::calcCovarMatrix函数的实现,   </p>
<img src="D:/Program%20Files/Typora/img/image-20230303184317695.png" alt="image-20230303184317695" style="zoom:80%;" />

<p>如果使用normal来进行协方差矩阵的计算<br>$$<br>\sum^{2}_{NORMAL}=</p>
<p>z<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{0,   1}&amp;v_{0,   2}&amp;…&amp; v_{0,   n}\<br>v_{1,   0}&amp;v_{1,   1}&amp;v_{1,   2}&amp;…&amp; v_{1,   n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{m,   0}&amp;v_{m,   1}&amp;v_{m,   2}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]</p>
<p>*<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{0,   1}&amp;v_{0,   2}&amp;…&amp; v_{0,   n}\<br>v_{1,   0}&amp;v_{1,   1}&amp;v_{1,   2}&amp;…&amp; v_{1,   n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{m,   0}&amp;v_{m,   1}&amp;v_{m,   2}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]^T<br>$$</p>
<p>$$<br>\begin{align*}<br>&amp;aTa=true,   使用MulTransposedR,   矩阵的转置乘原矩阵\\<br>&amp;\sum^{2}_{NORMAL}=</p>
<p>z<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{1,   0}&amp;v_{2,   0}&amp;…&amp; v_{m,   0}\<br>v_{0,   1}&amp;v_{1,   1}&amp;v_{2,   1}&amp;…&amp; v_{m,   1}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{0,   n}&amp;v_{1,   n}&amp;v_{2,   n}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]</p>
<p>*<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{0,   1}&amp;v_{0,   2}&amp;…&amp; v_{0,   n}\<br>v_{1,   0}&amp;v_{1,   1}&amp;v_{1,   2}&amp;…&amp; v_{1,   n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{m,   0}&amp;v_{m,   1}&amp;v_{m,   2}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]\\</p>
<p>&amp;(n * m) * (m * n)\\<br>&amp;从代码层面表现出来就是原矩阵的列乘列,   \<br>&amp;比如,   第一列<em>第一列=第一个元素<br>\end{align</em>}<br>$$</p>
<p>$$<br>\begin{align*}<br>&amp;aTa=false,   使用MulTransposedL,   原矩阵乘矩阵的转置\\<br>&amp;\sum^{2}_{NORMAL}=</p>
<p>z<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{0,   1}&amp;v_{0,   2}&amp;…&amp; v_{0,   n}\<br>v_{1,   0}&amp;v_{1,   1}&amp;v_{1,   2}&amp;…&amp; v_{1,   n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{m,   0}&amp;v_{m,   1}&amp;v_{m,   2}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]</p>
<p>*<br>\left[ \begin{array}{cc}<br>v_{0,   0}&amp;v_{1,   0}&amp;v_{2,   0}&amp;…&amp; v_{m,   0}\<br>v_{0,   1}&amp;v_{1,   1}&amp;v_{2,   1}&amp;…&amp; v_{m,   1}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>v_{0,   n}&amp;v_{1,   n}&amp;v_{2,   n}&amp;…&amp; v_{m,   n}\<br>\end{array} \right]\\</p>
<p>&amp;(m * n)    *    (n * m)\\<br>&amp; 从代码层面表现出来就是原矩阵的行乘行,   \<br>&amp;比如,   第一行<em>第一行=第一个元素<br>\end{align</em>}<br>$$</p>
<img src="D:/Program%20Files/Typora/img/image-20230303193809910.png" alt="image-20230303193809910" style="zoom:80%;" />

<p>如果aTa为真, 则使用MulTransposedR, 也就是矩阵的转置乘原矩阵<br>如果aTa为假, 则使用MulTransposedL, 也就是原矩阵乘矩阵的转置</p>
<p>MulTransposedR的乘积方式为<img src="D:/Program%20Files/Typora/img/image-20230303201848970.png" alt="image-20230303201848970" style="zoom:80%;" /></p>
<hr>
<p>到此为止总算是把pca.cpp的核心代码及其依赖函数分析完了,   剩下就是填写整体流程,   以及分析SIMD的优点了;   哦对了,   还有gemm的分析,   为啥100之后它要快一点呀?</p>
<p>找到了gemm32fc的实现！在F:\java\MStudy\opencv\sources\modules\core\src\matmul.simd.hpp里</p>
<p>防止越界的操作:   由于是4个4个的读取,   而且指针是指向4个元素的头元素的,   如果矩阵列数不为4的倍数,   则当j当达最后一个4元素模块的时候,   就会发生越界,   所以在最初的循环中,   要减掉元素矩阵的个数要减掉4,   然后另起一个循环处理最后的几个元素;   </p>
<h2 id="gemm分析"><a href="#gemm分析" class="headerlink" title="gemm分析"></a>gemm分析</h2><p>void gemm(InputArray matA, InputArray matB, double alpha, InputArray matC,<br>                     double beta, OutputArray _matD, int flags)</p>
<p>alpha为缩放尺度,   beta为src3的权重,   flags为对哪个矩阵进行转置(矩阵有matA,   matB和matC)</p>
<img src="D:/Program%20Files/Typora/img/image-20230304153828782.png" alt="image-20230304153828782" style="zoom:80%;" />

<p>假设我们已经得到了协方差矩阵$C$，其奇异值分解为： $$ C = U \Sigma V^T $$ 其中，$U$和$V$是正交矩阵，$\Sigma$是一个对角矩阵，其对角线上的元素称为奇异值。 由于协方差矩阵是实对称矩阵，因此它的特征向量可以通过奇异值分解来计算。具体地说，我们可以使用以下公式来计算协方差矩阵的特征向量： $$ \mathbf{v}_i = \frac{1}{\sqrt{n-1}\sigma_i} C \mathbf{u}_i $$ 其中，$\mathbf{u}_i$和$\mathbf{v}_i$分别是奇异值分解中左奇异向量和右奇异向量的第$i$列，$\sigma_i$是$\Sigma$中第$i$个奇异值。 需要注意的是，在实际应用中，我们通常会对奇异值进行截断或者使用增量SVD等技术来加速计算过程，并且可以处理大型或高维数据集。</p>
<p>特征值分解法是另一种常用的方法来获取协方差矩阵的特征向量。假设我们已经得到了协方差矩阵$C$，其特征值分解为： $$ C = Q \Lambda Q^{-1} $$ 其中，$Q$是特征向量组成的正交矩阵，$\Lambda$是对角矩阵，其对角线上的元素为特征值。 由于协方差矩阵是实对称矩阵，因此它的特征向量可以通过特征值分解来计算。具体地说，我们可以使用以下公式来计算协方差矩阵的特征向量： $$ \mathbf{v}_i = Q \mathbf{e}_i $$ 其中，$\mathbf{e}_i$是单位向量，表示第$i$个特征值所对应的方向。 特征值分解法获取协方差矩阵的时间复杂度主要取决于求解特征值和特征向量的算法。一般而言，使用传统方法（如幂迭代、QR迭代等）求解特征值和特征向量的时间复杂度为$O(n^3)$。但是，在实际应用中，我们通常会使用更高效的算法（如雅可比迭代、Lanczos迭代等）来加速计算过程，并且可以处理大型或高维数据集。这些算法的时间复杂度通常为$O(kn^2)$或更低，其中$k$是特征值的数量。</p>
<p>传统的方法求解特征值和特征向量的时间复杂度为$O(n^3)$，主要是因为这些方法需要进行矩阵乘法和矩阵-向量乘法等基本运算，而这些运算的时间复杂度都是$O(n^2)$。因此，对于一个$n \times n$的矩阵，传统的方法需要进行$n$次迭代，每次迭代都需要进行一次矩阵乘法和一次矩阵-向量乘法，因此总的时间复杂度为$O(n^3)$。 具体来说，传统的方法包括幂迭代、QR迭代等。其中，幂迭代是最简单、最直观的求解特征值和特征向量的方法之一。它通过不断地对一个初始向量进行矩阵乘法和归一化操作来逼近协方差矩阵的最大特征值和对应的特征向量。但是，幂迭代只能求解最大特征值和对应的特征向量，并且收敛速度较慢。 QR迭代是另一种常用的求解特征值和特征向量的方法。它通过将协方差矩阵分解为正交矩阵$Q$和上三角矩阵$R$的乘积来逼近协方差矩阵的所有特征值和对应的特征向量。QR迭代可以同时求解所有特征值和特征向量，并且收敛速度较快。但是，QR迭代的计算复杂度较高，主要是因为每次迭代都需要进行一次QR分解，其时间复杂度为$O(n^3)$。</p>
<p>JacobiSVD类的时间复杂度主要取决于矩阵的大小和精度要求。具体来说，对于一个$m \times n$的实数或复数矩阵，JacobiSVD类的时间复杂度为$O(\min(mn^2, m^2n))$。</p>
<p>具体来说，对于一个$m \times n$的实数或复数矩阵，JacobiSVD类的时间复杂度为$O(\min(mn^2, m^2n))$。其中，当$m \geq n$时，JacobiSVD类的时间复杂度为$O(mn^2)$；当$m &lt; n$时，JacobiSVD类的时间复杂度为$O(m^2n)$。</p>
<blockquote>
<p>所谓奇异值求解特征向量，就是在归一化之后，不断地调整这个超平面，依据所有的点到这个超平面的距离平方和大小进行排序，该距离平方和就是特征值，而距离平方和对应的基就是特征向量。</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/04/26/gong-wu-yuan-kao-shi/wu-shi-ji-chu/3-zi-liao-003/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">资料003</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PCA"><span class="toc-text">PCA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PCA%E8%A7%A3%E6%9E%901"><span class="toc-text">PCA解析1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCA%E8%A7%A3%E6%9E%902"><span class="toc-text">PCA解析2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenCV%E4%B8%AD%E7%9A%84PCA%E6%A1%88%E4%BE%8B"><span class="toc-text">OpenCV中的PCA案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PCA%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">PCA源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gemm%E5%88%86%E6%9E%90"><span class="toc-text">gemm分析</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>