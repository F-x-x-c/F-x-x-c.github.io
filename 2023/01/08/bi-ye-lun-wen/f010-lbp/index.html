<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Aegis | Aegis</title><meta name="author" content="Deng"><meta name="copyright" content="Deng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LBP特征LBP特征的描述​    在3 * 3的九宫格中,   以中心像素为阈值,   若其他八个像素中有灰度值大于中心像素的灰度值,   则该像素点的灰度值置1,   否则置0;   这样处理之后,   旁边八个像素点的灰度值只可能是0或者1;   从九宫格的左上角开始收集灰度值,   形成01序列,   该01序列的十进制描述就是中心像素的LBP值;    LBP的演进​    由于经典LB">
<meta property="og:type" content="article">
<meta property="og:title" content="Aegis">
<meta property="og:url" content="http://example.com/2023/01/08/bi-ye-lun-wen/f010-lbp/index.html">
<meta property="og:site_name" content="Aegis">
<meta property="og:description" content="LBP特征LBP特征的描述​    在3 * 3的九宫格中,   以中心像素为阈值,   若其他八个像素中有灰度值大于中心像素的灰度值,   则该像素点的灰度值置1,   否则置0;   这样处理之后,   旁边八个像素点的灰度值只可能是0或者1;   从九宫格的左上角开始收集灰度值,   形成01序列,   该01序列的十进制描述就是中心像素的LBP值;    LBP的演进​    由于经典LB">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-01-08T06:58:48.321Z">
<meta property="article:modified_time" content="2023-02-21T01:22:41.431Z">
<meta property="article:author" content="Deng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/08/bi-ye-lun-wen/f010-lbp/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Aegis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-21 09:22:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Aegis" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.picsum.photos/id/145/4288/2848.jpg?hmac=UkhcwQUE-vRBFXzDN1trCwWigpm7MXG5Bl5Ji103QG4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">137</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aegis</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-created" datetime="2023-01-08T06:58:48.321Z" title=" 2023-01-08 14:58:48">2023-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label"></span><time class="post-meta-date-updated" datetime="2023-02-21T01:22:41.431Z" title=" 2023-02-21 09:22:41">2023-02-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="LBP特征"><a href="#LBP特征" class="headerlink" title="LBP特征"></a>LBP特征</h1><h2 id="LBP特征的描述"><a href="#LBP特征的描述" class="headerlink" title="LBP特征的描述"></a>LBP特征的描述</h2><p>​    在3 * 3的九宫格中,   以中心像素为阈值,   若其他八个像素中有灰度值大于中心像素的灰度值,   则该像素点的灰度值置1,   否则置0;   这样处理之后,   旁边八个像素点的灰度值只可能是0或者1;   从九宫格的左上角开始收集灰度值,   形成01序列,   该01序列的十进制描述就是中心像素的LBP值;   </p>
<h2 id="LBP的演进"><a href="#LBP的演进" class="headerlink" title="LBP的演进"></a>LBP的演进</h2><p>​    由于经典LBP算子只覆盖了一个固定半径范围内的小区域,   不能满足不同尺寸和不同纹理的需要,   所以Ojala提出圆形LBP算子,   该算子允许半径为R的圆形领域内有任意多的采样点(像素点);   </p>
<p>​    初始圆形LBP算子,   由于旋转过后LBP值会发生改变,   所以提出,   在边像素点与中心像素点对比过后收集01字符时,   通过选取不同的开头字符得到不同的值,   取这些值的最小值作为LBP值,   以提供旋转不变性;   </p>
<p>​    由于最终得到的LBP值的二进制表示形式的位数=所选区域内的像素点的个数,   随着像素点的增加,   二进制的位数也在增加;   设像素点的数量为p,   则LBP值可能的二进制取值为2<sup>p</sup>;   当使用直方图来表示图像时,   较多的二进制取值会造成直方图过于稀疏,   数量过大;   所以Ojala对LBP值的取值可能进行了减少,   由于大多数LBP值的二进制表示形式都只存在不多于两次的01跳变,   所以可以把LBP值的取值可能进行分类,   对于不多于两次跳变的取值可能,   不改变它的值,   多于两次跳变的全部规定为另一个值;   这样能够最大限度地保留图像地信息,   并且极大限度地降低了特征向量的维度;   </p>
<h2 id="LBP特征向量的提取"><a href="#LBP特征向量的提取" class="headerlink" title="LBP特征向量的提取"></a>LBP特征向量的提取</h2><ol>
<li>将图像划分为16 * 16的区域;   </li>
<li>对每个区域的每一个元素进行边像素点与中心像素点的对比大则取1,   小则取0,   顺时针取得边像素点的二进制序列,   将它设为中心像素点的LBP值;   </li>
<li>计算每一个区域的直方图,   并对直方图进行归一化处理;   </li>
<li>将每一个区域的直方图连接为一个特征向量,   即得到整幅图的LBP纹理特征向量;   </li>
</ol>
<h2 id="OpenCV中LBP算法的实现"><a href="#OpenCV中LBP算法的实现" class="headerlink" title="OpenCV中LBP算法的实现"></a>OpenCV中LBP算法的实现</h2><p>把OpenCV的包导入Java的IDE中去后,   在追那些方法的实现方法时,   也碰到了追JVM源码时的问题—追到底层后发现,   Java中使用native封装了底层方法的实现,   也就是说那些方法在Java中根本没有,   只有深入JVM的c++实现中去查看对应的实现代码,   OpenCV的源码也同样如此;   </p>
<img src="D:/Program%20Files/Typora/img/image-20230108164437610.png" alt="image-20230108164437610" style="zoom: 67%;" />

<ol>
<li><p>旧版本OpenCV中的LBP算法实现</p>
<p>​    就像上面所说的那样,   通过八个边像素点来确定中心像素点的LBP值,   相比于算法思路而言,   算法实现没有进行任何优化,   所以非常好看懂;   </p>
<p>​    时间复杂度仅需考虑核心循环,   循环内部为O(1),   所以LBP的时间复杂度为O(M),   M为像素点的个数;   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于旧版本的opencv的LBP算法opencv1.0  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LBP</span> <span class="params">(IplImage *src,IplImage *dst)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;  </span><br><span class="line">    CvScalar s;  </span><br><span class="line">  </span><br><span class="line">    IplImage * temp = cvCreateImage(cvGetSize(src), IPL_DEPTH_8U,<span class="number">1</span>);  </span><br><span class="line">    uchar *data=(uchar*)src-&gt;imageData;  </span><br><span class="line">    <span class="keyword">int</span> step=src-&gt;widthStep;  <span class="comment">// 图像位宽</span></span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;step&quot;</span>&lt;&lt;step&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;src-&gt;height-<span class="number">1</span>;i++)  </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;src-&gt;width-<span class="number">1</span>;j++)  </span><br><span class="line">      &#123;  </span><br><span class="line">          <span class="keyword">int</span> sum=<span class="number">0</span>;  </span><br><span class="line">          <span class="keyword">if</span>(data[(i-<span class="number">1</span>)*step+j-<span class="number">1</span>]&gt;data[i*step+j])  <span class="comment">// 左上角</span></span><br><span class="line">            tmp[<span class="number">0</span>]=<span class="number">1</span>;  </span><br><span class="line">            </span><br><span class="line">          <span class="keyword">if</span>(data[i*step+(j-<span class="number">1</span>)]&gt;data[i*step+j])   <span class="comment">// 左侧</span></span><br><span class="line">            tmp[<span class="number">1</span>]=<span class="number">1</span>;  </span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span>(data[(i+<span class="number">1</span>)*step+(j-<span class="number">1</span>)]&gt;data[i*step+j])  <span class="comment">// 左下角</span></span><br><span class="line">            tmp[<span class="number">2</span>]=<span class="number">1</span>;  </span><br><span class="line">           </span><br><span class="line">          <span class="keyword">if</span> (data[(i+<span class="number">1</span>)*step+j]&gt;data[i*step+j])  <span class="comment">// 下侧</span></span><br><span class="line">            tmp[<span class="number">3</span>]=<span class="number">1</span>;  </span><br><span class="line">       </span><br><span class="line">          <span class="keyword">if</span> (data[(i+<span class="number">1</span>)*step+(j+<span class="number">1</span>)]&gt;data[i*step+j])  <span class="comment">// 右下角</span></span><br><span class="line">            tmp[<span class="number">4</span>]=<span class="number">1</span>;  </span><br><span class="line">            </span><br><span class="line">          <span class="keyword">if</span>(data[i*step+(j+<span class="number">1</span>)]&gt;data[i*step+j])  <span class="comment">// 右侧</span></span><br><span class="line">            tmp[<span class="number">5</span>]=<span class="number">1</span>;  </span><br><span class="line">           </span><br><span class="line">          <span class="keyword">if</span>(data[(i-<span class="number">1</span>)*step+(j+<span class="number">1</span>)]&gt;data[i*step+j])  <span class="comment">// 右上角</span></span><br><span class="line">            tmp[<span class="number">6</span>]=<span class="number">1</span>;  </span><br><span class="line">           </span><br><span class="line">          <span class="keyword">if</span>(data[(i-<span class="number">1</span>)*step+j]&gt;data[i*step+j])  <span class="comment">// 上侧</span></span><br><span class="line">            tmp[<span class="number">7</span>]=<span class="number">1</span>;  </span><br><span class="line">             </span><br><span class="line">          <span class="comment">//计算LBP编码  </span></span><br><span class="line">            s.val[<span class="number">0</span>]=(tmp[<span class="number">0</span>]*<span class="number">1</span>+tmp[<span class="number">1</span>]*<span class="number">2</span>+tmp[<span class="number">2</span>]*<span class="number">4</span>+tmp[<span class="number">3</span>]*<span class="number">8</span>+tmp[<span class="number">4</span>]*<span class="number">16</span>+tmp[<span class="number">5</span>]*<span class="number">32</span>+tmp[<span class="number">6</span>]*<span class="number">64</span>+tmp[<span class="number">7</span>]*<span class="number">128</span>);  </span><br><span class="line">            cvSet2D(dst,i,j,s);<span class="comment">//写入LBP图像  </span></span><br><span class="line">      &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>圆形LBP算子实现</p>
<p>​    首先根据输入参数对输出数组进行内存分配;   然后开始遍历取样点,   进行LBP值的计算,   通过极坐标参数方程获取当前采样点的直角坐标x和y,   分别对其进行向上和向下取整,   得到四个值,   算出这四个值的插值权重,   然后开始计算该点的LBP值;   先计算边像素点的权重和,   也就是t,   当t&gt;src(i,   j)或者当它们之间的差值小于系统提供的无穷小值ε时(也就是t&gt;=src(i,   j)),   那一大堆判断条件的值为1,   也就是进行1&lt;&lt;n的移位操作,   也就是计算当前边像素点的二进制权重,   然后加到中心像素点的LBP值当中;   (这一点以我的功力,   不认真看还真看不出来 ╮(￣▽￣)╭</p>
<p>​    圆形LBP算子对代码进行了些许常数时间上的优化;   (估计是搞算法竞赛的人写的)</p>
<p>​    时间复杂度:   外层for循环的迭代次数为样本点的个数;   对于内层的那个嵌套for循环,   设半径为R,   图像宽H,   图像长L,   考虑H与L都远远大于LBP半径R,   所以嵌套for循环时间复杂度为O(N),   N为像素点个数,   所以整体的时间复杂度为O(M * N),   M为样本点个数;   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src为输入图像，dst为输出图像，radius为半径，neighbor为计算当前点LBP所需的邻域像素点数即样本点个数</span></span><br><span class="line">template &lt;typename _Tp&gt; <span class="keyword">static</span> <span class="comment">// 模板函数，根据不同的原始数据类型得到不同的结果</span></span><br><span class="line"><span class="function">inline <span class="keyword">void</span> <span class="title">elbp_</span><span class="params">(InputArray _src, OutputArray _dst, <span class="keyword">int</span> radius, <span class="keyword">int</span> neighbors)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//get matrices</span></span><br><span class="line">    Mat src = _src.getMat();</span><br><span class="line">    <span class="comment">// allocate memory for result</span></span><br><span class="line">    _dst.create(src.rows-<span class="number">2</span>*radius, src.cols-<span class="number">2</span>*radius, CV_32SC1);</span><br><span class="line">    Mat dst = _dst.getMat();</span><br><span class="line">    <span class="comment">// zero</span></span><br><span class="line">    dst.setTo(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;neighbors; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sample points 获取当前采样点</span></span><br><span class="line">        <span class="keyword">float</span> x = static_cast&lt;<span class="keyword">float</span>&gt;(-radius) * sin(<span class="number">2.0</span>*CV_PI*n/static_cast&lt;<span class="keyword">float</span>&gt;(neighbors));</span><br><span class="line">        <span class="keyword">float</span> y = static_cast&lt;<span class="keyword">float</span>&gt;(radius) * cos(<span class="number">2.0</span>*CV_PI*n/static_cast&lt;<span class="keyword">float</span>&gt;(neighbors));</span><br><span class="line">        <span class="comment">// relative indices 下取整和上取整</span></span><br><span class="line">        <span class="keyword">int</span> fx = static_cast&lt;<span class="keyword">int</span>&gt;(floor(x)); <span class="comment">// 向下取整</span></span><br><span class="line">        <span class="keyword">int</span> fy = static_cast&lt;<span class="keyword">int</span>&gt;(floor(y));</span><br><span class="line">        <span class="keyword">int</span> cx = static_cast&lt;<span class="keyword">int</span>&gt;(ceil(x));  <span class="comment">// 向上取整</span></span><br><span class="line">        <span class="keyword">int</span> cy = static_cast&lt;<span class="keyword">int</span>&gt;(ceil(y));</span><br><span class="line">        <span class="comment">// fractional part 小数部分</span></span><br><span class="line">        <span class="keyword">float</span> tx = x - fx;</span><br><span class="line">        <span class="keyword">float</span> ty = y - fy;</span><br><span class="line">        <span class="comment">// set interpolation weights 设置四个点的插值权重</span></span><br><span class="line">        <span class="keyword">float</span> w1 = (<span class="number">1</span> - tx) * (<span class="number">1</span> - ty);</span><br><span class="line">        <span class="keyword">float</span> w2 =      tx  * (<span class="number">1</span> - ty);</span><br><span class="line">        <span class="keyword">float</span> w3 = (<span class="number">1</span> - tx) *      ty;</span><br><span class="line">        <span class="keyword">float</span> w4 =      tx  *      ty;</span><br><span class="line">        <span class="comment">// iterate through your data 循环处理图像数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=radius; i &lt; src.rows-radius;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=radius;j &lt; src.cols-radius;j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// calculate interpolated value 计算插值，t表示四个点的权重和</span></span><br><span class="line">                <span class="keyword">float</span> t = w1*src.at&lt;_Tp&gt;(i+fy,j+fx) + </span><br><span class="line">w2*src.at&lt;_Tp&gt;(i+fy,j+cx) + </span><br><span class="line">w3*src.at&lt;_Tp&gt;(i+cy,j+fx) + </span><br><span class="line">w4*src.at&lt;_Tp&gt;(i+cy,j+cx);</span><br><span class="line">                <span class="comment">// floating point precision, so check some machine-dependent epsilon</span></span><br><span class="line">                <span class="comment">// std::numeric_limits&lt;float&gt;::epsilon()=1.192092896e-07F</span></span><br><span class="line">                dst.at&lt;<span class="keyword">int</span>&gt;(i-radius,j-radius) += ((t &gt; src.at&lt;_Tp&gt;(i,j)) || </span><br><span class="line">                            (std::abs(t-src.at&lt;_Tp&gt;(i,j)) &lt; std::numeric_limits&lt;<span class="keyword">float</span>&gt;::epsilon())) &lt;&lt; n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部接口，根据不同的数据类型调用模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">elbp</span><span class="params">(InputArray src, OutputArray dst, <span class="keyword">int</span> radius, <span class="keyword">int</span> neighbors)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type = src.type();</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CV_8SC1:   elbp_&lt;<span class="keyword">char</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_8UC1:   elbp_&lt;unsigned <span class="keyword">char</span>&gt;(src, dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_16SC1:  elbp_&lt;<span class="keyword">short</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_16UC1:  elbp_&lt;unsigned <span class="keyword">short</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_32SC1:  elbp_&lt;<span class="keyword">int</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_32FC1:  elbp_&lt;<span class="keyword">float</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_64FC1:  elbp_&lt;<span class="keyword">double</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        string error_msg = format(<span class="string">&quot;Using Circle Local Binary Patterns for feature extraction only works                                     on single-channel images (given %d). Please pass the image data as a grayscale image!&quot;</span>, type);</span><br><span class="line">        CV_Error(CV_StsNotImplemented, error_msg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Mat cv::elbp(InputArray src, <span class="keyword">int</span> radius, <span class="keyword">int</span> neighbors) &#123;</span><br><span class="line">    Mat dst;</span><br><span class="line">    elbp(src, dst, radius, neighbors);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol>
<li><p>复习线性代数相关知识;   </p>
</li>
<li><p>学习计算机视觉相关知识,   包括各种基本概念, 滤波, 图像的平移旋转等等;   </p>
</li>
<li><p>学习在Java环境中使用OpenCV,   包括图像变换,   图像滤波,   图像的腐蚀与膨胀,   以及图像的边缘检测(<a target="_blank" rel="noopener" href="http://101.43.150.129/img/Graduation_Design/F008_bianYuanJianCe.pdf">http://101.43.150.129/img/Graduation_Design/F008_bianYuanJianCe.pdf</a>);   </p>
</li>
<li><p>使用Java+OpenCV完成基本的图像人脸检测(<a target="_blank" rel="noopener" href="http://101.43.150.129/img/Graduation_Design/F009_FaceRecognize.pdf">http://101.43.150.129/img/Graduation_Design/F009_FaceRecognize.pdf</a>)</p>
</li>
<li><p>学习LBP特征,   并阅读OpenCV所实现的LBP算法之源码(<a target="_blank" rel="noopener" href="http://101.43.150.129/img/Graduation_Design/F010_LBP.pdf">http://101.43.150.129/img/Graduation_Design/F010_LBP.pdf</a>)</p>
</li>
<li><p>对(网上找的那个能跑的通的)人脸识别考勤系统代码进行系统架构分析(<a target="_blank" rel="noopener" href="http://101.43.150.129/img/Graduation_Design/F011_SystemSourceCodeAnalizing.pdf">http://101.43.150.129/img/Graduation_Design/F011_SystemSourceCodeAnalizing.pdf</a>)<br><del>7. 我的云主机要过期了(大哭)</del></p>
</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/08/gong-wu-yuan-kao-shi/1-pan-duan-tui-li-003-ding-yi/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2023/01/07/bi-ye-lun-wen/f009-ren-lian-jian-ce/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LBP%E7%89%B9%E5%BE%81"><span class="toc-text">LBP特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LBP%E7%89%B9%E5%BE%81%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text">LBP特征的描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LBP%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-text">LBP的演进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LBP%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E7%9A%84%E6%8F%90%E5%8F%96"><span class="toc-text">LBP特征向量的提取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenCV%E4%B8%ADLBP%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">OpenCV中LBP算法的实现</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>